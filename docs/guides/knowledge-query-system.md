# Knowledge Query System

## 1. 개요

### 1.1 목적
참고 문헌의 내용을 바탕으로 사용자 질문에 대해 구조화된 답변을 제공하는 시스템. 질문을 개념적 범주로 변환하고, 관련 섹션들을 병렬로 분석하여 종합적인 답변을 생성한다.

### 1.2 시스템 개념
- 참고 문헌의 목차 구조를 활용한 지식 검색
- 질문-범주 1:1 매핑을 통한 지식 체계 구축
- 병렬 처리를 통한 효율적인 응답 생성

## 2. 준비 단계

### 2.1 참고 문헌 등록
```bash
# 참고 문헌 PDF 파일 경로 지정
PDF_PATH="/path/to/reference.pdf"

# 작업 디렉토리 설정 (예: growing-object-oriented-software/)
WORK_DIR="./reference-name/"
```

### 2.2 목차 파일 생성
참고 문헌의 구조화된 목차를 생성한다.

**스크립트:** `scripts/update_toc_with_numbers_and_labels.py`

**기능:**
- PDF 북마크 추출
- 섹션 번호 자동 추가 (예: 1.1, 2.3)
- 페이지 번호를 실제 인쇄 페이지 레이블로 변환

**실행:**
```bash
uv run python scripts/update_toc_with_numbers_and_labels.py \
  <pdf_path> <output_toc_path>
```

**출력 예시:** `toc.md`
```markdown
## 1. Chapter 1: What Is the Point of Test-Driven Development?
### 1.1 Software Development as a Learning Process (p.3)
### 1.2 Feedback Is the Fundamental Tool (p.4)
## 2. Chapter 2: Test-Driven Development with Objects
### 2.1 A Web of Objects (p.13)
```

### 2.3 섹션 매핑 파일 생성
섹션 번호와 실제 파일 경로를 매핑한다.

**스크립트:** `scripts/generate_section_mapping.py`

**기능:**
- 목차 파일 파싱
- 섹션 제목 → 파일명 변환 (kebab-case)
- JSON 형식의 매핑 파일 생성

**실행:**
```bash
uv run python scripts/generate_section_mapping.py \
  <toc_path> <chapters_dir> <output_json>
```

**출력 예시:** `section_mapping.json`
```json
{
  "1.1": {
    "title": "Software Development as a Learning Process",
    "path": "growing-object-oriented-software/chapter-1/software-development-as-a-learning-process.md"
  },
  "2.1": {
    "title": "A Web of Objects",
    "path": "growing-object-oriented-software/chapter-2/a-web-of-objects.md"
  }
}
```

## 3. 사용 자료

### 3.1 목차 파일 (toc.md)
- **역할:** 참고 문헌의 전체 구조와 섹션 정보 제공
- **형식:** Markdown
- **내용:** 장/섹션 제목, 섹션 번호, 페이지 정보
- **용도:** 사용자 질문과 연관된 섹션 식별

### 3.2 섹션 매핑 파일 (section_mapping.json)
- **역할:** 섹션 번호를 파일 경로로 변환
- **형식:** JSON
- **구조:** `{ "섹션번호": { "title": "제목", "path": "파일경로" } }`
- **용도:** 식별된 섹션의 실제 내용 파일 위치 조회

### 3.3 개별 섹션 파일 (.md)
- **역할:** 각 섹션의 실제 내용
- **형식:** Markdown
- **위치:** `chapter-{N}/섹션파일명.md`
- **용도:** 질의문 기반 답변 생성 소스

## 4. 실행 단계 (5단계 프로세스)

### 4.1 단계 1: 연관 섹션 식별
**입력:** 사용자 질문
**과정:**
1. `toc.md` 읽기
2. 질문 키워드와 목차 내용 비교
3. 관련 섹션 번호 추출

**출력:** 섹션 번호 리스트 (예: 1.2, 1.5, 3.4)

### 4.2 단계 2: 범주 체계 생성
**입력:** 사용자 질문, 식별된 섹션 정보

**범주 생성 우선순위:**
1. **1순위 (목차 기반):** 연관 섹션 제목에서 개념/용어 추출
2. **2순위 (사전 지식):** 목차에 적절한 단서가 없을 경우

**범주 특성:**
- 질문 → 범주 **1:1 대응**
- 세션 내내 **누적 및 확장**
- 새 범주는 기존 범주와의 **관계에 따라 계층적 배치**

**출력 예시:**
```
[범주 체계]
- 테스트
  ├─ 테스트 가독성 (출처: 5.5, 21.2, 21.4)
  └─ Mock 객체 사용 (출처: 2.7, 8.2)
- TDD 프로세스
  └─ 피드백 메커니즘 (출처: 1.2, 4.4)
```

### 4.3 단계 3: 섹션별 질의문 생성
**입력:** 사용자 질문, 식별된 섹션 리스트

**과정:**
각 연관 섹션마다 해당 섹션에 맞는 구체적인 질의문 작성

**출력 예시:**
```
질의문 매핑:
  • 섹션 1.2 → "피드백이 TDD에서 어떻게 활용되는가?"
  • 섹션 1.5 → "전체적인 맥락에서 피드백의 역할은?"
  • 섹션 3.4 → "도구는 피드백을 어떻게 지원하는가?"
```

### 4.4 단계 4: 병렬 응답 생성
**입력:** 질의문-섹션 매핑

**과정:**
1. `section_mapping.json`에서 각 섹션의 파일 경로 조회
2. 각 (질의문 + 섹션 파일) 쌍에 대해 Task 에이전트 생성
3. 모든 Task를 **병렬 실행** (단일 메시지에서 여러 Task 호출)
4. 각 Task는 파일 읽기 → 질의문 기반 답변 생성 → 응답 반환

**출력:** 각 섹션에 대한 개별 응답 리스트

### 4.5 단계 5: 최종 응답 종합
**입력:** 모든 Task의 개별 응답

**과정:**
개별 응답들을 통합하여 하나의 완결된 답변 생성

**출력:** 구조화된 최종 답변 (아래 7장 참고)

## 5. 범주 체계 생성 규칙

### 5.1 질문 → 범주 1:1 대응
- 하나의 질문은 반드시 하나의 범주로 변환
- 범주는 질문을 개념적/용어적으로 표현

### 5.2 범주 생성 우선순위

**1순위: 목차 기반**
- 연관 섹션의 제목에서 핵심 개념/용어 추출
- 참고 문헌의 언어와 용어 체계 유지
- 예: "Test Readability" 섹션 → "테스트 가독성" 범주

**2순위: 사전 지식**
- 목차에 적절한 개념/용어 단서가 없을 경우에만 사용
- 일반적인 소프트웨어 공학 지식 활용

### 5.3 범주 체계 누적 및 확장

**세션 진행에 따른 체계 성장:**
```
질문 1: "테스트 코드 작성 베스트 프랙티스는?"
[범주 체계]
- 테스트 가독성 (출처: 5.5, 21.2, 21.4)

질문 2: "Mock 객체는 언제 사용하나?"
[범주 체계]
- 테스트
  ├─ 테스트 가독성 (출처: 5.5, 21.2, 21.4)
  └─ Mock 객체 사용 (출처: 2.7, 8.2)

질문 3: "피드백 루프는 어떻게 작동하나?"
[범주 체계]
- TDD 프로세스
  └─ 피드백 메커니즘 (출처: 1.2, 4.4)
- 테스트
  ├─ 테스트 가독성 (출처: 5.5, 21.2, 21.4)
  └─ Mock 객체 사용 (출처: 2.7, 8.2)
```

**관계 파악 원칙:**
- 새 범주가 기존 범주의 하위 개념이면 계층 구조로 배치
- 새 범주가 독립적이면 동등한 레벨에 추가
- 관련 있는 범주들은 상위 카테고리로 그룹화

## 6. 실행 옵션

### 6.1 Verbose 모드 (`-v` 또는 `--verbose`)
**표시 내용:**
- 각 단계별 세부 진행 과정
- 중간 결과물 (식별된 섹션, 생성된 범주, 질의문 등)
- Task 병렬 실행 상태
- **각 Task의 개별 응답 전체**

**형식 예시:**
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[단계 4/5] 병렬 응답 생성
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚡ 3개 Task 병렬 실행 시작...
  ├─ Task 1: 섹션 1.2 분석 중
  ├─ Task 2: 섹션 1.5 분석 중
  └─ Task 3: 섹션 3.4 분석 중

[Task 1 응답] 섹션 1.2 - Feedback Is the Fundamental Tool
─────────────────────────────────────────
(응답 내용 전체)

[Task 2 응답] 섹션 1.5 - The Bigger Picture
─────────────────────────────────────────
(응답 내용 전체)

✓ 모든 Task 완료
```

### 6.2 기본 모드 (플래그 없음)
**표시 내용:**
- 진행 단계만 간단히 표시
- Task 개별 응답은 표시하지 않음
- 최종 종합 답변만 출력

**형식 예시:**
```
✓ 단계 1/5 완료: 연관 섹션 식별
✓ 단계 2/5 완료: 범주 체계 생성
✓ 단계 3/5 완료: 질의문 생성
⚡ 단계 4/5 진행 중: 병렬 응답 생성 (3개 Task)
✓ 단계 4/5 완료
✓ 단계 5/5 완료: 최종 응답 종합
```

## 7. 최종 응답 구조

모든 답변은 다음 3개 섹션으로 구성된다:

### 7.1 범주 체계
현재까지 누적된 전체 범주 체계를 계층적으로 표시

```
[범주 체계]
- TDD 프로세스
  └─ 피드백 메커니즘 (출처: 1.2, 4.4)
- 테스트
  ├─ 테스트 가독성 (출처: 5.5, 21.2, 21.4)
  └─ Mock 객체 사용 (출처: 2.7, 8.2)
```

### 7.2 원문 질문
사용자가 입력한 질문을 그대로 표시

```
[질문]
테스트 코드를 작성하는 베스트 프랙티스는?
```

### 7.3 종합 답변
모든 Task의 개별 응답을 통합한 완결된 답변

- Task별 응답을 주제/맥락에 따라 재구성
- 중복 제거 및 일관성 유지
- 참고 문헌의 관점과 용어 체계 유지

## 8. 예시 (워크플로우)

### 8.1 질문
"테스트 코드를 작성하는 베스트 프랙티스는?"

### 8.2 단계별 진행

**[단계 1] 연관 섹션 식별**
```
식별된 섹션: 5.5, 5.8, 21.3, 21.4, 23.2, 24.3
```

**[단계 2] 범주 체계 생성**
```
[범주 체계]
- 테스트 가독성 (출처: 5.5, 5.8, 21.3, 21.4, 23.2, 24.3)
```

**[단계 3] 질의문 생성**
```
• 섹션 5.5 → "가독성 높은 테스트를 작성하는 원칙은 무엇인가?"
• 섹션 5.8 → "테스트에서 무엇을 검증해야 하는가?"
• 섹션 21.3 → "테스트 코드의 표준 구조는?"
• 섹션 21.4 → "테스트 코드를 간결하게 만드는 방법은?"
• 섹션 23.2 → "효과적인 테스트의 크기와 범위는?"
• 섹션 24.3 → "정확한 단언문 작성 방법은?"
```

**[단계 4] 병렬 응답 생성**
6개 Task 동시 실행 → 각 섹션에 대한 개별 응답 생성

**[단계 5] 최종 응답 종합**
개별 응답들을 통합하여 완결된 답변 생성

### 8.3 최종 출력

```
[범주 체계]
- 테스트 가독성 (출처: 5.5, 5.8, 21.3, 21.4, 23.2, 24.3)

[질문]
테스트 코드를 작성하는 베스트 프랙티스는?

[답변]
(종합된 답변 내용)
```

## 9. 기술 스택

- **언어:** Python 3.x
- **PDF 처리:** PyMuPDF (fitz)
- **병렬 처리:** Task 에이전트 (Claude Code)
- **의존성 관리:** uv
- **데이터 형식:** JSON, Markdown
