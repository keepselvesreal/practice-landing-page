# MVP 요구사항 결정 과정 맥락

> **목적**: scouting/MVP-REQUIREMENTS.md가 어떤 과정을 통해 결정되었는지 비판적 피드백을 받기 위한 자료

## 1. 프로젝트 초기 요구사항

### 사용자 원본 요청
**원본 표현**:
> "랜딩페이지 mvp 진행을 위한 탐색 목적의 개발 진행 계획을 세우는 걸 도와줘. 이 탐색 개발 진행의 목적은 개발하려는 랜딩 페이지를 일단 만들어보는 거야. 최소한의 기능과 고려만으로 바탕으로. 학습이나 고려해야할 요소를 실제 진행을 통해 식별하는 것이 목표."

**정제된 표현**:
- 탐색 목적의 랜딩페이지 MVP 개발
- 최소 기능으로 빠르게 구현하여 학습 및 고려사항 식별

### 핵심 기능 요구사항
**원본 표현**:
> "구매자 이름, 이메일, 핸드폰 번호, 배송지 주소 입력 창 입력 후 결제 버튼 누르면 페이팔 샌드박스 이용해 결제 진행. 결제 완료 후 주문 id 나옴. 주문확인 페이지에 주문 id 입력하면 주문자 정보 나오고, 주문 취소 버튼 나옴. 주문 취소 누르면 주문 취소. 재고가 있을 때만 주문 가능해야 함. 주문 취소 시 자동으로 이를 반영한 재고 조정 진행되어야 하고."

**정제된 표현**:
1. 구매자 정보 입력 (이름, 이메일, 전화번호, 배송지)
2. PayPal 샌드박스 결제
3. 주문 ID 발급
4. 주문 조회 기능
5. 주문 취소 기능
6. 재고 관리 (주문 시 차감, 취소 시 복구)

### 기본 제약사항
**원본 표현**:
> "판매하는 상품은 1개, 총 수량은 10개. sqlite3 이용."

**정제된 표현**:
- 단일 상품 판매
- 초기 재고: 10개
- 데이터베이스: SQLite3

### 개발 방법론
**원본 표현**:
> "tdd로 개발할 거고"
> "outside in tdd 방식으로 진행할 거야. 만들 최소한의 기능 관련 개발은 모두 tdd로 진행할 거야."

**정제된 표현**:
- Outside-In TDD 방식
- 모든 핵심 기능을 TDD로 개발

---

## 2. 기술 스택 결정 과정

### 2.1 프론트엔드/백엔드 기술 선택

**질문**: "프론트엔드: React/Vue/Vanilla JS 중 뭘로 할까? 백엔드: Python(Flask/FastAPI)/Node.js 중 선호하는 게 있어?"

**사용자 답변 (원본)**:
> "프런트. html, css와 vanilla js는 필요한 경우만 백엔드는 fastapi."

**결정 사항**:
- 프론트엔드: HTML/CSS + 필요시 Vanilla JS
- 백엔드: FastAPI
- 이유: 탐색 목적이므로 최소한의 복잡도

### 2.2 데이터베이스 드라이버

**질문**: "비동기 DB 드라이버(aiosqlite) 쓸까, 아니면 동기(sqlite3) 쓸까?"

**사용자 답변 (원본)**:
> "동기"

**결정 사항**: 동기 방식 (sqlite3)
**이유**: 탐색 목적이므로 단순하게

### 2.3 템플릿 엔진

**질문**: "FastAPI에서 HTML 렌더링할 때 Jinja2 템플릿 쓸까? 아니면 static HTML 파일만 서빙하고 API 호출 방식?"

**사용자 답변 (원본)**:
> "가장 단순하고 쉬운 방식"

**결정 사항**: Static HTML + API 호출 방식
**이유**: 가장 단순한 구조

### 2.4 CSS 프레임워크

**질문**: "순수 CSS만? 아니면 Bootstrap/Tailwind 같은 거 가볍게 CDN으로?"

**사용자 답변 (원본)**:
> "스타일 최소한. 순수 css"

**결정 사항**: 순수 CSS만 사용
**이유**: MVP에서는 스타일 최소화

### 2.5 패키지 관리

**질문**: "CLAUDE.md에 uv 사용한다고 되어있는데, FastAPI 프로젝트도 uv로 관리하면 돼?"

**사용자 답변 (원본)**:
> "응 uv로"

**결정 사항**: uv로 Python 패키지 관리

---

## 3. 데이터베이스 스키마 진화 과정

### 3.1 초기 스키마 제안

**제안 내용**:
```sql
-- products 테이블
CREATE TABLE products (
    id, name, price, stock, created_at
);

-- orders 테이블
CREATE TABLE orders (
    id, customer_name, customer_email, customer_phone, shipping_address,
    product_id, quantity, total_amount,
    paypal_order_id, paypal_transaction_id, payment_status,
    order_status,
    created_at, updated_at
);
```

**초기 상태 정의**:
- payment_status: PENDING, COMPLETED, CANCELLED
- order_status: ACTIVE, CANCELLED

### 3.2 배송 추적 및 환불 요구사항 추가

**사용자 요청 (원본)**:
> "배송 전, 배송 중, 배송 완료도 추적 가능해야 해. 그리고 환불 경우도 고려 필요."

**결정 사항**:
1. 배송 상태 추가 필요
2. 환불 기능 추가 필요
3. refunds 테이블 신규 생성

**확장된 상태 정의**:
- payment_status: PENDING, COMPLETED, REFUNDED
- order_status: PAYMENT_PENDING, PAID, SHIPPING, DELIVERED, CANCELLED, REFUNDED
- shipping_status: PREPARING, SHIPPED, DELIVERED
- refund_status: PENDING, COMPLETED, FAILED

### 3.3 PayPal Transaction ID 추가 논의

**질문**: "transaction id만 있으면 돼?"

**설명 요청 (원본)**:
> "transaction_id (선택): 실제 거래 ID (capture 후 생성) 이에 관해 더 설명해줘."

**제공된 설명**:
- **order_id**: PayPal 주문 생성 시 발급 (결제 전)
- **transaction_id**: 결제 확정(capture) 시 발급 (실제 거래)
- order_id는 주문 추적용, transaction_id는 환불/정산용

**사용자 결정 (원본)**:
> "transaction id 포함"

**결정 이유**: 환불 기능 구현을 위해 필요

### 3.4 필드 제거 검토

**사용자 요청 (원본)**:
> "products 테이블에서 created at 필요 없지 않아? 상품 1개만 판매하고 추가 없음. 이처럼 제거 가능한 필드 검토해줘"

**검토 결과**:
1. `products.created_at` → **제거** (상품 1개 고정)
2. `orders.unit_price` → **유지** (가격 변동 추적)
3. `orders.updated_at` → **유지** (상태 변경 추적)
4. `refunds.refund_reason` → **유지** (환불 사유 기록)
5. `orders.product_id` → **유지** (확장성)

**사용자 최종 결정 (원본)**:
> "2, 3, 4 유지"

### 3.5 테이블 분리 결정

**사용자 요청 (원본)**:
> "주문과 배송 테이블 분리"

**결정 사항**:
- orders 테이블: 주문 및 결제 정보
- shipments 테이블: 배송 정보 (order_id와 1:1 관계)

**분리 이유**:
- 관심사 분리 (주문 vs 배송)
- 배송 상태는 별도 관리

### 3.6 최종 스키마 구조

**확정된 4개 테이블**:
1. **products**: 상품 정보 (id, name, price, stock)
2. **orders**: 주문 및 결제 정보
3. **shipments**: 배송 정보 (order_id 1:1)
4. **refunds**: 환불 내역

---

## 4. 비즈니스 로직 결정 과정

### 4.1 상품 정보 결정

**질문**: "상품 이름은 뭐로 할까? 가격은?"

**사용자 답변 (원본)**:
> "조선미녀 맑은쌀 선크림 50ml"
> "575"

**확정 정보**:
- 상품명: 조선미녀 맑은쌀 선크림 50ml
- 가격: 575원
- 재고: 10개

### 4.2 주문 수량 정책

**질문**: "한 주문당 1개만 구매 가능? 아니면 여러 개 선택 가능?"

**사용자 답변 (원본)**:
> "여러개 주문 가능. 한 번에 모두 구매 가능."

**결정 사항**:
- 1회 주문 시 다량 구매 가능
- 최대 재고(10개)까지 한 번에 구매 가능

### 4.3 주문 ID 형식

**질문**: "DB auto increment 그대로 쓸까? 아니면 난수 생성해서 보안성 높일까?"

**사용자 답변 (원본)**:
> "난수"

**결정 사항**: `ORD-XXXXXXXX` (8자리 랜덤)
**이유**: 보안성 향상

### 4.4 재고 관리 시점

**질문**: "주문 생성 시 재고 차감? 아니면 결제 완료 시?"

**사용자 답변 (원본)**:
> "주문 생성 시 재고 차감. 주문 취소, 환불 시 재고 자동 복구되게."

**결정 사항**:
- **재고 차감**: 주문 생성 시 (결제 전)
- **재고 복구**: 취소/환불 시 자동

**추가 요구사항 (원본)**:
> "응 동시 주문으로 실제 재고 없는데 주문되는 일 없어야."

**기술적 해결책**: 트랜잭션 처리로 동시성 제어

### 4.5 에러 처리

**질문**: "재고 부족 시 어떻게 처리? 동시 주문으로 재고 꼬이는 거 방지할까?"

**사용자 답변 (원본)**:
> "재고 부족 시 에러 메시지만"

**결정 사항**:
- 재고 부족 시 에러 메시지 반환
- 주문 생성 차단

### 4.6 주문 취소 vs 환불 구분

**초기 혼란**: 주문 취소와 환불의 차이점 불명확

**사용자 명확화 (원본)**:
> "주문 취소는 결제 완료 후에 가능한 것."

**최종 정리**:
- **주문 취소**: 결제 완료 후(`PAID`) 배송 전 취소, 재고 복구
- **환불**: 결제 완료 후 환불 처리, PayPal API 호출, 재고 복구

**질문**: "결제 전 취소는?"

**암묵적 결정**: 결제 전에는 주문이 완료되지 않으므로 취소 개념 불필요

---

## 5. 환불 프로세스 결정

### 5.1 환불 가능 조건

**질문**: "어느 상태까지 환불 가능? 배송 전만? 배송 중도? 배송 완료 후에도?"

**사용자 답변 (원본)**:
> "배송 중, 완료일 때도 환불 가능."

**결정 사항**: 모든 배송 상태에서 환불 가능
- PREPARING (배송 준비 중)
- SHIPPED (배송 중)
- DELIVERED (배송 완료)

### 5.2 환불 처리 방식

**질문**: "PayPal API로 자동 환불? 아니면 관리자가 수동 처리?"

**사용자 답변 (원본)**:
> "환불 요청 누르면 환불 요청 사유 적게. 관리자가 수동 처리"

**결정된 프로세스**:
1. 사용자가 환불 사유 입력 후 요청
2. `refunds` 테이블에 PENDING 상태로 저장
3. 관리자가 목록 확인 후 승인
4. 승인 시 PayPal API 호출하여 환불 처리
5. 주문 상태 REFUNDED로 변경
6. 재고 자동 복구

**추가 요구사항 (원본)**:
> "승인 버튼 누를 경우 한 번 더 최종 확인 후 진행되게."

**UI 처리**: confirm() 다이얼로그로 재확인

---

## 6. 배송 관리 결정

### 6.1 배송 레코드 생성 시점

**질문**: "주문 결제 완료(PAID) 시 자동 생성? 아니면 관리자가 수동으로 생성?"

**사용자 답변 (원본)**:
> "주문 결제 완료 시 자동 생성."

**결정 사항**:
- 결제 완료(order_status = PAID) 시 shipments 레코드 자동 생성
- 초기 상태: PREPARING

### 6.2 배송 상태 변경

**질문**: "배송 상태 변경은 관리자 기능으로 별도 페이지?"

**사용자 답변 (원본)**:
> "배송 상태 변경은 별도 페이지. 사용자가 직접 변경."

**수정된 표현**: "관리자가 별도 페이지에서 직접 변경"

**결정 사항**:
- `/admin/shipments` 페이지 제공
- 관리자가 수동으로 상태 변경
- 송장번호, 택배사 입력 가능

---

## 7. UI/UX 정책 결정

### 7.1 페이지 구성

**확정된 페이지**:

**사용자 페이지**:
1. 메인 랜딩페이지 (`/`)
2. 주문 조회 페이지 (`/order-check`)

**관리자 페이지**:
1. 배송 상태 변경 (`/admin/shipments`)
2. 환불 처리 (`/admin/refunds`)

### 7.2 관리자 인증

**질문**: "관리자 페이지는 간단한 비밀번호 인증? 아니면 인증 없이?"

**사용자 답변 (원본)**:
> "관리자 페이지 인증 불필요"

**결정 사항**: 인증 없이 URL 직접 접근
**이유**: MVP 단순화

### 7.3 관리자 페이지 접근 방식

**질문**: "별도 메뉴/네비게이션 필요? 아니면 URL 직접 입력?"

**사용자 답변 (원본)**:
> "url 직접 입력"

**결정 사항**: 네비게이션 없이 URL 직접 입력

### 7.4 환불 요청 버튼 활성화 규칙

**요구사항 (원본)**:
> "환불 요청이나 완료된 경우 환불 요청 버튼 비활성화. 밑에 환불 진행 중이나 완료 표시되게."

**결정된 규칙**:
- **활성화**: `order_status = PAID` AND 환불 미요청
- **비활성화**:
  - 환불 요청 중 (`refund_status = PENDING`) → "환불 진행 중" 표시
  - 환불 완료 (`refund_status = COMPLETED`) → "환불 완료" 표시

### 7.5 피드백 방식

**질문**: "단순 alert? 아니면 페이지 내 메시지?"

**사용자 답변 (원본)**:
> "단순 alert"

**결정 사항**: `alert()` 사용

---

## 8. 프로젝트 구조 결정

### 8.1 브랜치명

**질문**: "브랜치를 지금 목적에 맞는 걸로 제안해줘"

**초기 제안**:
1. `feature/mvp-landing-page`
2. `feature/paypal-landing-mvp`

**사용자 피드백 (원본)**:
> "scout 의미 들어간 걸로 브랜치 다시 제안. 3개 제안해줘."

**재제안**:
1. `feature/scout-paypal-landing`
2. `feature/mvp-scout`
3. `feature/landing-scout-phase`

**사용자 최종 선택 (원본)**:
> "scout-landing-page-mvp로 가자"

**확정 브랜치**: `scout-landing-page-mvp`

### 8.2 디렉토리 구조

**질문**: "가장 간단한 프로젝트 구조는? 단 내가 파악하기도 쉬워야 해."

**초기 제안**: 프로젝트 루트에 app/, static/, templates/ 배치

**사용자 요청 (원본)**:
> "scouting 폴더에 app static 등 만들어지게 해줘."

**최종 구조**:
```
practice-landing-page/
└── scouting/
    ├── app/
    ├── static/
    ├── templates/
    ├── tests/
    └── ...
```

**이유**: 탐색 프로젝트임을 명시적으로 표현

---

## 9. 의사결정 포인트 요약

### 단순성 우선 결정들
1. **동기 vs 비동기**: 동기 선택 (탐색 목적)
2. **템플릿 엔진**: Static HTML 선택 (단순성)
3. **CSS**: 순수 CSS (프레임워크 불필요)
4. **관리자 인증**: 없음 (MVP 단순화)
5. **피드백**: alert() (추가 구현 불필요)

### 확장성 고려 결정들
1. **product_id 유지**: 상품 1개지만 FK 관계 유지
2. **unit_price 유지**: 가격 변동 추적 가능성
3. **updated_at 유지**: 상태 변경 추적
4. **테이블 분리**: orders/shipments 분리로 관심사 분리

### 보안/안정성 고려 결정들
1. **주문 번호 난수화**: ORD-XXXXXXXX (예측 불가)
2. **트랜잭션 처리**: 재고 동시성 제어
3. **서버 사이드 결제 검증**: PayPal 검증

### 비즈니스 로직 결정들
1. **재고 차감 시점**: 주문 생성 시 (결제 전)
2. **환불 처리**: 관리자 수동 승인 방식
3. **배송 생성**: 결제 완료 시 자동
4. **환불 가능 범위**: 모든 배송 단계

---

## 10. 미결정/보류 사항

### 명시적으로 논의되지 않은 부분들

1. **PayPal 환경 변수**
   - API 키 저장 방식
   - .env 파일 구조

2. **데이터베이스 마이그레이션**
   - 스키마 초기화 방법
   - 초기 데이터 입력 방식

3. **에러 처리 상세**
   - HTTP 상태 코드 정책
   - 에러 메시지 포맷

4. **테스트 범위**
   - Outside-In TDD 시작점
   - 테스트 우선순위

5. **로깅**
   - 로그 레벨
   - 로그 저장 위치

6. **배포**
   - 로컬 실행 방법
   - 포트 설정

---

## 11. 생성된 산출물

### 파일 생성
1. **브랜치**: `scout-landing-page-mvp` 생성
2. **디렉토리**: `/scouting` 생성
3. **문서**: `/scouting/MVP-REQUIREMENTS.md` 생성

### MVP-REQUIREMENTS.md 내용
- 프로젝트 개요
- 데이터베이스 스키마 (4개 테이블)
- 상품 정보
- 상태 플로우 정의
- 비즈니스 로직
- 페이지 구성
- UI/UX 정책
- 프로젝트 구조
- 개발 방법론

---

## 12. 대화 특징 분석

### 의사결정 패턴
1. **점진적 구체화**: 큰 그림 → 세부사항 순서로 진행
2. **양방향 질문**: 개발자가 선택지 제시 → 사용자 선택
3. **즉각적 피드백**: 제안에 대한 빠른 수정 요청
4. **명확화 요청**: 불명확한 부분 적극 질문

### 요구사항 진화
1. **초기**: 기본 주문/결제 기능
2. **1차 확장**: 배송 추적 추가
3. **2차 확장**: 환불 기능 추가
4. **최적화**: 불필요 필드 제거

### 기술적 일관성
- **단순성 원칙 유지**: 모든 기술 선택에서 단순함 우선
- **MVP 범위 준수**: 불필요한 기능 배제
- **확장 가능성 고려**: 최소한의 유연성 확보

---

## 비판적 검토를 위한 질문 제안

1. **스키마 설계**
   - orders와 shipments 분리가 과도한 정규화인가?
   - refunds 테이블이 정말 필요한가? orders 테이블에 통합 가능한가?

2. **재고 관리**
   - 주문 생성 시 재고 차감이 적절한가? (결제 실패 시 문제 발생 가능)
   - 트랜잭션 처리만으로 동시성 문제 해결 충분한가?

3. **주문 취소 vs 환불**
   - 개념 구분이 명확한가?
   - CANCELLED와 REFUNDED 상태를 분리할 필요가 있는가?

4. **환불 프로세스**
   - 관리자 수동 승인이 MVP에 적합한가?
   - 자동화 가능한 부분은 없는가?

5. **보안**
   - 관리자 페이지 인증 없음이 적절한가?
   - 주문번호 난수화만으로 충분한가?

6. **확장성 vs 단순성**
   - product_id, unit_price 등 유지가 과도한 미래 대비인가?
   - YAGNI 원칙 위배 가능성은?

7. **사용자 경험**
   - alert() 사용이 2024년 웹 표준에 적합한가?
   - 환불 요청 후 피드백이 충분한가?

8. **테스트 전략**
   - Outside-In TDD 시작점이 명확하지 않음
   - 테스트 우선순위 미결정

9. **기술 스택**
   - FastAPI + SQLite3 동기 조합의 적절성
   - Static HTML + API 방식이 SEO에 미치는 영향

10. **비즈니스 로직 일관성**
    - 환불 시 재고 복구가 모든 경우에 타당한가?
    - 배송 완료 후 환불 시에도 재고 복구가 맞는가?
