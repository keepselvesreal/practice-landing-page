---
version: 1
created_date: 25-11-07 15:38
note: AI용 Outside-In TDD 실천 가이드
---

# Outside-In TDD 가이드 (AI용)

> 이 문서는 AI가 Outside-In TDD 방식으로 개발할 때 참고할 핵심 프로세스와 원칙을 담고 있습니다.

## 1. Outside-In TDD 프로세스 개요 [1.5, 1.6]

### 1.1 이중 피드백 루프 구조

**외부 루프 (Acceptance Test)**
- 기능이 완성되었는지 측정하는 지표
- 작성 중인 테스트는 빌드에서 제외, 완료된 테스트만 포함하여 항상 통과해야 함
- 한 번에 하나의 Acceptance Test에 집중

**내부 루프 (Unit Test)**
- 개발자를 지원하는 루프
- 작성 후 바로 통과해야 하며, 실패하는 단위 테스트는 절대 커밋하지 않음

### 1.2 End-to-End 테스트의 의미 [1.6]

**반드시 포함해야 할 요소**
- 외부에서만 시스템과 상호작용 (UI, 메시지, 웹 서비스 등)
- 내부 객체를 직접 호출하지 않음
- 빌드 → 배포 → 테스트 전체 프로세스 자동화
- 프로덕션과 유사한 환경에서 실행

**위험 신호**
- Acceptance Test가 내부 객체만 테스트하는 경우
- 실제 entry point가 구현되지 않은 경우

## 2. 워킹 스켈레톤 (Walking Skeleton) 구축 [4.1, 4.2, 4.3, 4.4, 4.5, 10.1, 10.2, 10.3]

### 2.1 워킹 스켈레톤이란 [4.2]

**정의**
- 자동으로 빌드, 배포, end-to-end 테스트 가능한 가장 얇은 실제 기능 조각
- 첫 기능 작업을 시작할 수 있도록 하는 최소한의 자동화, 주요 컴포넌트, 통신 메커니즘 포함
- 애플리케이션 기능은 명백하고 흥미롭지 않을 정도로 단순하게 유지

**예시**
- 데이터베이스 기반 웹 앱: 데이터베이스 필드를 보여주는 평범한 웹 페이지
- 메시징 시스템: UI에 단일 값 표시 + 서버로 핸드셰이크 메시지 전송

### 2.2 워킹 스켈레톤 구축 단계 [4.2, 4.3, 10.1, 10.2]

**Step 1: 시스템 구조 결정 [4.3]**
- 화이트보드 수준의 고수준 구조 스케치 (몇 분 안에 그릴 수 있어야 함)
- 주요 시스템 컴포넌트와 통신 방법 파악
- Big Design Up Front가 아님 - 최소한의 결정만 수행
- 틀릴 수 있다는 전제하에 시작, 나중에 변경 가능

**Step 2: 첫 Acceptance Test 작성 [10.2]**
```
1. When an auction is selling an item,
2. And an Auction Sniper has started to bid in that auction,
3. Then the auction will receive a Join request from the Auction Sniper.
4. When an auction announces that it is Closed,
5. Then the Auction Sniper will show that it lost the auction.
```

**"Wishful Thinking" 방식 적용**
- 구현이 이미 존재하는 것처럼 테스트 작성
- 인프라를 테스트에 맞추는 방식 (반대가 아님)
- 도메인 언어로만 테스트 작성 (기술적 세부사항 숨기기)

**Step 3: 최소 구현으로 통과시키기 [4.2, 10.3]**
- 필요한 컴포넌트 선정 (메시지 브로커, GUI 테스트 프레임워크 등)
- 자동화된 빌드/배포/테스트 프로세스 구축
- 실제 외부 시스템과 연동이 어려우면 Fake/Stub으로 시작하되, 리스크로 기록
- 가능한 빨리 실제 시스템과 통합 테스트 일정 수립

### 2.3 피드백 소스 구축 [4.4]

**자동화로 얻는 피드백**
- 배포 용이성
- 설계 품질
- 코드 품질
- 실제 사용자로부터의 도메인 이해도

**핵심 원칙**
- 모든 것을 test-first로 작성하면 회귀 테스트 스위트가 자동 구축됨
- 주요 변경도 안전하게 수행 가능

### 2.4 불확실성을 조기에 노출 [4.5]

**워킹 스켈레톤의 효과**
- 초기에 스트레스 집중 (후반부는 안정적)
- 기술적/조직적 리스크 조기 발견
- 인프라 구축 후 이후 기능 개발 속도 향상

**예상해야 할 것**
- 워킹 스켈레톤 구축에 예상보다 오래 걸림
- 많은 질문과 결정이 필요함
- 초기 몇 개 기능은 예측 불가능

## 3. Acceptance Test 주도 기능 개발 [5.2, 5.3, 5.4, 5.5, 5.7, 5.8]

### 3.1 기능마다 Acceptance Test로 시작 [5.2]

**테스트 작성 원칙**
- 애플리케이션 도메인 용어만 사용 (기술 용어 배제)
- 데이터베이스, 웹 서버 등 기술적 세부사항 노출 금지
- 구현 가정에 얽매이지 않도록 작성
- 기술 인프라 변경으로부터 테스트 스위트 보호

**효과**
- 요구사항 명확화
- 암묵적 가정 발견
- 사용자 관점에서 시스템 바라보기
- 제한된 기능 집합에 집중

### 3.2 Progress Test vs Regression Test 구분 [5.3]

**Progress Test (진행 중인 테스트)**
- 새로운 기능을 설명하는 테스트
- 기능 구현 전까지 실패 예상
- 빌드에 포함하지 않음
- Red → Green으로 전환되며 진척도 측정

**Regression Test (회귀 테스트)**
- 완료된 기능의 테스트
- 항상 통과해야 함
- 실패는 기존 코드를 망가뜨렸다는 의미
- 빌드에 포함

### 3.3 가장 단순한 성공 케이스부터 시작 [5.4]

**원칙**
- Degenerate case나 실패 케이스부터 시작하지 않기
- 단순한 성공 케이스가 솔루션 구조에 대한 더 나은 피드백 제공
- 성공 케이스 완성 후 실패 케이스 우선순위 결정

**실천 방법**
- 실패 케이스, 리팩토링, 기술적 작업을 노트패드/인덱스 카드에 기록
- 작업 중인 태스크에 집중
- 모든 항목을 처리해야 기능 완료로 간주

### 3.4 읽고 싶은 테스트 작성 [5.5]

**작성 순서**
1. 테스트가 실행되지 않아도 괜찮다고 생각하고 텍스트에만 집중
2. 테스트가 잘 읽히면 지원 인프라 구축
3. 예상한 방식으로 실패하는지 확인
4. 명확한 에러 메시지 확인
5. 에러 메시지가 불명확하면 테스트 코드 조정

**에러 메시지 확인의 중요성**
- 코드에 대한 가정 검증
- 의도 표현의 명확성 확보
- 몇 주 후 코드가 망가졌을 때 디버깅 용이

### 3.5 Input에서 Output으로 개발 [5.7]

**프로세스**
1. 시스템에 들어오는 이벤트부터 시작
2. End-to-end 테스트로 이벤트 시뮬레이션
3. 경계에서 이벤트 처리 객체 작성
4. 필요한 서비스 발견 → 새로운 객체 작성
5. 중간 레이어를 거쳐 도메인 모델로 이동
6. 다른 경계 객체까지 도달하여 외부 응답 생성

**피해야 할 것**
- 도메인 모델 객체부터 단위 테스트 시작
- 나중에 통합 → 불필요하거나 잘못된 기능 구현 위험

### 3.6 동작(Behavior) 테스트, 메서드 테스트 금지 [5.8]

**잘못된 방식**
- `testBidAccepted()` - 무엇을 하는지는 알지만 왜 하는지 모름
- 메서드마다 테스트 작성

**올바른 방식**
- 객체가 제공해야 하는 기능에 집중
- 목표 달성을 위한 클래스 사용법 파악
- 코드 경로 실행이 아닌 협력과 여러 메서드 호출 포함

**테스트 이름 규칙 [21.2]**
- TestDox 컨벤션 사용
- 테스트 이름이 문장처럼 읽히도록 작성
- 대상 클래스는 암묵적 주어
- 예: `holdsItemsInTheOrderTheyWereAdded()`
- 예상 결과, 객체에 대한 액션, 시나리오 동기 모두 포함
- 예: `notifiesListenersThatServerIsUnavailableWhenCannotConnectToItsMonitoringPort()`

### 3.7 표준 테스트 구조 [21.3]

**Canonical Structure**
1. **Setup**: 테스트 컨텍스트 준비
2. **Execute**: 대상 코드 호출
3. **Verify**: 예상 효과 확인
4. **Teardown**: 남은 상태 정리

**Mock 사용 시 변형**
- Expect 단계를 Execute 전에 선언
- 암묵적으로 사후 검증

## 4. Mock을 활용한 협력 객체 설계 [2.3, 2.6, 2.7, 7.4, 7.5]

### 4.1 Messages를 따라가며 설계 [2.3]

**핵심 원칙**
- 도메인 모델은 통신 패턴에 존재
- 정적 분류가 아닌 동적 통신 구조로 사고
- 역할(Role)은 인터페이스로 식별

**CRC (Candidates, Responsibilities, Collaborators)**
- 인덱스 카드로 잠재적 객체 구조 탐색
- 디테일이나 초기 솔루션에 얽매이지 않음
- 역할, 책임, 협력자 관점으로 사고

**Tell, Don't Ask**
- 호출 객체가 원하는 것을 역할 관점에서 설명
- 호출된 객체가 수행 방법 결정
- 내부 구조나 시스템 구조 숨김
- 상호작용 명시적으로 명명

### 4.2 협력 객체 테스트 [2.6]

**문제**
- 명령을 보내는 객체는 상태 쿼리 방법이 없음
- 단위 테스트에서 무엇을 assert할 것인가?

**해결: Mock Objects**
- 이웃 객체를 Mock으로 대체
- 대상 객체가 Mock과 어떻게 통신할지 기대(Expectation) 명시
- Mock이 기대대로 호출되었는지 검증

### 4.3 인터페이스 발견 (Interface Discovery) [2.7, 7.4]

**On-Demand Design**
- 객체 구현 중 필요한 서비스 발견
- 새로운 서비스에 이름 부여하고 Mock으로 구현
- 단위 테스트에서 Mock을 사용해 두 객체 간 관계 명확화
- 해당 서비스를 제공하는 객체 작성
- 기존 객체나 third-party API에 연결될 때까지 반복

**발견 방법 3가지 [7.4]**

1. **Breaking Out (분리)**
   - 큰 객체를 협력하는 작은 객체 그룹으로 분리
   - 테스트가 너무 복잡해지면 실행
   - 신호: 테스트 실패 해석 어려움

2. **Budding Off (파생)**
   - 기능 추가 중 새로운 서비스 필요 발견
   - 서비스 인터페이스 정의 후 Mock으로 관계 명확화
   - 실제 구현 작성
   - 질문: "이게 동작하면 누가 알아야 하나?" → 대상 객체가 아니면 새 협력자 도입

3. **Bundling Up (묶기)**
   - 함께 동작하는 관련 객체 클러스터를 컨테이너 객체로 패키징
   - 추상화로 복잡성 숨김
   - 신호: 테스트 설정이 너무 복잡함

### 4.4 인터페이스로 관계 정의 [7.5]

**인터페이스 사용 원칙**
- 객체 간 관계를 통신 프로토콜로 정의
- 역할 이름과 수용할 메시지 설명

**좁은 인터페이스 선호**
- 메서드가 적을수록 역할이 명확함
- 어댑터와 데코레이터 작성 용이
- 클라이언트에서 "Pull" 방식으로 인터페이스 생성 → 과도한 정보 유출 방지

**"Impl" 클래스 금지**
- `BookingImpl`은 중복 (이미 `implements Booking`에 표현됨)
- 구현의 특정 사항을 이름에 포함: HTTP, Database, Bounded 등
- 좋은 이름이 없으면 인터페이스 설계 재검토 필요

## 5. 테스트-주도 리팩터링 [6.7, 6.8, 7.6, 7.7]

### 5.1 Context Independence [6.7]

**정의**
- 각 객체가 실행되는 시스템에 대한 내장된 지식이 없어야 함
- 다른 상황에서 재사용 가능한 동작 단위

**구현 방법**
- 필요한 정보를 외부에서 전달받음
  - Permanent: 생성자로 전달
  - Transient: 메서드 파라미터로 전달
- 각 객체는 작업에 필요한 정보만 전달받음
- 적절한 추상화로 감싸서 어휘 매칭

**효과**
- 관계가 명시적으로 정의됨 (객체 자신과 분리)
- 객체가 단순해짐 (자체 관계 관리 불필요)
- 관계 관리 단순화 (Factory 객체에서 함께 생성/조합)
- 재구성으로 시스템 변경 가능

### 5.2 적절한 정보 숨기기 [6.8]

**원칙**
- Encapsulation은 거의 항상 좋지만 잘못된 장소에 숨기면 문제 발생

**판별 방법**
- "Hide the X in Y" 형태로 재구성
- 예: "Hide the name of the application's log file in the PricingPolicy class" → 잘못됨
- Context independence 위반 여부 확인
- 서로 다른 도메인 수준의 개념은 분리

### 5.3 인터페이스도 리팩터링 [7.6]

**유사 인터페이스 발견 시**
- 단일 개념인지 확인 후 병합 고려
- 공통 역할 추출 → 더 많은 컴포넌트가 "플러그 호환"
- 높은 추상화 수준에서 작업 가능

**다른 개념 발견 시**
- 명시적으로 구분
- 컴파일러가 올바른 조합만 허용하도록 보장
- 이름 재고려

**구현 시작 시점에 리팩터링**
- 구현 클래스 구조가 불명확하면 인터페이스도 재검토
- 책임이 너무 많은지 확인 → 분리 필요 신호

### 5.4 객체 조합으로 시스템 동작 표현 [7.7]

**원칙**
- 하위 수준 객체를 빌딩 블록으로 사용
- 더 높은 능력의 객체 구성
- 객체의 웹 형성

**레이어 구분**
1. **Implementation Layer**: 객체 그래프, 이벤트 응답으로 동작
2. **Declarative Layer**: 구현 레이어 객체 조립, 작은 "sugar" 메서드 사용

**효과**
- 유연한 애플리케이션 구조
- 상대적으로 적은 코드
- 관련 시나리오가 많은 경우 특히 유용
- 확장 용이: 새로운 플러그 호환 컴포넌트 작성 후 추가

## 6. 외부 라이브러리/Third-Party 코드 다루기 [8.2, 8.3]

### 6.1 직접 소유한 타입만 Mock [8.2]

**이유**
- Third-party 코드의 깊은 이해 부족
- 문서가 불완전하거나 부정확
- 버그가 있을 수 있음
- 코드 변경 불가 → 설계 피드백 반영 불가능

**문제점**
- Third-party 타입을 Mock한 테스트는 복잡해짐
- 실제 동작과 Stub/Mock 동작 일치 확인 어려움
- 라이브러리 업그레이드 시 테스트 유효성 재검증 필요

### 6.2 Adapter Layer 작성 [8.2]

**구조**
- TDD로 설계한 인터페이스 (애플리케이션 도메인 용어)
- Third-party API를 사용해 인터페이스 구현하는 Adapter 객체
- 가능한 얇게 유지 (테스트하기 어렵고 brittle한 코드 최소화)

**테스트**
- 집중된 Integration Test로 Adapter 테스트
- Third-party API 동작 방식 이해 확인
- Unit Test보다 적은 수 → 빌드 속도 영향 최소화

**효과**
- 애플리케이션 용어로 관계 정의
- 하위 수준 기술 개념이 도메인 모델로 유출 방지

### 6.3 Integration Test에서 애플리케이션 객체 Mock [8.3]

**Callback 패턴**
- Adapter가 애플리케이션 코드 호출 필요 시 (이벤트 기반 라이브러리)
- 애플리케이션 callback (도메인 용어로 정의) 제공
- Adapter가 external library callback으로 변환

**테스트 방법**
- 애플리케이션에 정의된 callback 인터페이스만 Mock
- Adapter가 도메인 간 이벤트 변환을 올바르게 하는지 검증
- Third-party 라이브러리는 실제 사용

## 7. 테스트가 주는 설계 피드백 듣기 [5.9, 20.6, 20.7, 20.8]

### 7.1 테스트 난이도 = 설계 문제 신호 [5.9]

**원칙**
- 테스트하기 어려운 코드 = 나중에 변경하기 어려운 코드
- 테스트를 설계 문제의 조기 경고로 활용
- 문제가 신선할 때 수정

**프로세스**
- 다음 실패 테스트 작성이 어려우면 프로덕션 코드 설계 재검토
- 리팩터링 후 테스트 계속 진행

### 7.2 설계 문제 신호들

**Bloated Constructor [20.6]**

*증상*
- 생성자 인자가 길고 다루기 어려움

*진단 1: 암묵적 개념 존재*
- 함께 사용되는 인자들 식별
- 같은 lifetime을 가진 인자들 식별
- 새로운 객체로 묶기
- 적절한 이름 부여

*예시*
```java
// Before
MessageProcessor(unpacker, auditor, counterpartyFinder,
                 locationFinder, domesticNotifier, importedNotifier)

// After - locationFinder + notifiers → MessageDispatcher
MessageProcessor(unpacker, auditor, MessageDispatcher)
```

*효과*
- 명확한 단계 분리 (receive, process, forward)
- 라우팅 코드 분리 → 책임 감소
- 의존성 스코프 명확화
- 단위 테스트 간소화

**Confused Object [20.7]**

*증상*
- 생성자는 bloated하지만 암묵적 개념이 없음
- 관련 없는 여러 책임 보유

*예시*
```java
Handset(network, camera, display, dataNetwork,
        addressBook, storage, tuner, ...)
```

*진단*
- 객체가 너무 큼
- 관련 없는 기능들이 서로 간섭

*신호: 테스트 스위트*
- 다양한 기능 테스트가 서로 관련 없음
- 한 영역의 주요 변경이 다른 영역에 영향 없음
- 테스트를 공유 없이 슬라이스할 수 있으면 객체도 분리

*해결*
- 객체 분리
- 각 책임을 별도 객체로

**Too Many Dependencies [20.8]**

*증상*
- 생성자에 많은 인자, 하지만 실제 Dependency는 일부

*진단*
- Dependency vs Notification vs Adjustment 구분
- Dependency만 생성자로 전달 (final 필드)
- Notification과 Adjustment는 기본값 설정 후 setter로 재구성

*예시*
```java
// Before: 모두 생성자 인자
RacingCar(track, driver, tyres, suspension,
          frontWing, backWing, fuelLoad, listener)

// After: track만 dependency
RacingCar(track)
private DrivingStrategy driver = borderlineAggressiveDriving();
public void setDriver(DrivingStrategy driver) {...}
```

## 참고 문헌

본 가이드는 "Growing Object-Oriented Software, Guided by Tests" (Steve Freeman, Nat Pryce)의 다음 섹션들을 기반으로 작성되었습니다:

- 프로세스: 1.5, 1.6, 4.1
- 워킹 스켈레톤: 4.2, 4.3, 4.4, 4.5, 10.1, 10.2, 10.3
- Acceptance Test: 5.2, 5.3, 5.4, 5.5, 5.7, 5.8, 21.2, 21.3
- Mock & 협력 객체: 2.3, 2.6, 2.7, 7.4, 7.5
- 리팩터링: 6.7, 6.8, 7.6, 7.7
- Third-party: 8.2, 8.3
- 설계 피드백: 5.9, 20.6, 20.7, 20.8
