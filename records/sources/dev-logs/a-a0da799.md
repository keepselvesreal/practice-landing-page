# 나


# ai

## 작업 내용

### 문제 발생
- E2E 테스트 실행 시 서버 연결 실패: `net::ERR_CONNECTION_REFUSED at http://localhost:8000/`
- 서버 로그 확인 결과: `PaymentServiceError: PayPal credentials not configured`
- `.env` 파일에는 `PAYPAL_CLIENT_ID`, `PAYPAL_CLIENT_SECRET` 존재함

### 원인 분석
- `backend/api/orders.py:12`: 모듈 레벨에서 `paypal_adapter = PayPalAdapter()` 인스턴스화
- FastAPI 시작 → `main.py:12`에서 `from backend.api.orders import router` 실행
- → `orders.py` 모듈 로드 시점에 `PayPalAdapter()` 초기화 시도
- → 이 시점에 환경변수가 로드되지 않음 → 초기화 실패

### 해결 방법
**파일**: `backend/main.py`
```python
# Before
"""FastAPI 메인 애플리케이션"""
from pathlib import Path
from fastapi import FastAPI
...

# After (3-6행 추가)
"""FastAPI 메인 애플리케이션"""
from pathlib import Path
from dotenv import load_dotenv

# ⭐ 모든 import보다 먼저 환경변수 로드 (orders.py의 PayPalAdapter 초기화 전)
load_dotenv()

from fastapi import FastAPI
...
```

**핵심**: `load_dotenv()`를 `from backend.api.orders import router`보다 먼저 실행

### 검증
- 서버 시작 성공: `curl http://localhost:8000/health` → `{"status":"ok"}`
- E2E 테스트 통과: `test_customer_can_create_order_and_pay_with_paypal` PASSED
- 커밋: `b6300f8`

---

## 이해 요소

### Python 모듈 로드 시점과 인스턴스 초기화의 관계

**핵심**: 파이썬에서 `import` 문은 모듈을 로드하면서 모듈의 최상위 코드를 **즉시 실행**한다.

```python
# orders.py (문제가 발생한 코드)
from backend.services.payment import PayPalAdapter

paypal_adapter = PayPalAdapter()  # ⭐ 이 줄이 import 시점에 실행됨
```

**실행 순서**:
1. `main.py` 실행 시작
2. `from backend.api.orders import router` 실행
3. → `orders.py` 모듈 로드 시작
4. → `paypal_adapter = PayPalAdapter()` 실행 (모듈 최상위 코드)
5. → `PayPalAdapter.__init__()` 내부에서 `os.getenv("PAYPAL_CLIENT_ID")` 호출
6. → 환경변수 없음 → 에러 발생

**해결의 원리**: `load_dotenv()`를 `import router`보다 먼저 실행하면:
1. `.env` 파일 내용이 `os.environ`에 로드됨
2. 이후 `orders.py` 로드 시 환경변수가 이미 존재
3. `PayPalAdapter()` 초기화 성공

---

## 판단 요소

### 환경변수 로드 위치 선택

**상황**: `.env` 파일은 있지만 서버 시작 시 로드되지 않음

**선택지 1**: `orders.py`에서 직접 `load_dotenv()` 호출
- ❌ API 라우터가 환경 설정에 대한 책임을 가지게 됨 (단일 책임 원칙 위반)
- ❌ 다른 모듈에서도 환경변수가 필요하면 중복 코드 발생

**선택지 2**: `main.py` 최상단에 `load_dotenv()` 추가 (채택)
- ✅ 애플리케이션 진입점에서 중앙화된 설정 관리
- ✅ 모든 모듈이 환경변수에 접근 가능
- ✅ 환경 설정 책임이 명확히 분리됨

**현재 상황에서 최선인 이유**:
1-a 단계에서는 설정 관리 복잡도 최소화 필요, 빠른 검증이 목표

---

## 개선 요소

### 함수/클래스 차원
**현재 한계**: 모듈 레벨 인스턴스화로 인한 테스트 어려움
- 테스트에서 Mock 주입 어려움
- 환경변수 로드 순서에 의존적

**개선 방향**: Dependency Injection
```python
def get_payment_service() -> PaymentService:
    return PayPalAdapter()

@router.post("")
async def create_order(
    order_data: OrderCreate,
    payment_service: PaymentService = Depends(get_payment_service)
):
    paypal_result = payment_service.create_order(...)
```

**이점**:
- 테스트 시 Mock으로 쉽게 교체
- 생명주기 관리 용이

### 모듈 차원
**현재 한계**: 환경변수 검증이 분산되어 있음 (각 Adapter에서 개별 검증)

**개선 방향**: 설정 관리 모듈 (`backend/config.py`)
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    paypal_client_id: str
    paypal_client_secret: str

    class Config:
        env_file = ".env"

settings = Settings()  # 앱 시작 시 모든 환경변수 검증
```

**이점**:
- 애플리케이션 시작 시점에 설정 오류 즉시 발견 (fail-fast)
- 타입 검증 자동화
- 어떤 설정이 필요한지 코드로 명확히 문서화

### 아키텍처 차원
**현재 한계**: 환경변수 로드가 `main.py` import 순서에 암묵적으로 의존

**개선 방향**: FastAPI 생명주기 이벤트 활용
```python
@app.on_event("startup")
async def startup_event():
    # 필수 환경변수 검증
    required_vars = ["PAYPAL_CLIENT_ID", "PAYPAL_CLIENT_SECRET"]
    missing = [var for var in required_vars if not os.getenv(var)]
    if missing:
        raise RuntimeError(f"Missing env vars: {missing}")

    # Adapter 초기화
    app.state.payment_service = PayPalAdapter()
```

**이점**:
- 환경변수 의존성이 명시적으로 선언됨
- 애플리케이션 상태와 외부 서비스 연결을 생명주기에 맞춰 관리
- 에러 메시지에서 정확히 무엇이 누락되었는지 확인 가능