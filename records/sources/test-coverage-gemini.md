실패한 테스트 케이스가 커버리지 측정에 어떻게 영향을 미치는지에 대한 아주 중요한 질문입니다.

결론부터 말씀드리면, **테스트 성공 여부와 관계없이 코드가 실행된 라인은 모두 커버리지로 인정**됩니다.

핵심 원리를 단계별로 설명해 드립니다.

### 1. 테스트 결과와 커버리지 측정은 독립적입니다.

`pytest-cov` (그리고 `coverage.py`)는 코드가 "올바르게 실행되었는지(테스트 성공)" 여부와는 무관하게, 코드가 **"실제로 실행되었는지(코드 경로 통과)"** 여부만을 측정합니다.

| 구분 | 코드 커버리지 (Coverage) | 테스트 결과 (Test Result) |
| :--- | :--- | :--- |
| **측정 목적** | 소스 코드의 **실행된 양** 측정 | 소스 코드의 **기능적 정확성** 검증 |
| **실패한 테스트의 영향** | **코드가 실행된 시점까지는** 모두 커버리지로 기록됩니다. | 테스트 실패(`AssertionError`, 예외 발생)로 기록됩니다. |

### 2. 실패한 테스트의 커버리지 측정 과정

테스트가 실패하더라도 커버리지 측정은 다음과 같이 진행됩니다.

#### A. 실행된 라인 (Covered Lines)

테스트 함수가 실행을 시작해서 실패(예: `assert` 실패, 예외 발생)로 인해 **중단되는 시점까지 실행된 소스 코드의 모든 라인**은 커버된 것으로 간주됩니다.

* **예시:** `function_A()`를 호출하는 테스트가 있고, `function_A()`의 10라인 중 5라인을 실행한 뒤 6번째 라인에서 `AssertionError`가 발생해 테스트가 실패했다고 가정합니다.
    * **결과:** 이 테스트는 실패했지만, `function_A()`의 **1라인부터 5라인까지는 커버리지에 기여**한 것으로 기록됩니다.

#### B. 누락된 라인 (Missing Lines)

테스트 실패로 인해 **실행이 중단되면서 끝까지 도달하지 못한 나머지 소스 코드 라인**은 누락된 것으로 기록됩니다.

* **예시:** 위와 동일한 상황에서, 7라인부터 10라인까지의 코드는 테스트 실패로 인해 실행되지 못했으므로 **누락된 것으로 기록**됩니다.

### 3. 결론

실패한 테스트는 버그를 발견했다는 의미이므로 고쳐야 하지만, **커버리지 관점에서는 유효한 실행 기록**을 남깁니다.

이는 커버리지 도구가 "코드가 실행은 되었지만, 테스트가 기대한 결과를 내지 못했다"는 사실을 구분하기 때문입니다. 실패한 테스트도 코드의 일부 경로를 실행시켰다면, 그 부분은 커버리지 %에 긍정적으로 기여합니다.

따라서, 커버리지를 측정하는 것은 **테스트가 성공하는지**와는 별개로 **어떤 코드가 한 번이라도 호출되었는지**를 확인하는 과정이라고 이해하시면 됩니다.