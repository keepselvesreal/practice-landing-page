다음 구조로 시스템 아키텍처 문서를 작성하세요:

## 메타데이터

created_at: [현재 한국 시간 YYYY-MM-DD HH:mm:ss 형식]
address: [파일 경로]
links:
  in: []  # 현재 파일을 참조하는 파일의 상대 경로
  out: []  # 현재 파일이 참조하는 파일의 상대 경로
tags: []
notes: ""

---

## 1. 압축 내용

이 시스템의 아키텍처를 **한 문장**으로 요약
- 시스템의 핵심 구조와 설계 철학

---

## 2. 핵심 내용

**아키텍처 패턴**
- 2-3줄로 선택한 아키텍처 패턴 설명
- 예: 마이크로서비스, 모놀리스, 레이어드, 이벤트 기반 등

**핵심 컴포넌트**
- 시스템을 구성하는 주요 컴포넌트 3-5개 나열
- 각 컴포넌트의 핵심 역할 한 줄씩

**기술 스택**
- 주요 기술 선택 (언어, 프레임워크, DB, 인프라)
- 선택 이유 간략히

---

## 3. 상세 내용

### 📋 목차
- [시스템 구조](#시스템-구조)
- [컴포넌트 상세](#컴포넌트-상세)
- [데이터 설계](#데이터-설계)
- [품질 속성](#품질-속성)
- [배포 아키텍처](#배포-아키텍처)
- [ADR (Architecture Decision Records)](#adr)

---

### 시스템 구조

#### 전체 다이어그램

시스템 전체 구조를 다이어그램으로 표현
- ASCII 다이어그램 또는 별도 이미지 첨부
- 주요 컴포넌트와 연결 관계 표시

**런타임 흐름:**
- 요청이 시스템을 통과하는 주요 경로
- 예: Client → Gateway → Service → Database

**의존성 방향:**
- 컴포넌트 간 의존 관계
- 화살표로 방향 표시
- 순환 의존 여부 명시

---

#### 컴포넌트 목록

주요 컴포넌트를 표로 정리

| 컴포넌트 | 책임 | 기술 스택 |
|----------|------|-----------|
| [컴포넌트명] | [핵심 역할] | [사용 기술] |
| ... | ... | ... |

---

#### 컴포넌트 간 관계

**통신 방식:**
- 동기/비동기 구분
- 프로토콜 (REST, gRPC, 메시지 큐 등)
- 데이터 형식 (JSON, Protocol Buffers 등)

**의존성 규칙:**
- 컴포넌트 간 의존 방향
- 허용/금지되는 통신 패턴
- 순환 의존 방지 규칙

**제약 사항:**
- 직접 DB 접근 규칙
- 컴포넌트 경계 침범 금지 사항
- 기타 아키텍처 제약

---

### 컴포넌트 상세

각 주요 컴포넌트별로 다음 항목 작성:

#### [컴포넌트명 1]

**책임 (Responsibility):**
- 이 컴포넌트가 담당하는 핵심 기능
- 3-5개 항목으로 간결하게

**경계 (Boundary):**

*담당하는 것:*
- 이 컴포넌트의 범위 내 작업

*담당하지 않는 것:*
- 명시적으로 제외되는 책임
- 다른 컴포넌트에 위임하는 작업

**통신 규칙:**

*제공하는 인터페이스:*
- API 엔드포인트 또는 이벤트 목록
- 간단한 설명만 (상세는 API 문서)

*사용하는 인터페이스:*
- 의존하는 다른 컴포넌트의 API
- 외부 서비스 (써드파티 API 등)

*데이터 접근:*
- 소유하는 데이터/테이블
- 접근 금지되는 데이터

---

#### [컴포넌트명 2]

(위와 동일한 형식으로 반복)

---

### 데이터 설계

#### 데이터 모델

**컴포넌트별 데이터 소유권:**

각 컴포넌트가 소유하는 주요 엔티티와 스키마
- SQL 스키마 또는 NoSQL 구조
- 엔티티 간 관계
- 주요 인덱스

**데이터 소유권 원칙:**
- 한 테이블/컬렉션은 한 컴포넌트만 소유
- 다른 컴포넌트는 API를 통해서만 접근
- 외래 키 사용 규칙

---

#### 데이터 플로우

주요 비즈니스 플로우별 데이터 이동 경로
- 시퀀스 다이어그램 또는 단계별 설명
- 데이터 변환 과정
- 트랜잭션 경계

---

### 품질 속성

#### 보안 설계

**인증/인가:**
- 인증 방식 (JWT, Session, OAuth 등)
- 토큰 만료 정책
- 권한 관리 방식

**데이터 보호:**
- 암호화 알고리즘 및 적용 대상
- 민감 정보 처리 방식
- 통신 보안 (TLS/SSL)

**API 보안:**
- Rate Limiting
- CORS 정책
- Input Validation
- 기타 보안 조치

---

#### 확장성/성능 전략

**수평 확장:**
- Stateless 설계 여부
- 세션/상태 관리 방식
- 로드 밸런싱 전략

**캐싱 전략:**
- 캐싱 대상 데이터
- TTL 정책
- 캐시 무효화 전략
- 사용 기술 (Redis, Memcached 등)

**성능 목표:**
- API 응답 시간 목표
- 동시 접속자 처리 목표
- DB 쿼리 성능 목표

**최적화 방안:**
- 데이터베이스 최적화 (인덱스, 쿼리 등)
- 네트워크 최적화
- 리소스 사용 최적화

---

### 배포 아키텍처

#### 인프라 구성

배포 환경의 물리적/논리적 구조
- 서버 구성
- 네트워크 구성
- 로드 밸런서
- 다이어그램 포함

**환경 구성:**

각 환경별 구성 차이

| 환경 | 용도 | 배포 방식 | 특이사항 |
|------|------|-----------|----------|
| Development | [용도] | [방식] | [메모] |
| Staging | [용도] | [방식] | [메모] |
| Production | [용도] | [방식] | [메모] |

**배포 전략:**
- 배포 방식 (Blue-Green, Rolling, Canary 등)
- 롤백 계획
- 다운타임 최소화 전략

---

### ADR (Architecture Decision Records)

중요한 아키텍처 결정 사항을 기록

#### ADR-001: [결정 제목]

**날짜:** YYYY-MM-DD

**상태:** Proposed | Accepted | Deprecated | Superseded

**컨텍스트:**
- 어떤 상황/문제가 있었는가
- 어떤 요구사항이 있었는가
- 제약 사항은 무엇인가

**결정:**
- 무엇을 선택했는가
- 핵심 내용

**대안:**
- 고려했던 다른 옵션들
- 각 옵션의 장단점
- 왜 채택되지 않았는가

**결과:**
- 이 결정의 장점
- 예상되는 단점/트레이드오프
- 후속 조치 필요 사항

---

#### ADR-002: [결정 제목]

(위와 동일한 형식으로 반복)

---

## 작성 원칙

1. **컴포넌트 경계 명확화**: 책임과 경계를 명시하여 Epic 분해 기준 제공
2. **기술 결정 근거**: 모든 주요 기술 선택은 ADR로 문서화
3. **데이터 소유권**: 각 컴포넌트가 소유하는 데이터 명확히 정의
4. **확장 가능성**: 초기 설계부터 확장성 고려
5. **보안 우선**: 보안은 나중이 아닌 설계 단계부터
6. **다이어그램 활용**: 텍스트보다 다이어그램으로 구조 표현
7. **실행 가능성**: 이 문서만으로 구현 시작 가능해야 함
8. **변경 이력**: ADR로 주요 변경 사항 추적