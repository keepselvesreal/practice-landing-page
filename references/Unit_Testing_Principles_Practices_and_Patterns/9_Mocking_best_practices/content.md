Line 1: 
Line 2: --- 페이지 238 ---
Line 3: 216
Line 4: Mocking best practices
Line 5: As you might remember from chapter 5, a mock is a test double that helps to emu-
Line 6: late and examine interactions between the system under test and its dependencies.
Line 7: As you might also remember from chapter 8, mocks should only be applied to
Line 8: unmanaged dependencies (interactions with such dependencies are observable by
Line 9: external applications). Using mocks for anything else results in brittle tests (tests that
Line 10: lack the metric of resistance to refactoring). When it comes to mocks, adhering to
Line 11: this one guideline will get you about two-thirds of the way to success.
Line 12:  This chapter shows the remaining guidelines that will help you develop inte-
Line 13: gration tests that have the greatest possible value by maxing out mocks’ resistance
Line 14: to refactoring and protection against regressions. I’ll first show a typical use of
Line 15: mocks, describe its drawbacks, and then demonstrate how you can overcome
Line 16: those drawbacks.
Line 17: This chapter covers
Line 18: Maximizing the value of mocks
Line 19: Replacing mocks with spies
Line 20: Mocking best practices
Line 21: 
Line 22: --- 페이지 239 ---
Line 23: 217
Line 24: Maximizing mocks’ value
Line 25: 9.1
Line 26: Maximizing mocks’ value
Line 27: It’s important to limit the use of mocks to unmanaged dependencies, but that’s only
Line 28: the first step on the way to maximizing the value of mocks. This topic is best explained
Line 29: with an example, so I’ll continue using the CRM system from earlier chapters as a sam-
Line 30: ple project. I’ll remind you of its functionality and show the integration test we ended
Line 31: up with. After that, you’ll see how that test can be improved with regard to mocking.
Line 32:  As you might recall, the CRM system currently supports only one use case: chang-
Line 33: ing a user’s email. The following listing shows where we left off with the controller.
Line 34: public class UserController
Line 35: {
Line 36: private readonly Database _database;
Line 37: private readonly EventDispatcher _eventDispatcher;
Line 38: public UserController(
Line 39: Database database,
Line 40: IMessageBus messageBus,
Line 41: IDomainLogger domainLogger)
Line 42: {
Line 43: _database = database;
Line 44: _eventDispatcher = new EventDispatcher(
Line 45: messageBus, domainLogger);
Line 46: }
Line 47: public string ChangeEmail(int userId, string newEmail)
Line 48: {
Line 49: object[] userData = _database.GetUserById(userId);
Line 50: User user = UserFactory.Create(userData);
Line 51: string error = user.CanChangeEmail();
Line 52: if (error != null)
Line 53: return error;
Line 54: object[] companyData = _database.GetCompany();
Line 55: Company company = CompanyFactory.Create(companyData);
Line 56: user.ChangeEmail(newEmail, company);
Line 57: _database.SaveCompany(company);
Line 58: _database.SaveUser(user);
Line 59: _eventDispatcher.Dispatch(user.DomainEvents);
Line 60: return "OK";
Line 61: }
Line 62: }
Line 63: Note that there’s no longer any diagnostic logging, but support logging (the IDomain-
Line 64: Logger interface) is still in place (see chapter 8 for more details). Also, listing 9.1
Line 65: introduces a new class: the EventDispatcher. It converts domain events generated by
Line 66: Listing 9.1
Line 67: User controller
Line 68: 
Line 69: --- 페이지 240 ---
Line 70: 218
Line 71: CHAPTER 9
Line 72: Mocking best practices
Line 73: the domain model into calls to unmanaged dependencies (something that the control-
Line 74: ler previously did by itself), as shown next.
Line 75: public class EventDispatcher
Line 76: {
Line 77: private readonly IMessageBus _messageBus;
Line 78: private readonly IDomainLogger _domainLogger;
Line 79: public EventDispatcher(
Line 80: IMessageBus messageBus,
Line 81: IDomainLogger domainLogger)
Line 82: {
Line 83: _domainLogger = domainLogger;
Line 84: _messageBus = messageBus;
Line 85: }
Line 86: public void Dispatch(List<IDomainEvent> events)
Line 87: {
Line 88: foreach (IDomainEvent ev in events)
Line 89: {
Line 90: Dispatch(ev);
Line 91: }
Line 92: }
Line 93: private void Dispatch(IDomainEvent ev)
Line 94: {
Line 95: switch (ev)
Line 96: {
Line 97: case EmailChangedEvent emailChangedEvent:
Line 98: _messageBus.SendEmailChangedMessage(
Line 99: emailChangedEvent.UserId,
Line 100: emailChangedEvent.NewEmail);
Line 101: break;
Line 102: case UserTypeChangedEvent userTypeChangedEvent:
Line 103: _domainLogger.UserTypeHasChanged(
Line 104: userTypeChangedEvent.UserId,
Line 105: userTypeChangedEvent.OldType,
Line 106: userTypeChangedEvent.NewType);
Line 107: break;
Line 108: }
Line 109: }
Line 110: }
Line 111: Finally, the following listing shows the integration test. This test goes through all out-
Line 112: of-process dependencies (both managed and unmanaged).
Line 113: [Fact]
Line 114: public void Changing_email_from_corporate_to_non_corporate()
Line 115: {
Line 116: Listing 9.2
Line 117: Event dispatcher
Line 118: Listing 9.3
Line 119: Integration test
Line 120: 
Line 121: --- 페이지 241 ---
Line 122: 219
Line 123: Maximizing mocks’ value
Line 124: // Arrange
Line 125: var db = new Database(ConnectionString);
Line 126: User user = CreateUser("user@mycorp.com", UserType.Employee, db);
Line 127: CreateCompany("mycorp.com", 1, db);
Line 128: var messageBusMock = new Mock<IMessageBus>();   
Line 129: var loggerMock = new Mock<IDomainLogger>();     
Line 130: var sut = new UserController(
Line 131: db, messageBusMock.Object, loggerMock.Object);
Line 132: // Act
Line 133: string result = sut.ChangeEmail(user.UserId, "new@gmail.com");
Line 134: // Assert
Line 135: Assert.Equal("OK", result);
Line 136: object[] userData = db.GetUserById(user.UserId);
Line 137: User userFromDb = UserFactory.Create(userData);
Line 138: Assert.Equal("new@gmail.com", userFromDb.Email);
Line 139: Assert.Equal(UserType.Customer, userFromDb.Type);
Line 140: object[] companyData = db.GetCompany();
Line 141: Company companyFromDb = CompanyFactory.Create(companyData);
Line 142: Assert.Equal(0, companyFromDb.NumberOfEmployees);
Line 143: messageBusMock.Verify(
Line 144:   
Line 145: x => x.SendEmailChangedMessage(
Line 146:   
Line 147: user.UserId, "new@gmail.com"),  
Line 148: Times.Once);
Line 149:   
Line 150: loggerMock.Verify(
Line 151:   
Line 152: x => x.UserTypeHasChanged(
Line 153:   
Line 154: user.UserId,
Line 155:   
Line 156: UserType.Employee,
Line 157:   
Line 158: UserType.Customer),
Line 159:   
Line 160: Times.Once);
Line 161:   
Line 162: }
Line 163: This test mocks out two unmanaged dependencies: IMessageBus and IDomainLogger.
Line 164: I’ll focus on IMessageBus first. We’ll discuss IDomainLogger later in this chapter.
Line 165: 9.1.1
Line 166: Verifying interactions at the system edges
Line 167: Let’s discuss why the mocks used by the integration test in listing 9.3 aren’t ideal in
Line 168: terms of their protection against regressions and resistance to refactoring and how we
Line 169: can fix that.
Line 170: TIP
Line 171: When mocking, always adhere to the following guideline: verify interac-
Line 172: tions with unmanaged dependencies at the very edges of your system.
Line 173: The problem with messageBusMock in listing 9.3 is that the IMessageBus interface
Line 174: doesn’t reside at the system’s edge. Look at that interface’s implementation.
Line 175:  
Line 176: Sets up the 
Line 177: mocks
Line 178: Verifies the 
Line 179: interactions 
Line 180: with the mocks
Line 181: 
Line 182: --- 페이지 242 ---
Line 183: 220
Line 184: CHAPTER 9
Line 185: Mocking best practices
Line 186: public interface IMessageBus
Line 187: {
Line 188: void SendEmailChangedMessage(int userId, string newEmail);
Line 189: }
Line 190: public class MessageBus : IMessageBus
Line 191: {
Line 192: private readonly IBus _bus;
Line 193: public void SendEmailChangedMessage(
Line 194: int userId, string newEmail)
Line 195: {
Line 196: _bus.Send("Type: USER EMAIL CHANGED; " +
Line 197: $"Id: {userId}; " +
Line 198: $"NewEmail: {newEmail}");
Line 199: }
Line 200: }
Line 201: public interface IBus
Line 202: {
Line 203: void Send(string message);
Line 204: }
Line 205: Both the IMessageBus and IBus interfaces (and the classes implementing them) belong
Line 206: to our project’s code base. IBus is a wrapper on top of the message bus SDK library (pro-
Line 207: vided by the company that develops that message bus). This wrapper encapsulates non-
Line 208: essential technical details, such as connection credentials, and exposes a nice, clean
Line 209: interface for sending arbitrary text messages to the bus. IMessageBus is a wrapper on
Line 210: top of IBus; it defines messages specific to your domain. IMessageBus helps you keep all
Line 211: such messages in one place and reuse them across the application.
Line 212:  It’s possible to merge the IBus and IMessageBus interfaces together, but that
Line 213: would be a suboptimal solution. These two responsibilities—hiding the external
Line 214: library’s complexity and holding all application messages in one place—are best kept
Line 215: separated. This is the same situation as with ILogger and IDomainLogger, which you
Line 216: saw in chapter 8. IDomainLogger implements specific logging functionality required
Line 217: by the business, and it does that by using the generic ILogger behind the scenes.
Line 218:  Figure 9.1 shows where IBus and IMessageBus stand from a hexagonal architec-
Line 219: ture perspective: IBus is the last link in the chain of types between the controller and
Line 220: the message bus, while IMessageBus is only an intermediate step on the way.
Line 221:  Mocking IBus instead of IMessageBus maximizes the mock’s protection against
Line 222: regressions. As you might remember from chapter 4, protection against regressions is
Line 223: a function of the amount of code that is executed during the test. Mocking the very
Line 224: last type that communicates with the unmanaged dependency increases the number
Line 225: of classes the integration test goes through and thus improves the protection. This
Line 226: guideline is also the reason you don’t want to mock EventDispatcher. It resides even
Line 227: further away from the edge of the system, compared to IMessageBus.
Line 228: Listing 9.4
Line 229: Message bus 
Line 230: 
Line 231: --- 페이지 243 ---
Line 232: 221
Line 233: Maximizing mocks’ value
Line 234: Here’s the integration test after retargeting it from IMessageBus to IBus. I’m omitting
Line 235: the parts that didn’t change from listing 9.3.
Line 236: [Fact]
Line 237: public void Changing_email_from_corporate_to_non_corporate()
Line 238: {
Line 239: var busMock = new Mock<IBus>();
Line 240: var messageBus = new MessageBus(busMock.Object);     
Line 241: var loggerMock = new Mock<IDomainLogger>();
Line 242: var sut = new UserController(db, messageBus, loggerMock.Object);
Line 243: /* ... */
Line 244: busMock.Verify(
Line 245: x => x.Send(
Line 246: "Type: USER EMAIL CHANGED; " +  
Line 247: $"Id: {user.UserId}; " +
Line 248:   
Line 249: "NewEmail: new@gmail.com"),
Line 250:   
Line 251: Times.Once);
Line 252: }
Line 253: Listing 9.5
Line 254: Integration test targeting IBus
Line 255: External client
Line 256: Message bus
Line 257: IMessageBus
Line 258: Controller
Line 259: Domain model
Line 260: IBus
Line 261: Figure 9.1
Line 262: IBus resides at the system’s edge; IMessageBus is only an intermediate 
Line 263: link in the chain of types between the controller and the message bus. Mocking IBus 
Line 264: instead of IMessageBus achieves the best protection against regressions.
Line 265: Uses a concrete 
Line 266: class instead of 
Line 267: the interface
Line 268: Verifies the actual 
Line 269: message sent to 
Line 270: the bus
Line 271: 
Line 272: --- 페이지 244 ---
Line 273: 222
Line 274: CHAPTER 9
Line 275: Mocking best practices
Line 276: Notice how the test now uses the concrete MessageBus class and not the correspond-
Line 277: ing IMessageBus interface. IMessageBus is an interface with a single implementation,
Line 278: and, as you’ll remember from chapter 8, mocking is the only legitimate reason to have
Line 279: such interfaces. Because we no longer mock IMessageBus, this interface can be
Line 280: deleted and its usages replaced with MessageBus.
Line 281:  Also notice how the test in listing 9.5 checks the text message sent to the bus. Com-
Line 282: pare it to the previous version:
Line 283: messageBusMock.Verify(
Line 284: x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
Line 285: Times.Once);
Line 286: There’s a huge difference between verifying a call to a custom class that you wrote and
Line 287: the actual text sent to external systems. External systems expect text messages from your
Line 288: application, not calls to classes like MessageBus. In fact, text messages are the only side
Line 289: effect observable externally; classes that participate in producing those messages are
Line 290: mere implementation details. Thus, in addition to the increased protection against
Line 291: regressions, verifying interactions at the very edges of your system also improves resis-
Line 292: tance to refactoring. The resulting tests are less exposed to potential false positives; no
Line 293: matter what refactorings take place, such tests won’t turn red as long as the message’s
Line 294: structure is preserved.
Line 295:  The same mechanism is at play here as the one that gives integration and end-to-end
Line 296: tests additional resistance to refactoring compared to unit tests. They are more detached
Line 297: from the code base and, therefore, aren’t affected as much during low-level refactorings.
Line 298: TIP
Line 299: A call to an unmanaged dependency goes through several stages before
Line 300: it leaves your application. Pick the last such stage. It is the best way to ensure
Line 301: backward compatibility with external systems, which is the goal that mocks
Line 302: help you achieve. 
Line 303: 9.1.2
Line 304: Replacing mocks with spies
Line 305: As you may remember from chapter 5, a spy is a variation of a test double that serves
Line 306: the same purpose as a mock. The only difference is that spies are written manually,
Line 307: whereas mocks are created with the help of a mocking framework. Indeed, spies are
Line 308: often called handwritten mocks.
Line 309:  It turns out that, when it comes to classes residing at the system edges, spies are supe-
Line 310: rior to mocks. Spies help you reuse code in the assertion phase, thereby reducing the
Line 311: test’s size and improving readability. The next listing shows an example of a spy that
Line 312: works on top of IBus.
Line 313: public interface IBus
Line 314: {
Line 315: void Send(string message);
Line 316: }
Line 317: Listing 9.6
Line 318: A spy (also known as a handwritten mock)
Line 319: 
Line 320: --- 페이지 245 ---
Line 321: 223
Line 322: Maximizing mocks’ value
Line 323: public class BusSpy : IBus
Line 324: {
Line 325: private List<string> _sentMessages =    
Line 326: new List<string>();
Line 327:     
Line 328: public void Send(string message)
Line 329: {
Line 330: _sentMessages.Add(message);
Line 331:     
Line 332: }
Line 333: public BusSpy ShouldSendNumberOfMessages(int number)
Line 334: {
Line 335: Assert.Equal(number, _sentMessages.Count);
Line 336: return this;
Line 337: }
Line 338: public BusSpy WithEmailChangedMessage(int userId, string newEmail)
Line 339: {
Line 340: string message = "Type: USER EMAIL CHANGED; " +
Line 341: $"Id: {userId}; " +
Line 342: $"NewEmail: {newEmail}";
Line 343: Assert.Contains(
Line 344:    
Line 345: _sentMessages, x => x == message);   
Line 346: return this;
Line 347: }
Line 348: }
Line 349: The following listing is a new version of the integration test. Again, I’m showing only
Line 350: the relevant parts.
Line 351: [Fact]
Line 352: public void Changing_email_from_corporate_to_non_corporate()
Line 353: {
Line 354: var busSpy = new BusSpy();
Line 355: var messageBus = new MessageBus(busSpy);
Line 356: var loggerMock = new Mock<IDomainLogger>();
Line 357: var sut = new UserController(db, messageBus, loggerMock.Object);
Line 358: /* ... */
Line 359: busSpy.ShouldSendNumberOfMessages(1)
Line 360: .WithEmailChangedMessage(user.UserId, "new@gmail.com");
Line 361: }
Line 362: Verifying the interactions with the message bus is now succinct and expressive, thanks
Line 363: to the fluent interface that BusSpy provides. With that fluent interface, you can chain
Line 364: together several assertions, thus forming cohesive, almost plain-English sentences.
Line 365: TIP
Line 366: You can rename BusSpy into BusMock. As I mentioned earlier, the differ-
Line 367: ence between a mock and a spy is an implementation detail. Most programmers
Line 368: Listing 9.7
Line 369: Using the spy from listing 6.43
Line 370: Stores all sent 
Line 371: messages 
Line 372: locally
Line 373: Asserts that the 
Line 374: message has been sent
Line 375: 
Line 376: --- 페이지 246 ---
Line 377: 224
Line 378: CHAPTER 9
Line 379: Mocking best practices
Line 380: aren’t familiar with the term spy, though, so renaming the spy as BusMock can
Line 381: save your colleagues unnecessary confusion.
Line 382: There’s a reasonable question to be asked here: didn’t we just make a full circle and
Line 383: come back to where we started? The version of the test in listing 9.7 looks a lot like the
Line 384: earlier version that mocked IMessageBus:
Line 385: messageBusMock.Verify(
Line 386: x => x.SendEmailChangedMessage(
Line 387:   
Line 388: user.UserId, "new@gmail.com"),  
Line 389: Times.Once);      
Line 390: These assertions are similar because both BusSpy and MessageBus are wrappers on
Line 391: top of IBus. But there’s a crucial difference between the two: BusSpy is part of the test
Line 392: code, whereas MessageBus belongs to the production code. This difference is import-
Line 393: ant because you shouldn’t rely on the production code when making assertions in tests.
Line 394:  Think of your tests as auditors. A good auditor wouldn’t just take the auditee’s
Line 395: words at face value; they would double-check everything. The same is true with the
Line 396: spy: it provides an independent checkpoint that raises an alarm when the message
Line 397: structure is changed. On the other hand, a mock on IMessageBus puts too much trust
Line 398: in the production code. 
Line 399: 9.1.3
Line 400: What about IDomainLogger?
Line 401: The mock that previously verified interactions with IMessageBus is now targeted at
Line 402: IBus, which resides at the system’s edge. Here are the current mock assertions in the
Line 403: integration test.
Line 404: busSpy.ShouldSendNumberOfMessages(1)
Line 405:   
Line 406: .WithEmailChangedMessage(
Line 407:   
Line 408: user.UserId, "new@gmail.com");  
Line 409: loggerMock.Verify(
Line 410:     
Line 411: x => x.UserTypeHasChanged(
Line 412:   
Line 413: user.UserId,
Line 414:   
Line 415: UserType.Employee,
Line 416:   
Line 417: UserType.Customer),
Line 418:   
Line 419: Times.Once);
Line 420:   
Line 421: Note that just as MessageBus is a wrapper on top of IBus, DomainLogger is a wrapper
Line 422: on top of ILogger (see chapter 8 for more details). Shouldn’t the test be retargeted at
Line 423: ILogger, too, because this interface also resides at the application boundary?
Line 424:  In most projects, such retargeting isn’t necessary. While the logger and the mes-
Line 425: sage bus are unmanaged dependencies and, therefore, both require maintaining
Line 426: backward compatibility, the accuracy of that compatibility doesn’t have to be the
Line 427: same. With the message bus, it’s important not to allow any changes to the structure of
Line 428: Listing 9.8
Line 429: Mock assertions
Line 430: Same as WithEmailChanged-
Line 431: Message(user.UserId, 
Line 432: "new@gmail.com")
Line 433: Same as 
Line 434: ShouldSendNumberOfMessages(1)
Line 435: Checks 
Line 436: interactions 
Line 437: with IBus
Line 438: Checks 
Line 439: interactions with 
Line 440: IDomainLogger
Line 441: 
Line 442: --- 페이지 247 ---
Line 443: 225
Line 444: Mocking best practices
Line 445: the messages, because you never know how external systems will react to such
Line 446: changes. But the exact structure of text logs is not that important for the intended
Line 447: audience (support staff and system administrators). What’s important is the existence
Line 448: of those logs and the information they carry. Thus, mocking IDomainLogger alone
Line 449: provides the necessary level of protection. 
Line 450: 9.2
Line 451: Mocking best practices
Line 452: You’ve learned two major mocking best practices so far:
Line 453: Applying mocks to unmanaged dependencies only
Line 454: Verifying the interactions with those dependencies at the very edges of your
Line 455: system
Line 456: In this section, I explain the remaining best practices:
Line 457: Using mocks in integration tests only, not in unit tests
Line 458: Always verifying the number of calls made to the mock
Line 459: Mocking only types that you own
Line 460: 9.2.1
Line 461: Mocks are for integration tests only
Line 462: The guideline saying that mocks are for integration tests only, and that you shouldn’t
Line 463: use mocks in unit tests, stems from the foundational principle described in chapter 7:
Line 464: the separation of business logic and orchestration. Your code should either communi-
Line 465: cate with out-of-process dependencies or be complex, but never both. This principle
Line 466: naturally leads to the formation of two distinct layers: the domain model (that handles
Line 467: complexity) and controllers (that handle the communication).
Line 468:  Tests on the domain model fall into the category of unit tests; tests covering con-
Line 469: trollers are integration tests. Because mocks are for unmanaged dependencies only,
Line 470: and because controllers are the only code working with such dependencies, you
Line 471: should only apply mocking when testing controllers—in integration tests. 
Line 472: 9.2.2
Line 473: Not just one mock per test
Line 474: You might sometimes hear the guideline of having only one mock per test. According
Line 475: to this guideline, if you have more than one mock, you are likely testing several things
Line 476: at a time.
Line 477:  This is a misconception that follows from a more foundational misunderstanding
Line 478: covered in chapter 2: that a unit in a unit test refers to a unit of code, and all such units
Line 479: must be tested in isolation from each other. On the contrary: the term unit means
Line 480: a unit of behavior, not a unit of code. The amount of code it takes to implement such a
Line 481: unit of behavior is irrelevant. It could span across multiple classes, a single class, or
Line 482: take up just a tiny method.
Line 483:  With mocks, the same principle is at play: it’s irrelevant how many mocks it takes to ver-
Line 484: ify a unit of behavior. Earlier in this chapter, it took us two mocks to check the scenario
Line 485: of changing the user email from corporate to non-corporate: one for the logger and
Line 486: 
Line 487: --- 페이지 248 ---
Line 488: 226
Line 489: CHAPTER 9
Line 490: Mocking best practices
Line 491: the other for the message bus. That number could have been larger. In fact, you don’t
Line 492: have control over how many mocks to use in an integration test. The number of
Line 493: mocks depends solely on the number of unmanaged dependencies participating in
Line 494: the operation. 
Line 495: 9.2.3
Line 496: Verifying the number of calls
Line 497: When it comes to communications with unmanaged dependencies, it’s important to
Line 498: ensure both of the following:
Line 499: The existence of expected calls
Line 500: The absence of unexpected calls
Line 501: This requirement, once again, stems from the need to maintain backward compatibil-
Line 502: ity with unmanaged dependencies. The compatibility must go both ways: your appli-
Line 503: cation shouldn’t omit messages that external systems expect, and it also shouldn’t
Line 504: produce unexpected messages. It’s not enough to check that the system under test
Line 505: sends a message like this:
Line 506: messageBusMock.Verify(
Line 507: x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"));
Line 508: You also need to ensure that this message is sent exactly once:
Line 509: messageBusMock.Verify(
Line 510: x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
Line 511: Times.Once);      
Line 512: With most mocking libraries, you can also explicitly verify that no other calls are
Line 513: made on the mock. In Moq (the mocking library of my choice), this verification
Line 514: looks as follows:
Line 515: messageBusMock.Verify(
Line 516: x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
Line 517: Times.Once);
Line 518: messageBusMock.VerifyNoOtherCalls();     
Line 519: BusSpy implements this functionality, too:
Line 520: busSpy
Line 521: .ShouldSendNumberOfMessages(1)
Line 522: .WithEmailChangedMessage(user.UserId, "new@gmail.com");
Line 523: The spy’s check ShouldSendNumberOfMessages(1) encompasses both Times.Once and
Line 524: VerifyNoOtherCalls() verifications from the mock. 
Line 525: Ensures that the method 
Line 526: is called only once
Line 527: The additional 
Line 528: check
Line 529: 
Line 530: --- 페이지 249 ---
Line 531: 227
Line 532: Summary
Line 533: 9.2.4
Line 534: Only mock types that you own
Line 535: The last guideline I’d like to talk about is mocking only types that you own. It was first
Line 536: introduced by Steve Freeman and Nat Pryce.1 The guideline states that you should
Line 537: always write your own adapters on top of third-party libraries and mock those adapters
Line 538: instead of the underlying types. A few of their arguments are as follows:
Line 539: You often don’t have a deep understanding of how the third-party code works.
Line 540: Even if that code already provides built-in interfaces, it’s risky to mock those
Line 541: interfaces, because you have to be sure the behavior you mock matches what
Line 542: the external library actually does.
Line 543: Adapters abstract non-essential technical details of the third-party code and
Line 544: define the relationship with the library in your application’s terms.
Line 545: I fully agree with this analysis. Adapters, in effect, act as an anti-corruption layer
Line 546: between your code and the external world.2 These help you to
Line 547: Abstract the underlying library’s complexity
Line 548: Only expose features you need from the library
Line 549: Do that using your project’s domain language
Line 550: The IBus interface in our sample CRM project serves exactly that purpose. Even if the
Line 551: underlying message bus’s library provides as nice and clean an interface as IBus, you
Line 552: are still better off introducing your own wrapper on top of it. You never know how the
Line 553: third-party code will change when you upgrade the library. Such an upgrade could
Line 554: cause a ripple effect across the whole code base! The additional abstraction layer
Line 555: restricts that ripple effect to just one class: the adapter itself.
Line 556:  Note that the “mock your own types” guideline doesn’t apply to in-process depen-
Line 557: dencies. As I explained previously, mocks are for unmanaged dependencies only.
Line 558: Thus, there’s no need to abstract in-memory or managed dependencies. For instance,
Line 559: if a library provides a date and time API, you can use that API as-is, because it doesn’t
Line 560: reach out to unmanaged dependencies. Similarly, there’s no need to abstract an ORM
Line 561: as long as it’s used for accessing a database that isn’t visible to external applications.
Line 562: Of course, you can introduce your own wrapper on top of any library, but it’s rarely
Line 563: worth the effort for anything other than unmanaged dependencies. 
Line 564: Summary
Line 565: Verify interactions with an unmanaged dependency at the very edges of your
Line 566: system. Mock the last type in the chain of types between the controller and the
Line 567: unmanaged dependency. This helps you increase both protection against
Line 568: regressions (due to more code being validated by the integration test) and
Line 569: 1 See page 69 in Growing Object-Oriented Software, Guided by Tests by Steve Freeman and Nat Pryce (Addison-Wesley
Line 570: Professional, 2009).
Line 571: 2 See Domain-Driven Design: Tackling Complexity in the Heart of Software by Eric Evans (Addison-Wesley, 2003).
Line 572: 
Line 573: --- 페이지 250 ---
Line 574: 228
Line 575: CHAPTER 9
Line 576: Mocking best practices
Line 577: resistance to refactoring (due to detaching the mock from the code’s imple-
Line 578: mentation details).
Line 579: Spies are handwritten mocks. When it comes to classes residing at the system’s
Line 580: edges, spies are superior to mocks. They help you reuse code in the assertion
Line 581: phase, thereby reducing the test’s size and improving readability.
Line 582: Don’t rely on production code when making assertions. Use a separate set of lit-
Line 583: erals and constants in tests. Duplicate those literals and constants from the pro-
Line 584: duction code if necessary. Tests should provide a checkpoint independent of
Line 585: the production code. Otherwise, you risk producing tautology tests (tests that
Line 586: don’t verify anything and contain semantically meaningless assertions).
Line 587: Not all unmanaged dependencies require the same level of backward compati-
Line 588: bility. If the exact structure of the message isn’t important, and you only want to
Line 589: verify the existence of that message and the information it carries, you can
Line 590: ignore the guideline of verifying interactions with unmanaged dependencies at
Line 591: the very edges of your system. The typical example is logging.
Line 592: Because mocks are for unmanaged dependencies only, and because controllers
Line 593: are the only code working with such dependencies, you should only apply mock-
Line 594: ing when testing controllers—in integration tests. Don’t use mocks in unit tests.
Line 595: The number of mocks used in a test is irrelevant. That number depends solely
Line 596: on the number of unmanaged dependencies participating in the operation.
Line 597: Ensure both the existence of expected calls and the absence of unexpected calls
Line 598: to mocks.
Line 599: Only mock types that you own. Write your own adapters on top of third-party
Line 600: libraries that provide access to unmanaged dependencies. Mock those adapters
Line 601: instead of the underlying types.