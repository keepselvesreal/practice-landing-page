# 7장: 가치 있는 단위 테스트를 향한 리팩터링 - 추출된 정보

## 핵심 내용
- 코드를 4가지 유형으로 분류하여 테스트 전략 수립
- 과도하게 복잡한 코드를 알고리즘과 컨트롤러로 분리
- Humble Object 패턴을 통한 테스트 용이성 개선
- 함수형/육각형 아키텍처와의 연관성

## 상세 핵심 내용

### 코드의 4가지 유형
코드를 두 차원으로 분류:
1. **복잡성/도메인 중요도** (세로축)
2. **협력자 수** (가로축)

#### 4개 사분면:
1. **도메인 모델과 알고리즘** (왼쪽 위): 높은 복잡성 + 적은 협력자
2. **과도하게 복잡한 코드** (오른쪽 위): 높은 복잡성 + 많은 협력자
3. **자명한 코드** (왼쪽 아래): 낮은 복잡성 + 적은 협력자
4. **컨트롤러** (오른쪽 아래): 낮은 복잡성 + 많은 협력자

### 각 유형별 테스트 전략
- **도메인 모델/알고리즘**: 단위 테스트로 집중 커버 (최고의 ROI)
- **과도하게 복잡한 코드**: 리팩터링으로 분해 필요
- **자명한 코드**: 테스트하지 않음 (가치 거의 없음)
- **컨트롤러**: 통합 테스트로 간략히 커버

### Humble Object 패턴
- **목적**: 테스트하기 어려운 종속성으로부터 로직 분리
- **결과**: 로직 부분은 테스트 가능, Humble 부분은 테스트 불필요
- **적용 사례**: 육각형 아키텍처, 함수형 아키텍처, MVP/MVC 패턴

## 상세 내용

### 순환 복잡도(Cyclomatic Complexity)
- **공식**: `1 + 분기점 수`
- **의미**: 메서드의 독립적인 경로 수 또는 100% 분기 커버리지 달성에 필요한 테스트 수
- **예**: `IF condition1 AND condition2`의 복잡도는 3 (1 + 2)

### 협력자(Collaborator)의 정의
- **포함 대상**: 가변적이거나 프로세스 외부 종속성
- **제외 대상**: 불변 종속성 (값, 값 객체)
- **암시적/명시적 무관**: 정적 메서드 호출도 협력자에 포함
- **프로세스 외부 종속성**: 도메인 모델에서는 금지 (유지보수 비용 증가)

### 코드 깊이 vs 코드 폭 개념
- **깊이**: 복잡성이나 중요도 (비즈니스 로직)
- **폭**: 협력자 수 (오케스트레이션)
- **핵심 원칙**: 코드는 깊거나 넓을 수 있지만, 둘 다일 수는 없음

### 단일 책임 원칙과의 관계
- **비즈니스 로직**: 하나의 책임
- **오케스트레이션**: 다른 책임
- Humble Object 패턴 = 책임 분리의 구체적 구현

## 주요 화제

### 1. 아키텍처 패턴과의 연관성
- **육각형 아키텍처**: 도메인 vs 애플리케이션 서비스 분리
- **함수형 아키텍처**: 함수형 코어 vs 가변 셸 분리
- **MVP/MVC**: 모델 vs 뷰/프레젠터(컨트롤러) 분리
- **Aggregate 패턴**: 클러스터 내 높은 결합, 클러스터 간 느슨한 결합

### 2. 테스트 가능성의 핵심
- **최고 우선순위**: 도메인 모델과 알고리즘 (왼쪽 위 사분면)
  - 높은 가치 (복잡한/중요한 로직)
  - 낮은 비용 (적은 협력자)
- **리팩터링 대상**: 과도하게 복잡한 코드 (오른쪽 위 사분면)
- **통합 테스트**: 컨트롤러 (오른쪽 아래 사분면)

### 3. 100% 커버리지의 오해
- **목표가 아님**: 100% 테스트 커버리지
- **진짜 목표**: 각 테스트가 상당한 가치를 프로젝트에 추가
- **실용적 접근**: 가치 없는 테스트는 리팩터링하거나 제거

### 4. 함수형 vs 육각형 아키텍처 위치
```
복잡성/도메인 중요도
      ↑
      │ [함수형 코어]    [과도하게 복잡한 코드]
      │      │                   │
      │ [도메인 레이어]             │
      │      │                   │
      │ [자명한 코드]  ─ [가변 셸/애플리케이션 서비스]
      └─────────────────────→ 협력자 수
```

## 부차 화제

### 1. 테스트하기 어려운 종속성 예시
- **비동기/멀티스레드 실행**
- **사용자 인터페이스**
- **프로세스 외부 종속성과의 통신**
- **파일 시스템, 네트워크, 데이터베이스**

### 2. 나쁜 테스트 vs 테스트 없음
> "나쁜 테스트를 작성하는 것보다 테스트를 전혀 작성하지 않는 것이 낫다"

### 3. 도메인 코드의 특별성
- 모든 도메인 레이어 코드: 최종 사용자 목표와 직접 연결
- 높은 도메인 중요도 보장
- 복잡성과 무관하게 테스트 가치 존재
- 예: 단순한 주문 가격 계산도 순환 복잡도 1이지만 테스트 필요

### 4. 협력자 유형별 고려사항
- **가변 종속성**: 테스트에서 상태 설정/검증 필요
- **프로세스 외부 종속성**: 목 머신러리 유지보수 비용 발생
- **불변 종속성**: 설정과 검증이 쉬움
- **정적 참조**: 명시적 매개변수와 동일하게 취급

### 5. 리팩터링 실무 지침
- **"중요하거나 복잡할수록 협력자는 적어야 한다"**
- **이상적인 구조**: 오른쪽 위 사분면에는 코드가 없어야 함
- **점진적 개선**: 기존 코드를 단계적으로 분해
- **패턴 인식**: 대부분의 설계 패턴이 Humble Object 패턴의 변형