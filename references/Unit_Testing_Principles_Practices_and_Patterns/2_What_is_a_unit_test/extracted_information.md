# 2장: 단위 테스트란 무엇인가? - 추출된 정보

## 핵심 내용
- 단위 테스트의 정의와 격리(isolation) 이슈
- 클래식(고전) 학파와 런던 학파의 단위 테스트 접근법 차이
- 공유, 비공유, 프로세스 외부 의존성의 구분과 처리 방법
- 단위 테스트, 통합 테스트, 종단간 테스트의 구분

## 상세 핵심 내용

### 단위 테스트의 정의
단위 테스트는 다음 세 가지 특성을 가진 자동화된 테스트:
1. **작은 코드 조각(unit) 검증**
2. **빠른 실행**
3. **격리된 방식으로 실행**

세 번째 특성인 "격리"의 해석이 두 학파의 차이점을 만듦

### 격리 이슈: 런던 학파 vs 클래식 학파

#### 런던 학파 (London/Mockist School)
- **격리 대상**: 테스트 대상 시스템을 협력자들로부터 격리
- **단위 정의**: 단일 클래스
- **테스트 더블 사용**: 불변 의존성을 제외한 모든 의존성을 테스트 더블로 대체
- **구조**: 프로덕션 코드의 각 클래스마다 대응하는 테스트 클래스 생성

#### 클래식 학파 (Classical/Detroit School)
- **격리 대상**: 단위 테스트들을 서로 격리
- **단위 정의**: 단일 클래스 또는 클래스들의 집합
- **테스트 더블 사용**: 공유 의존성에만 테스트 더블 사용
- **실행**: 병렬, 순차, 임의 순서로 실행 가능

## 상세 내용

### 의존성 분류 체계

#### 공유 의존성 (Shared Dependencies)
- **정의**: 테스트 간에 공유되어 서로의 결과에 영향을 줄 수 있는 의존성
- **예시**: 데이터베이스, 파일 시스템, 정적 가변 필드
- **특성**: 테스트 간 통신 수단 제공

#### 비공유 의존성 (Private Dependencies)
- **정의**: 테스트 간 공유되지 않는 의존성
- **분류**:
  - **가변(Mutable)**: Store 인스턴스
  - **불변(Immutable)**: Product 인스턴스, 숫자 5 (값 객체)

#### 프로세스 외부 의존성 (Out-of-Process Dependencies)
- **정의**: 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
- **관계**: 대부분 공유 의존성이지만 항상은 아님
- **예외**: 읽기 전용 API (프로세스 외부이지만 공유되지 않음)

#### 휘발성 의존성 (Volatile Dependencies)
다음 중 하나 이상의 특성을 가진 의존성:
1. **런타임 환경 설정 요구**: 데이터베이스, API 서비스
2. **비결정적 동작**: 난수 생성기, 현재 날짜/시간 클래스

### 협력자(Collaborator) vs 의존성(Dependency)
- **협력자**: 공유되거나 가변인 의존성
- **값 객체**: 불변인 비공유 의존성 (Product, 숫자 5)

## 주요 화제

### 1. 런던 학파의 장점과 한계

#### 장점
1. **세밀한 단위**: 한 번에 하나의 클래스만 테스트
2. **복잡한 객체 그래프 테스트 용이성**: 협력자를 테스트 더블로 대체
3. **정확한 버그 위치 파악**: 테스트 실패 시 정확한 원인 클래스 식별

#### 한계
1. **잘못된 세밀함**: 코드 단위가 아닌 동작 단위를 테스트해야 함
2. **설계 문제 은폐**: 복잡한 객체 그래프는 설계 문제의 신호
3. **과도한 명세화**: 구현 세부사항과 결합도 증가

### 2. 동작 단위 vs 코드 단위
- **올바른 접근**: "개가 나에게 온다" (응집력 있는 스토리)
- **잘못된 접근**: "개가 앞다리를 움직이고, 머리를 돌리고..." (의미 없는 세부사항)
- **원칙**: 테스트는 문제 도메인에 의미 있고 비즈니스 담당자가 유용하다고 인식할 수 있는 동작을 검증해야 함

### 3. 테스트 주도 개발(TDD) 접근법 차이

#### 런던 학파: Outside-in TDD
- 상위 레벨 테스트에서 시작
- 목을 사용하여 협력자 명세
- 클래스 그래프를 따라 구현

#### 클래식 학파: Inside-out TDD
- 도메인 모델에서 시작
- 실제 객체 사용
- 최종 사용자가 사용 가능할 때까지 계층 추가

## 부차 화제

### 1. 테스트 더블 개념
- **테스트 더블**: 실제 의존성을 대체하는 단순화된 객체
- **목(Mock)**: 테스트 더블의 한 종류, 상호작용 검사 가능
- **용어 혼용**: 사람들이 테스트 더블과 목을 동의어로 사용하지만 기술적으로 다름

### 2. 온라인 스토어 예제 분석

#### 클래식 스타일
```csharp
var store = new Store(); // 실제 프로덕션 인스턴스 사용
store.AddInventory(Product.Shampoo, 10);
bool success = customer.Purchase(store, Product.Shampoo, 5);
Assert.Equal(5, store.GetInventory(Product.Shampoo)); // 상태 검증
```

#### 런던 스타일
```csharp
var storeMock = new Mock<IStore>(); // 인터페이스 목 사용
storeMock.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5)).Returns(true);
storeMock.Verify(x => x.RemoveInventory(Product.Shampoo, 5), Times.Once); // 상호작용 검증
```

### 3. 통합 테스트와 종단간 테스트

#### 통합 테스트 정의
다음 중 하나 이상을 위반하는 테스트:
- 단일 동작 단위 검증
- 빠른 실행
- 다른 테스트와 격리

#### 종단간 테스트
- **정의**: 통합 테스트의 하위 집합
- **특징**: 모든 또는 대부분의 프로세스 외부 의존성 포함
- **관점**: 최종 사용자 관점에서 시스템 검증
- **동의어**: UI 테스트, GUI 테스트, 기능 테스트

### 4. 값 객체의 특성
- **개별 정체성 없음**: 내용으로만 식별
- **교환 가능성**: 동일한 내용이면 어느 인스턴스든 사용 가능
- **언어 무관성**: 특정 프로그래밍 언어나 프레임워크에 종속되지 않음

### 5. 학파별 접근법 요약

| 특성 | 런던 학파 | 클래식 학파 |
|------|----------|------------|
| 격리 대상 | 단위들 | 단위 테스트들 |
| 단위 정의 | 클래스 | 클래스 또는 클래스 집합 |
| 테스트 더블 사용 | 불변 의존성 제외 모든 것 | 공유 의존성만 |

### 6. 저자의 선호도와 근거
- **선호**: 클래식 학파
- **근거**: 런던 학파의 목 사용은 테스트를 더 취약하게 만듦 (5장에서 자세히 다룸)
- **품질**: 클래식 스타일이 더 높은 품질의 테스트 생성
- **목표**: 프로젝트의 지속 가능한 성장이라는 궁극적 목표에 더 적합