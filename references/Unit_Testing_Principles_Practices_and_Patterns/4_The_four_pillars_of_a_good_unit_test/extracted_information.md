# 4장: 좋은 단위 테스트의 4가지 기둥 - 추출된 정보

## 핵심 내용
- 좋은 단위 테스트의 4가지 핵심 속성과 그 상호관계
- 회귀 방지와 리팩터링 저항성의 중요성과 상충관계
- 테스트 피라미드와 블랙박스/화이트박스 테스팅
- 이상적인 테스트의 불가능성과 절충점 찾기

## 상세 핵심 내용

### 좋은 단위 테스트의 4가지 기둥
1. **회귀 방지 (Protection against regressions)**
   - 소프트웨어 버그 탐지 능력
   - 실행되는 코드의 양, 복잡성, 도메인 중요도에 따라 결정
   - 외부 라이브러리와 프레임워크까지 포함해야 최적의 보호

2. **리팩터링 저항성 (Resistance to refactoring)**
   - 코드 리팩터링 시 거짓 양성(false positive) 방지
   - 구현 세부사항이 아닌 최종 결과 검증
   - 거짓 양성은 테스트에 대한 신뢰도 저하와 리팩터링 기피로 이어짐

3. **빠른 피드백 (Fast feedback)**
   - 테스트 실행 속도
   - 빠른 피드백으로 버그 수정 비용 최소화

4. **유지보수성 (Maintainability)**
   - 테스트 이해 용이성 (코드 크기와 품질)
   - 테스트 실행 용이성 (외부 종속성 최소화)

### 거짓 양성과 거짓 음성
- **거짓 양성 (False Positive)**: 기능은 정상이지만 테스트 실패
- **거짓 음성 (False Negative)**: 기능에 버그가 있지만 테스트 통과
- 테스트 정확도 = 신호(버그 발견 수) / 노이즈(거짓 경보 수)
- 프로젝트 초기에는 거짓 음성이 더 중요하지만, 시간이 지날수록 거짓 양성의 중요성 증가

## 상세 내용

### 이상적인 테스트의 불가능성
- 처음 3가지 속성(회귀 방지, 리팩터링 저항성, 빠른 피드백)은 상호 배타적
- **리팩터링 저항성은 타협 불가**: 이진 선택 (있거나 없거나)
- 회귀 방지와 빠른 피드백 사이의 슬라이더 조정 필요

### 극단적 사례들
1. **End-to-End 테스트**: 뛰어난 회귀 방지 + 리팩터링 저항성, 느린 피드백
2. **자명한 테스트**: 빠른 피드백 + 리팩터링 저항성, 낮은 회귀 방지
3. **취약한 테스트**: 빠른 피드백 + 회귀 방지, 낮은 리팩터링 저항성

### 구현 세부사항 vs 관찰 가능한 동작
- **구현 세부사항**: 최종 결과에 직접적 연결이 없는 내부 동작
- **관찰 가능한 동작**: 클라이언트 목표 달성에 도움이 되는 작업이나 상태
- 잘 설계된 API: 관찰 가능한 동작만 공개, 구현 세부사항은 비공개

## 주요 화제

### 1. 테스트 피라미드 (Test Pyramid)
- **단위 테스트**: 빠른 피드백 중심, 가장 많은 수량
- **통합 테스트**: 중간 균형, 중간 수량
- **End-to-End 테스트**: 회귀 방지 중심, 가장 적은 수량
- 모든 레벨에서 리팩터링 저항성은 포기하지 않음

### 2. 블랙박스 vs 화이트박스 테스팅
- **블랙박스**: 외부 명세 기반, 리팩터링 저항성 우수
- **화이트박스**: 소스 코드 기반, 회귀 방지 우수하지만 취약함
- **권장사항**: 기본적으로 블랙박스 방식 선택, 화이트박스는 분석용으로만 사용

### 3. MessageRenderer 예제를 통한 취약성 분석
```csharp
// 나쁜 예: 구현 세부사항에 결합
[Fact]
public void MessageRenderer_uses_correct_sub_renderers()
{
    // SubRenderers 컬렉션 구성 검증
}

// 좋은 예: 최종 결과 검증
[Fact]
public void Rendering_a_message()
{
    string html = sut.Render(message);
    Assert.Equal("<h1>h</h1><b>b</b><i>f</i>", html);
}
```

### 4. CAP 정리와의 유사성
- 분산 시스템의 CAP 정리처럼 3가지 속성 중 2개만 최대화 가능
- Partition Tolerance(분할 내성) = Resistance to Refactoring(리팩터링 저항성)
- 둘 다 대규모 시스템에서는 타협 불가능한 속성

## 부차 화제

### 1. 테스트 가치 평가 공식
- **가치 = [0..1] * [0..1] * [0..1] * [0..1]** (곱셈 원칙)
- 하나라도 0이면 전체 가치가 0이 됨
- 높은 임계치 설정으로 가치있는 테스트만 유지

### 2. 코드 복잡도와 도메인 중요성
- 비즈니스 로직 > 상용구 코드
- 복잡한 알고리즘 > 간단한 속성
- 도메인 핵심 기능 > 유틸리티 코드

### 3. 테스트 피라미드의 예외 사례
- **CRUD 중심 애플리케이션**: 사각형 모양 (단위 테스트 = 통합 테스트)
- **단일 종속성 API**: End-to-End 테스트 비중 증가 가능

### 4. 취약한 테스트의 실제 사례
```csharp
// 극단적으로 취약한 테스트 예제
[Fact]
public void MessageRenderer_is_implemented_correctly()
{
    string sourceCode = File.ReadAllText(@"[path]\MessageRenderer.cs");
    Assert.Equal(expectedSourceCode, sourceCode);
}
```

### 5. 저자의 실무 경험담
- 레거시 프로젝트에서 취약한 테스트로 인한 개발 마비 경험
- 거짓 양성 누적으로 인한 실제 버그 놓침 사례
- 테스트 비활성화와 기술 부채 누적의 악순환