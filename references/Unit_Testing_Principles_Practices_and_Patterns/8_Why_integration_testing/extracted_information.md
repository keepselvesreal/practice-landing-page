# 8장: 통합 테스트가 왜 필요한가 - 추출된 정보

## 핵심 내용
- 통합 테스트의 정의와 단위 테스트와의 차이점
- 테스트 피라미드 재검토와 비즈니스 시나리오 테스트 전략
- 관리되는/관리되지 않는 종속성 구분과 목킹 전략
- 통합 테스트 작성 시 베스트 프랙티스

## 상세 핵심 내용

### 통합 테스트 정의
**통합 테스트**: 다음 3가지 단위 테스트 요구사항을 하나라도 만족하지 않는 테스트
1. 단일 동작 단위 검증
2. 빠른 실행
3. 다른 테스트와의 격리

**실무적 정의**: 프로세스 외부 종속성과의 통합을 검증하는 테스트

### 코드 사분면과 테스트 전략
- **도메인 모델/알고리즘**: 단위 테스트로 커버
- **컨트롤러**: 통합 테스트로 커버
- **자명한 코드**: 테스트하지 않음
- **과도하게 복잡한 코드**: 리팩터링으로 분해 후 위 두 사분면으로 이동

### 관리되는 vs 관리되지 않는 종속성
#### 관리되는 종속성 (Managed Dependencies)
- **정의**: 애플리케이션을 통해서만 접근 가능한 종속성
- **예**: 애플리케이션 데이터베이스, 파일 시스템
- **테스트 전략**: 실제 인스턴스 사용 (목 사용하지 않음)

#### 관리되지 않는 종속성 (Unmanaged Dependencies)
- **정의**: 외부 애플리케이션에서 관찰 가능한 부작용을 만들어내는 종속성
- **예**: SMTP 서버, 메시지 버스, 외부 API
- **테스트 전략**: 목으로 대체

## 상세 내용

### 테스트 피라미드 재검토
**일반적 비율 원칙**:
- **해피 패스**: 비즈니스 시나리오당 1-2개의 통합 테스트
- **엣지 케이스**: 대부분을 단위 테스트로 커버
- **장점**: 유지보수 비용 최소화 + 전체 시스템 정확성 보장

#### 테스트 피라미드 예외 사례
1. **CRUD 중심 애플리케이션**: 단위 테스트 = 통합 테스트 비율
2. **단일 외부 종속성 API**: End-to-End 테스트 비중 증가 가능

### 통합 테스트의 구조
```csharp
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    // Arrange: 데이터베이스에 테스트 데이터 설정
    var database = new Database(ConnectionString);
    User user = CreateUser("user@mycorp.com", UserType.Employee, database);

    // 관리되지 않는 종속성은 목으로 대체
    var messageBusMock = new Mock<IMessageBus>();

    // Act: 시스템 전체를 통해 작업 실행
    string result = sut.ChangeEmail(user.UserId, "new@gmail.com");

    // Assert: 최종 상태와 부작용 검증
    Assert.Equal("OK", result);
    // 데이터베이스 상태 검증
    // 목을 통한 외부 상호작용 검증
}
```

### CRM 시스템 예제를 통한 실무 적용
- **시나리오**: 사용자 이메일 변경 시 타입도 함께 변경 (Employee → Customer)
- **관리되는 종속성**: 데이터베이스 (실제 사용)
- **관리되지 않는 종속성**: 메시지 버스 (목 사용)

## 주요 화제

### 1. 통합 테스트의 단점과 장점
**단점**:
- **느린 실행**: 프로세스 외부 종속성 사용
- **높은 유지보수 비용**: 종속성 운영 + 더 큰 테스트 크기

**장점**:
- **회귀 방지**: 더 많은 코드 경로 실행
- **리팩터링 저항성**: 프로덕션 코드에서 더 멀리 떨어져 있음

### 2. 데이터베이스 테스트 전략
- **트랜잭션 롤백**: 각 테스트 후 데이터 정리
- **테스트 데이터 빌더**: 복잡한 테스트 데이터 생성
- **인메모리 데이터베이스**: 더 빠른 실행 (주의: 프로덕션과 차이)

### 3. 인터페이스 단일 구현체 문제
**문제점**:
- 실제 추상화 제공하지 않음
- 테스트를 위한 인터페이스 (안티패턴)
- YAGNI 원칙 위반

**해결책**:
- 실제 필요할 때까지 구체 클래스 사용
- 진정한 추상화가 필요할 때만 인터페이스 도입

### 4. 로깅 테스트 가이드라인
- **구조적 로깅**: 비즈니스 관련 로그만 테스트
- **지원 로깅**: 일반적으로 테스트하지 않음 (가치 낮음)
- **도메인 중요도**: 로그가 비즈니스 요구사항을 반영하는지 확인

## 부차 화제

### 1. 순환 의존성 제거
- **계층별 분리**: 도메인 → 애플리케이션 서비스 → 인프라
- **의존성 주입**: 인터페이스를 통한 의존성 역전
- **헥사고날 아키텍처**: 명확한 경계 설정

### 2. 레이어 수 최소화
- **불필요한 추상화 제거**: 실제 가치 없는 레이어 정리
- **직접적 연결**: 중간 레이어 없이 직접 통신
- **복잡성 감소**: 이해하기 쉬운 구조

### 3. 도메인 모델 경계 명시
- **응집도 높은 모듈**: 관련 기능을 함께 묶기
- **결합도 낮은 모듈**: 모듈 간 의존성 최소화
- **명확한 인터페이스**: 모듈 간 상호작용 규칙 정의

### 4. Fail Fast 원칙 활용
- **입력 검증**: 메서드 시작 부분에서 즉시 검증
- **전제 조건 체크**: 실행 전 필수 조건 확인
- **조기 실패**: 문제 발생 즉시 예외 발생

### 5. 테스트 데이터 관리
- **Object Mother 패턴**: 테스트 데이터 생성 중앙화
- **Test Data Builder**: 유연한 테스트 데이터 구성
- **데이터 정리**: 테스트 간 격리를 위한 깔끔한 정리

### 6. 성능 고려사항
- **병렬 실행**: 가능한 경우 테스트 병렬 실행
- **공유 자원**: 데이터베이스 등 공유 자원 관리
- **테스트 시간**: 피드백 시간 단축을 위한 최적화