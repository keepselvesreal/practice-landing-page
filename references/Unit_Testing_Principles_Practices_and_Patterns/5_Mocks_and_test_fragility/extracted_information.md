# 5장: 목과 테스트 취약성 - 추출된 정보

## 핵심 내용
- 목(Mock)과 스텁(Stub)의 차이점과 올바른 사용법
- 관찰 가능한 동작 vs 구현 세부사항의 구분
- 시스템 내부 vs 시스템 간 통신의 차이점
- 목 사용 시 테스트 취약성을 피하는 방법

## 상세 핵심 내용

### 목과 스텁의 구분
- **목(Mock)**: 나가는 상호작용을 에뮬레이션하고 검사 (상태 변경을 일으키는 호출)
- **스텁(Stub)**: 들어오는 상호작용을 에뮬레이션만 함 (입력 데이터를 제공하는 호출)
- **핵심 원칙**: 스텁과의 상호작용은 절대 검증하지 말 것

### 테스트 더블의 5가지 유형
1. **Dummy**: 하드코딩된 단순 값
2. **Stub**: 시나리오별로 다른 값을 반환하는 완전한 종속성
3. **Spy**: 수동으로 작성된 목
4. **Mock**: 목킹 프레임워크로 생성된 목
5. **Fake**: 아직 존재하지 않는 종속성을 대체하기 위해 구현된 스텁

### 명령-쿼리 분리(CQS) 원칙과의 관계
- **명령(Command)**: 부작용 발생, 반환값 없음 → Mock으로 대체
- **쿼리(Query)**: 부작용 없음, 값 반환 → Stub으로 대체
- 예외: `stack.Pop()` 같은 메서드는 CQS 원칙을 위반하지만 합리적

## 상세 내용

### 관찰 가능한 동작의 정의
코드가 관찰 가능한 동작이 되려면 다음 중 하나를 만족해야 함:
1. **작업(Operation)**: 클라이언트 목표 달성에 도움이 되는 계산이나 부작용
2. **상태(State)**: 클라이언트 목표 달성에 도움이 되는 현재 시스템 상태

### 잘 설계된 API의 특징
- **이상적인 경우**: 관찰 가능한 동작 = Public API, 구현 세부사항 = Private API
- **문제가 있는 경우**: 구현 세부사항이 Public API로 누출
- **경험칙**: 단일 목표 달성을 위해 여러 작업이 필요하면 구현 세부사항 누출 가능성

### User 클래스 리팩터링 예제
```csharp
// Before: 구현 세부사항 누출
public string NormalizeName(string name) { /* ... */ }
user.Name = user.NormalizeName(newName);

// After: 잘 설계된 API
private string NormalizeName(string name) { /* ... */ }
user.Name = newName; // 내부적으로 정규화 수행
```

### 육각형 아키텍처(Hexagonal Architecture)
- **도메인 계층**: 비즈니스 로직 (애플리케이션의 핵심)
- **애플리케이션 서비스 계층**: 도메인 계층과 외부 세계 간의 조정
- **의존성 방향**: 애플리케이션 서비스 → 도메인 (단방향)

### 시스템 내부 vs 시스템 간 통신
- **시스템 내부(Intra-system)**: 애플리케이션 내 클래스 간 통신 → **구현 세부사항**
- **시스템 간(Inter-system)**: 애플리케이션 간 통신 → **관찰 가능한 동작**
- **예외**: 애플리케이션을 통해서만 접근 가능한 외부 시스템은 구현 세부사항

## 주요 화제

### 1. 목킹 도구 vs 목킹 테스트 더블
```csharp
var mock = new Mock<IEmailGateway>(); // Mock (도구)
// mock.Object는 Mock (테스트 더블)

var stub = new Mock<IDatabase>(); // Mock (도구)
// stub.Object는 Stub (테스트 더블)
```

### 2. 올바른 목 사용 사례
```csharp
// 좋은 예: 시스템 간 통신 검증
mock.Verify(x => x.SendGreetingsEmail("user@email.com"), Times.Once);

// 나쁜 예: 시스템 내부 통신 검증 (취약한 테스트)
stub.Verify(x => x.GetNumberOfUsers(), Times.Once);
```

### 3. Customer-Store 예제를 통한 통신 유형 구분
- **올바른 목 사용**: CustomerController → EmailGateway (시스템 간)
- **잘못된 목 사용**: Customer → Store (시스템 내부)

### 4. 애플리케이션 데이터베이스의 특별한 경우
- 애플리케이션만 접근 가능한 데이터베이스는 구현 세부사항
- 외부 시스템이 직접 접근할 수 없으면 목킹할 필요 없음
- 애플리케이션과 함께 배포되어 하나의 시스템으로 취급

## 부차 화제

### 1. 런던 vs 고전 스타일 재검토
- **런던 스타일**: 불변 종속성을 제외한 모든 종속성에 목 사용
- **고전 스타일**: 공유 종속성에만 테스트 더블 사용
- **문제점**: 런던 스타일은 시스템 내부/간 통신을 구분하지 않아 취약한 테스트 양산

### 2. 캡슐화와 불변성 보장
- **캡슐화**: 불변성 위반으로부터 코드 보호
- **Tell-Don't-Ask 원칙**: 데이터와 그 데이터를 조작하는 함수를 묶음
- **구현 세부사항 숨기기**: 클라이언트가 내부 구조를 손상시킬 위험 제거

### 3. 과도한 명세(Over-specification) 안티패턴
- 최종 결과가 아닌 중간 과정을 검증하는 실수
- 스텁과의 상호작용 검증이 가장 흔한 사례
- 리팩터링 저항성을 크게 해치는 주요 원인

### 4. 동작(Behavior) 검증의 오해
- 대부분의 경우 목은 동작을 검증하지 않음
- 클래스 간 상호작용은 구현 세부사항
- 진정한 동작은 외부 클라이언트에게 의미 있는 결과

### 5. 공유 종속성과 프로세스 외부 종속성
- **공유 종속성**: 테스트 간에 공유되는 종속성
- **프로세스 외부 종속성**: 별도 프로세스에서 호스팅되는 종속성
- **비공개 종속성**: 공유되지 않는 종속성
- 모든 프로세스 외부 종속성이 목킹 대상은 아님