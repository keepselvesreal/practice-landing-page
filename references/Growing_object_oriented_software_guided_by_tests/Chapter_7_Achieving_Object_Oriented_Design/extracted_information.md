# Growing_object_oriented_software_guided_by_tests_Chapter 7: Achieving Object-Oriented Design

## 압축 내용

TDD는 테스트 우선 작성을 통해 의도를 먼저 서술하고(추상화 수준 유지), 테스트 범위 제한으로 컴포넌트 크기를 적절히 유지하며, 의존성 명시적 전달로 컨텍스트 독립성을 장려하여 객체지향 설계를 달성하고, 통신 프로토콜을 가시화하며, 값 타입(Breaking Out, Budding Off, Bundling Up)과 객체 타입(동일한 기법)을 발견하고, 좁은 인터페이스로 관계를 식별하며, 선언적 레이어와 구현 레이어로 코드를 조직화하여 높은 수준의 프로그래밍을 구축하고, 클래스보다 인터페이스와 통신 프로토콜을 강조한다.

## 핵심 내용

### 핵심 개념들
1. **Test-First Design Benefits** (참조: [상세 내용 1.1])
2. **Communication over Classification** (참조: [상세 내용 2.1])
3. **Value Types Discovery** (참조: [상세 내용 3.1])
4. **Object Discovery Techniques** (참조: [상세 내용 4.1, 4.2, 4.3])
5. **Interface-Driven Design** (참조: [상세 내용 5.1, 5.2])
6. **Composing Objects** (참조: [상세 내용 6.1])
7. **Declarative vs Implementation Layers** (참조: [상세 내용 6.2])
8. **Interfaces over Classes** (참조: [상세 내용 7.1])

### 핵심 개념 설명

**1. Test-First Design Benefits** (참조: [상세 내용 1.1])
- 테스트 우선 작성: 구현 전에 달성하고자 하는 것을 서술 → 올바른 추상화 수준 유지
- 테스트 범위 제한: 컴포넌트 크기를 적절하게 유지 → 관심사의 분리
- 의존성 명시적 전달: 컨텍스트 독립성 장려

**2. Communication over Classification** (참조: [상세 내용 2.1])
- 클래스 구조보다 객체 간 통신 패턴이 더 중요
- 통신 프로토콜: 인터페이스 간 관계, 인터페이스 내 메서드 간 관계
- Mock 객체를 통한 통신 프로토콜 가시화

**3. Value Types Discovery** (참조: [상세 내용 3.1])
- Breaking Out: 복잡한 코드를 일관된 행동 단위로 분리
- Budding Off: 새로운 도메인 개념을 위한 플레이스홀더 타입 도입
- Bundling Up: 항상 함께 사용되는 값들을 새 타입으로 그룹화

**4. Object Discovery Techniques** (참조: [상세 내용 4.1, 4.2, 4.3])
- Breaking Out: 큰 객체를 협력하는 객체 그룹으로 분리
- Budding Off: 객체가 필요로 하는 새 서비스 정의 및 제공 객체 추가
- Bundling Up: 관련 객체들을 포함 객체로 숨김

**5. Interface-Driven Design** (참조: [상세 내용 5.1, 5.2])
- 좁은 인터페이스: 역할이 명확하고 구현이 쉬움
- 인터페이스를 "pull"하여 존재시킴: 클라이언트 필요에서 도출
- 인터페이스 리팩터링: 유사성과 차이점에 주의

**6. Composing Objects** (참조: [상세 내용 6.1])
- 단위 수준 TDD: 값 타입과 느슨하게 결합된 계산 객체로 분해
- 낮은 수준 객체를 빌딩 블록으로 더 유능한 객체 구성
- 유연한 애플리케이션 구조, 적은 코드

**7. Declarative vs Implementation Layers** (참조: [상세 내용 6.2])
- 선언적 레이어: 무엇을 할지(what) 설명, 도메인 특화 언어
- 구현 레이어: 어떻게 할지(how) 설명, 객체 그래프
- 더 적은 코드로 더 많이 달성

**8. Interfaces over Classes** (참조: [상세 내용 7.1])
- 인터페이스가 클래스보다 중요: 다른 객체가 보는 것
- 객체 타입은 그것이 수행하는 역할로 정의됨
- 클래스는 "구현 세부사항": 타입 구현 방법, 타입 자체가 아님

### 핵심 개념 간 관계

**Test-First Design Benefits**는 **Communication over Classification**을 가능하게 하며, 이를 통해 **Value Types Discovery**와 **Object Discovery Techniques**를 체계적으로 수행할 수 있습니다. 발견된 타입들은 **Interface-Driven Design**을 통해 관계를 정의하고, **Composing Objects**를 통해 더 복잡한 행동을 구성합니다. 이 과정에서 **Declarative vs Implementation Layers**로 코드를 조직화하여 가독성을 높이고, 최종적으로 **Interfaces over Classes**를 강조하여 유연하고 변경하기 쉬운 시스템을 만듭니다.

## 상세 내용

### 목차
1. 테스트 우선 작성이 설계에 도움이 되는 방법
   1.1 TDD의 세 가지 설계 지원 측면
2. 분류보다 통신
   2.1 통신 프로토콜과 Mock 객체
3. 값 타입
   3.1 값 타입 도입 기법
4. 객체는 어디서 오는가
   4.1 Breaking Out: 큰 객체 분리
   4.2 Budding Off: 새 서비스 정의
   4.3 Bundling Up: 관련 객체 숨김
5. 인터페이스로 관계 식별
   5.1 좁은 인터페이스와 역할
   5.2 인터페이스 리팩터링
6. 시스템 행동을 설명하기 위한 객체 조합
   6.1 객체 조합으로 웹 구성
   6.2 높은 수준의 프로그래밍으로 구축
7. 클래스는 어떤가
   7.1 인터페이스가 클래스보다 중요

---

### 1. 테스트 우선 작성이 설계에 도움이 되는 방법

**화제 배경**: 이전 장에서 설명한 설계 원칙들이 TDD를 통해 어떻게 달성되는지 설명합니다. (Lines 10-15)

#### 1.1 TDD의 세 가지 설계 지원 측면 [핵심 개념: Test-First Design Benefits]

**TDD가 올바른 범위 지정을 달성하는 세 가지 측면** (Lines 16-34)

```
전제 (Lines 10-15):
설계 원칙의 목표:
- 객체의 올바른 경계 찾기
- 이웃과 잘 상호작용
- 호출자가 알아야 할 것:
  - 객체가 무엇을 하는가
  - 무엇에 의존하는가
  - 어떻게 작동하는가는 아님
- 더 큰 환경에서 의미 있는 일관된 단위

결과:
이러한 컴포넌트로 구축된 시스템 → 요구사항 변경에 따라 재구성하고 적응할 유연성

1. 의도 우선 서술 (Lines 16-21):
테스트로 시작 = 구현 전에 달성하고자 하는 것을 서술해야 함

효과:
- 대상 객체의 올바른 추상화 수준 유지에 집중 도움
- 단위 테스트의 의도가 불명확하면
  → 개념을 혼합하고 있으며 코딩 시작 준비 안 됨
- 정보 은닉 도움
  → 객체 외부에서 무엇이 보여야 하는지 결정해야 함

2. 테스트 범위 제한 (Lines 22-28):
단위 테스트를 이해 가능(따라서 유지보수 가능)하게 유지하려면 범위 제한 필요

경험:
수십 줄 길이의 단위 테스트 → 설정 어딘가에 테스트 요점 묻힘

신호:
테스트하는 컴포넌트가 너무 크다
→ 더 작은 컴포넌트로 분리 필요

결과:
- 암시적 구조를 추출하면서 더 명확한 관심사의 분리
- 추출된 객체에 대한 더 단순한 테스트 작성 가능

3. 의존성 명시적 전달 (Lines 29-34):
단위 테스트를 위한 객체 구성 시 의존성을 전달해야 함
→ 의존성이 무엇인지 알아야 함

효과:
컨텍스트 독립성 장려
→ 단위 테스트 전에 대상 객체의 환경 설정 가능해야 함
→ 단위 테스트는 그저 또 다른 컨텍스트

알림:
암시적(또는 너무 많은) 의존성을 가진 객체는 테스트 준비가 고통스러움
→ 정리 지점 만들기
```

**이 장의 목적** (Lines 35-37)
```
설명:
이전 장에서 설명한 설계 원칙을 향해
점진적이고 테스트 주도적인 접근 방식으로
코드를 어떻게 nudge(부드럽게 밀어냄)하는지
```

---

### 2. 분류보다 통신

**이전 화제와의 관계**: TDD가 설계를 돕는 방법을 이해한 후, 구체적으로 통신에 집중하는 설계 접근을 설명합니다.

#### 2.1 통신 프로토콜과 Mock 객체 [핵심 개념: Communication over Classification]

**통신에 초점 맞추기** (Lines 42-46)
```
Chapter 2에서 언급:
실행 중인 시스템을 통신하는 객체의 웹으로 봄

설계 노력 초점:
객체들이 필요한 기능을 제공하기 위해 어떻게 협력하는지

목표:
잘 설계된 클래스 구조 달성

중요도:
객체 간 통신 패턴 > 클래스 구조
```

**인터페이스와 통신 프로토콜** (Lines 47-51)
```
Java 같은 언어:
인터페이스를 사용하여 객체 간 사용 가능한 메시지 정의

추가 필요 사항:
통신 패턴 정의 = 통신 프로토콜

한계:
- 명명과 규칙으로 최선을 다함
- 언어에 다음을 설명할 것이 없음:
  - 인터페이스 간 관계
  - 인터페이스 내 메서드 간 관계
- 설계의 상당 부분이 암시적으로 남음
```

**인터페이스와 프로토콜의 차이** (Lines 52-55)
```
Steve의 컨퍼런스 토크에서 들은 유용한 구분:

인터페이스 (Interface):
두 컴포넌트가 물리적으로 맞을지 설명

프로토콜 (Protocol):
두 컴포넌트가 함께 작동할지 설명
```

**Mock 객체로 통신 프로토콜 가시화** (Lines 56-71)
```
목적:
TDD와 Mock 객체를 통신 프로토콜을 가시화하는 기법으로 사용

역할:
1. 개발 중 발견 도구
2. 코드 재방문 시 설명

예시 (Chapter 3 끝부분의 단위 테스트, Lines 63-71):
```
```java
// 원본 Java 코드 (Lines 63-71)
@Test public void
notifiesAuctionClosedWhenCloseMessageReceived() {
  Message message = new Message();
  message.setBody("SOLVersion: 1.1; Event: CLOSE;");
  context.checking(new Expectations() {{
    oneOf(listener).auctionClosed();
  }});
  translator.processMessage(UNUSED_CHAT, message);
}
```
```python
# 파이썬 버전
import unittest
from unittest.mock import Mock

class TestTranslator(unittest.TestCase):
    def test_notifies_auction_closed_when_close_message_received(self):
        # 테스트 설정
        message = Message()
        message.set_body("SOLVersion: 1.1; Event: CLOSE;")

        # Mock 리스너 생성
        listener = Mock()
        translator = Translator(listener)

        # 테스트 실행
        translator.process_message(UNUSED_CHAT, message)

        # 검증: auctionClosed()가 정확히 한 번 호출되어야 함
        listener.auction_closed.assert_called_once()
```

**설명 (Lines 59-62)**:
```
특정 입력 메시지가 주어지면:
translator는 listener.auctionClosed()를 정확히 한 번 호출해야 함
→ 다른 것은 아무것도 호출하지 않음

listener 인터페이스에 다른 메서드들이 있지만:
이 테스트는 프로토콜이 auctionClosed()를 단독으로 호출하도록 요구한다고 말함
```

**정보 은닉 장려** (Lines 72-78)
```
Mock 객체를 사용한 TDD의 효과:
정보 은닉 장려

Mock 대상:
- 객체의 피어
  - 의존성 (dependencies)
  - 알림 (notifications)
  - 조정 (adjustments)
  - Page 52에서 분류한 것
- 객체의 내부는 Mock하지 않음

도움:
- 객체의 이웃을 강조하는 테스트
- 피어인지 대상 객체 내부여야 하는지 판단 도움

신호:
- 서툴거나 불명확한 테스트
  → 너무 많은 구현을 노출했다는 힌트
  → 객체와 이웃 간 책임 재조정 필요
```

---

### 3. 값 타입

**이전 화제와의 관계**: 통신에 집중한 후, 값 타입과 객체 타입의 구분과 값 타입을 발견하는 방법을 설명합니다.

#### 3.1 값 타입 도입 기법 [핵심 개념: Value Types Discovery]

**값과 객체의 구분 재방문** (Lines 85-88)
```
"Values and Objects" (page 13)에서 설명한 구분:

값 (Values):
- 불변
- 더 단순
- 의미 있는 정체성 없음

객체 (Objects):
- 상태를 가짐
- 정체성을 가짐
- 서로 관계를 가짐
```

**값 타입 정의의 중요성** (Lines 89-99)
```
확신 (Lines 89-90):
코드를 더 많이 작성할수록 확신 강화:
→ 도메인의 값 개념을 나타내는 타입을 정의해야 함
→ 많은 일을 하지 않더라도

장점:

1. 일관된 도메인 모델 생성 (Lines 90-93):
- 더 자명함 (self-explanatory)
- 예: Item 타입 생성 vs 그냥 String 사용
- 변경에 관련된 모든 코드를 메서드 호출 추적 없이 찾을 수 있음

2. 혼동 위험 감소 (Lines 94-96):
- Mars Climate Orbiter 재난 사례
- feet와 metres는 둘 다 숫자로 표현될 수 있지만 다른 것
- 1999년 NASA의 Mars Climate Orbiter가 화성 대기권에서 타버림
  → 네비게이션 소프트웨어가 미터법과 야드-파운드법 혼동
  → http://news.bbc.co.uk/1/hi/sci/tech/514763.stm

3. 행동을 거는 좋은 장소 (Lines 96-99):
- 개념을 나타내는 타입이 생기면
- 일반적으로 행동을 거는 좋은 장소로 판명됨
- 더 객체지향적 접근 사용으로 안내
- 관련 행동을 코드 전체에 흩어뜨리는 대신
```

**값 타입 도입의 세 가지 기본 기법** (Lines 100-128)
```
이름 짓기 (Lines 100-101):
(두운법 사용): Breaking Out, Budding Off, Bundling Up

1. Breaking Out (분리) (Lines 102-108):
시기:
객체의 코드가 복잡해질 때

신호:
여러 관심사를 구현하고 있다는 신호

방법:
일관된 행동 단위를 헬퍼 타입으로 분리

예시 ("Tidying Up the Translator", page 135):
- 들어오는 메시지를 처리하는 클래스를 두 부분으로 분리:
  1. 메시지 문자열을 파싱
  2. 파싱 결과를 해석

2. Budding Off (싹 틔우기) (Lines 109-114):
시기:
코드에서 새로운 도메인 개념을 표시하고 싶을 때

방법:
- 단일 필드를 감싸는 플레이스홀더 타입 도입
- 또는 필드가 전혀 없을 수도 있음

성장:
- 코드가 성장하면서 새 타입에 더 많은 세부사항 채움
- 필드와 메서드 추가

효과:
각 타입 추가마다 코드의 추상화 수준 높임

3. Bundling Up (묶기) (Lines 115-128):
시기:
값들의 그룹이 항상 함께 사용됨을 알아차릴 때

해석:
누락된 구조가 있다는 제안

첫 단계 (Lines 117-119):
- 고정된 public 필드를 가진 새 타입 생성
- 그룹에 이름만 부여해도 누락된 개념 강조

나중 단계 (Lines 119-128):
- 새 타입으로 행동 마이그레이션
- 최종적으로 깔끔한 인터페이스 뒤에 필드 숨기기 가능
- "composite simpler than the sum of its parts" 규칙 만족
```

**값 타입 발견의 동기** (Lines 129-131)
```
일반적으로 동기:
설계 원칙을 따르려는 시도에 의해 동기 부여됨
→ 테스트 작성 시 코드 스트레스에 대응하는 것이 아님
```

---

### 4. 객체는 어디서 오는가

**이전 화제와의 관계**: 값 타입 발견 방법을 이해한 후, 객체 타입을 발견하는 유사한 방법을 설명합니다.

**객체 타입 발견의 차이점** (Lines 133-138)
```
유사성:
객체 타입 발견 범주는 유사함
(그래서 이 이름들로 억지로 끼워 맞춤)

차이점:
단위 테스트 작성에서 얻는 설계 지침이 더 중요

참조:
- "External and Internal Quality" (page 10)
- 단위 테스트 노력을 코드의 내부 품질 유지에 사용
- Chapter 20: 테스트가 설계에 미치는 영향의 더 많은 예시
```

#### 4.1 Breaking Out: 큰 객체 분리 [핵심 개념: Object Discovery Techniques]

**새 코드 영역 시작 시 접근** (Lines 141-148)
```
초기 접근 (Lines 141-144):
- 일시적으로 설계 판단 중단
- 많은 구조 부과 없이 코드 작성
- 목적:
  1. 영역에서 경험 쌓기
  2. 개발 중인 외부 API 이해 테스트

이후 (Lines 144-148):
- 짧은 시간 후 코드가 이해하기 너무 복잡해짐
- 정리하고 싶음
- 방법:
  1. 일관된 기능 단위를 더 작은 협력 객체로 추출
  2. 독립적으로 단위 테스트
  3. 새 객체 분리 → 추출하는 코드의 의존성 확인 강제
```

**정리 지연에 대한 두 가지 우려** (Lines 149-156)
```
우려 1: 타이밍 (Lines 149-153)
문제:
- 시간 압박 하에서 구조화되지 않은 코드를 그대로 두고 다음으로 이동하고 싶은 유혹
- "어쨌든 작동하고 단 하나의 클래스일 뿐..."

경험:
- 의도가 명확하지 않은 너무 많은 코드 봄
- 정리 비용이 팀이 가장 감당하기 어려울 때 발생

우려 2: Spike로 취급 (Lines 153-156)
때때로 더 나은 방법:
- 이 코드를 스파이크로 취급
- 무엇을 할지 알았으면 롤백하고 깔끔하게 재구현
- 코드는 존재한다고 신성하지 않음
- 두 번째는 그렇게 오래 걸리지 않음
```

**테스트가 말하는 것** (Lines 158-159)
```
분리 신호:
- 쉽게 테스트하기에 너무 큰 객체
- 테스트 실패가 해석하기 어려워질 때

행동:
→ 새 부분을 분리하여 별도로 단위 테스트
```

**Chapter 12의 예시 미리 보기** (Lines 166-173)
```
AuctionMessageTranslator 추출:
- MainWindow와의 상호작용 포함 회피
  → 너무 많은 책임을 주게 됨

새 클래스의 행동 확인:
- 누락된 의존성 식별: AuctionEventListener
- 단위 테스트 작성 중 정의

Main의 기존 코드 재패키징:
- 새 인터페이스 구현 제공

설계 휴리스틱 만족:
1. 관심사의 분리 도입
   - 메시지 번역과 경매 표시 분리
2. 메시지 처리 코드를 새로운 도메인 특화 개념으로 추상화
```

#### 4.2 Budding Off: 새 서비스 정의 [핵심 개념: Object Discovery Techniques]

**이전 화제와의 관계**: 코드를 분리하는 것을 넘어, 객체가 필요로 하는 새로운 서비스를 발견하는 방법을 설명합니다.

**새 타입 발견 방법** (Lines 176-179)
```
상황:
코드가 더 안정적이고 어느 정도 구조를 가질 때

발견 방법:
새 타입을 존재하도록 "pulling(끌어당김)"하여 발견

과정:
- 객체에 행동 추가 중
- 설계 원칙에 따라 어떤 새 기능이 그 안에 속하지 않음을 발견
```

**새 서비스 정의 프로세스** (Lines 180-184)
```
대응:
1. 객체 관점에서 필요한 서비스를 정의하는 인터페이스 생성
2. 서비스가 이미 존재하는 것처럼 새 행동 테스트 작성
3. Mock 객체 사용:
   - 대상 객체와 새 협력자 간 관계 설명 도움
4. 이전 섹션에서 언급한 AuctionEventListener 도입 방식
```

**개발 사이클** (Lines 185-192)
```
사이클:
1. 객체 구현 중 다른 객체가 제공할 서비스 필요 발견
2. 새 서비스에 이름 부여
3. 클라이언트 객체의 단위 테스트에서 Mock out
   → 두 객체 간 관계 명확화
4. 해당 서비스를 제공하는 객체 작성
5. 작성 중 그 객체가 필요로 하는 서비스 발견
6. 기존 객체에 연결될 때까지 협력자 관계의 체인(또는 방향 그래프) 따라감
   - 우리 자신의 객체
   - 또는 제3자 API

구현:
"Develop from the Inputs to the Outputs" (page 43) 구현 방법
```

**"온디맨드" 설계** (Lines 193-195)
```
개념:
클라이언트의 필요로부터 인터페이스와 구현을 존재하도록 "pull"

vs.
클래스가 제공해야 한다고 생각하는 기능을 "push" out하는 것
```

**테스트가 말하는 것** (Lines 197-199)
```
질문:
테스트 작성 시, "이것이 작동한다면, 누가 알까?"

답변이 대상 객체가 아니면:
→ 새 협력자를 도입할 시간
```

**Chapter 13의 예시 미리 보기** (Lines 205-210)
```
Auction 인터페이스 도입:
- 입찰하는 개념이 AuctionSniper의 추가 책임이 되었을 것
- 입찰을 위한 새 서비스 도입
  → 구현 없이 인터페이스만

새 테스트 작성:
- AuctionSniper와 Auction 간 관계 표시

Auction의 구체적 구현 작성:
- 처음: Main의 익명 클래스
- 나중: XMPPAuction
```

#### 4.3 Bundling Up: 관련 객체 숨김 [핵심 개념: Object Discovery Techniques]

**이전 화제와의 관계**: 개별 객체를 발견하는 것을 넘어, 관련 객체들을 어떻게 조직화하고 숨기는지 설명합니다.

**복합 객체 패키징** (Lines 212-215)
```
원칙 적용:
"composite simpler than the sum of its parts" 규칙 (page 53)

상황:
함께 작동하는 관련 객체들의 클러스터가 있을 때

방법:
포함 객체(containing object)로 패키징

효과:
- 복잡성을 추상화로 숨김
- 더 높은 수준에서 프로그래밍 가능
```

**암시적 개념을 구체화하는 효과** (Lines 216-222)
```
추가 효과:

1. 명명 (Lines 217-218):
- 이름을 부여해야 함
- 도메인을 조금 더 잘 이해하는 데 도움

2. 의존성 범위 지정 (Lines 218-219):
- 의존성을 더 명확하게 범위 지정 가능
- 개념의 경계를 볼 수 있으므로

3. 단위 테스트 정밀도 (Lines 219-222):
- 더 정밀한 단위 테스트 가능
- 새 복합 객체를 직접 테스트
- Mock 구현 사용:
  - 추출된 코드의 테스트 단순화
  - (물론 새 객체가 수행하는 역할에 대한 인터페이스 추가)
```

**테스트가 말하는 것** (Lines 224-227)
```
복잡한 테스트 설정:
- 객체의 테스트가 설정하기 너무 복잡할 때
- 코드를 관련 상태로 만들기 위한 너무 많은 움직이는 부품

해결책:
→ 일부 협력 객체를 묶어 패키징 고려

예시:
"Bloated Constructor" (page 238)
```

**Chapter 17의 예시 미리 보기** (Lines 229-233)
```
XMPPAuctionHouse 도입:
- 메시징 인프라와 관련된 모든 것 패키징

SniperLauncher 도입:
- Sniper 구성 및 첨부

추출 후:
- SniperLauncher의 Swing 행동 참조가 부적절함이 드러남

SniperCollector 도입:
- 도메인 분리
```

---

### 5. 인터페이스로 관계 식별

**이전 화제와의 관계**: 객체를 발견한 후, 이들 간의 관계를 어떻게 정의하는지 설명합니다.

#### 5.1 좁은 인터페이스와 역할 [핵심 개념: Interface-Driven Design]

**인터페이스 사용 철학** (Lines 240-243)
```
사용 방식:
Java 인터페이스를 다른 개발자들보다 더 자유롭게 사용

반영:
통신 프로토콜로 정의된 객체 간 관계 강조

사용 목적:
1. 객체가 수행할 수 있는 역할 명명
2. 수락할 메시지 설명
```

**좁은 인터페이스 선호** (Lines 244-249)
```
선호:
가능한 좁은 인터페이스
→ 더 많은 인터페이스 필요하더라도

장점:

1. 역할 명확성 (Lines 245-247):
- 인터페이스의 메서드가 적을수록
- 호출 객체에서 역할이 더 명백
- 어떤 다른 메서드가 특정 호출과 관련 있는지 걱정할 필요 없음
- 편의를 위해 포함된 것은 무엇인지 걱정할 필요 없음

2. 구현 용이성 (Lines 248-249):
- 어댑터와 데코레이터 작성 더 쉬움
- 구현할 것이 적음
- 잘 조합되는 객체 작성 더 쉬움
```

**"Budding Off"로 인터페이스 "Pulling"** (Lines 250-253)
```
방법:
"Budding Off"에서 설명한 대로 인터페이스를 존재하도록 "Pulling"

효과:
가능한 좁게 유지 도움

이유:
- 클라이언트로부터 인터페이스 도출
- 구현자에 대한 과도한 정보 누출 회피
- 객체 간 암시적 결합 최소화
- 코드를 유연하게 유지
```

**"Impl" 클래스는 의미 없음** (Lines 255-270)
```
나쁜 관행 (Lines 255-258):
단일 인터페이스를 구현하는 클래스 이름에 "Impl" 추가

예: BookingImpl implements Booking

조금 나은 것:
클래스 이름 그대로 두고 인터페이스에 "I" 접두사
→ 하지만 많이 나은 것은 아님

문제:
- 중복
- implements Booking과 똑같은 말
- "코드 냄새"
- 코드의 다른 곳에서는 이런 명백한 중복을 허용하지 않음
- 리팩터링해야 함

해결책 1: 명명 문제 (Lines 261-265)
- 구현에 대해 특정한 것이 항상 있음
- 클래스 이름에 포함 가능:
  - bounded collection 사용
  - HTTP로 통신
  - 데이터베이스 사용한 영속성
  - 등
- 브릿징 클래스는 명명 더 쉬움
  - 한 도메인에 속하지만 다른 도메인의 인터페이스 구현

해결책 2: 설계 문제 (Lines 266-270)
정말 좋은 구현 이름이 없다면:
→ 인터페이스가 잘못 명명되거나 설계되었을 수 있음

가능성:
- 너무 많은 책임으로 초점이 없음
- 역할이 아닌 구현 이후에 명명됨
- 객체가 아닌 값
  → 단위 테스트 작성 시 나타나는 불일치
  → "Don't Mock Values" (page 237) 참조
```

#### 5.2 인터페이스 리팩터링 [핵심 개념: Interface-Driven Design]

**이전 화제와의 관계**: 인터페이스를 정의한 후, 이를 지속적으로 개선하는 방법을 설명합니다.

**유사한 인터페이스 찾기** (Lines 272-282)
```
프로토콜을 위한 인터페이스가 있으면:
유사성과 차이점에 주의 시작 가능

합리적으로 큰 코드베이스에서:
유사해 보이는 인터페이스 발견 시작

확인 사항:
단일 개념을 나타내는지
→ 병합해야 하는지

효과 (Lines 275-282):
1. 더 유연한 설계:
   - 더 많은 컴포넌트가 "플러그 호환"
   - 더 높은 수준의 추상화에서 작업 가능

2. 개발자에게 부차적 이점:
   - 이해하는 데 시간 비용이 드는 개념 감소
```

**다른 개념 구분** (Lines 283-287)
```
대안:
유사한 인터페이스가 다른 개념을 나타내는 경우

행동:
구별되도록 명확히 함
→ 컴파일러가 객체를 올바르게만 조합하도록 보장

기회:
유사해 보이는 인터페이스 분리 결정
→ 명명 재고하기 좋은 시간
→ 최소 하나에 대해 더 적절한 이름이 있을 가능성
```

**구현 시 리팩터링** (Lines 288-291)
```
또 다른 리팩터링 시기:
인터페이스 구현 시작할 때

예시:
구현 클래스의 구조가 불명확한 경우
→ 너무 많은 책임을 가질 수 있음
→ 인터페이스도 초점이 없다는 힌트일 수 있음
→ 분리해야 함
```

---

### 6. 시스템 행동을 설명하기 위한 객체 조합

**이전 화제와의 관계**: 개별 객체와 인터페이스를 이해한 후, 이들을 어떻게 조합하여 시스템을 구축하는지 설명합니다.

#### 6.1 객체 조합으로 웹 구성 [핵심 개념: Composing Objects]

**단위 수준 TDD의 결과** (Lines 293-297)
```
단위 수준 TDD가 안내:
시스템을 다음으로 분해:
- 값 타입
- 느슨하게 결합된 계산 객체

테스트가 제공:
- 각 객체가 어떻게 행동하는지 잘 이해
- 다른 객체와 어떻게 결합될 수 있는지

사용:
낮은 수준 객체를 더 유능한 객체의 빌딩 블록으로 사용
→ Chapter 2에서 설명한 객체의 웹
```

**jMock 예시** (Lines 298-303)
```
jMock에서 (Lines 298-303):
테스트에 대한 예상 호출 설명을 Mockery라는 컨텍스트 객체에 조립

테스트 실행 중:
- Mockery가 모든 Mock 객체에 대한 호출을 Expectations로 전달
- 각 Expectation이 호출 매칭 시도
- Expectation이 매칭되면 → 테스트의 해당 부분 성공
- 매칭되지 않으면 → 각 Expectation이 불일치 보고, 테스트 실패

런타임 조립 객체:
Figure 7.1 참조
```

**조합 접근의 장점** (Lines 306-317)
```
장점:
1. 상대적으로 적은 코드로 유연한 애플리케이션 구조 구축 (Lines 306-307)

2. 많은 관련 시나리오를 지원해야 하는 코드에 특히 적합 (Lines 307-309)

3. 각 시나리오마다:
   - 다른 컴포넌트 조립 제공
   - 효과적으로 애플리케이션의 나머지 부분에 플러그인할 하위 시스템 구축

4. 확장 용이 (Lines 315-317):
   - 새로운 플러그 호환 컴포넌트 작성하고 추가
   - Part III에서 여러 새로운 Hamcrest matcher 작성 예정
```

**jMock 예시 코드** (Lines 318-327)
```java
// 원본 Java 코드 (Lines 321-327)
InvocationExpectation expectation = new InvocationExpectation();
expectation.setParametersMatcher(
  new AllParametersMatcher(Arrays.asList(new IsInstanceOf(String.class)));
expectation.setCardinality(new Cardinality(1, 1));
expectation.setMethodMatcher(new MethodNameMatcher("doSomething"));
expectation.setObjectMatcher(new IsSame<Example>(example));
context.addExpectation(expectation);
```
```python
# 파이썬 버전
from unittest.mock import Mock

# jMock 스타일의 expectation 설정을 파이썬으로 표현
expectation = InvocationExpectation()
# 파라미터 매처 설정: String 타입 확인
expectation.set_parameters_matcher(
    AllParametersMatcher([IsInstanceOf(str)])
)
# 카디널리티 설정: 정확히 1번 호출
expectation.set_cardinality(Cardinality(1, 1))
# 메서드 매처 설정: "doSomething" 메서드
expectation.set_method_matcher(MethodNameMatcher("doSomething"))
# 객체 매처 설정: example 객체와 동일
expectation.set_object_matcher(IsSame(example))
# 컨텍스트에 expectation 추가
context.add_expectation(expectation)
```

**목적 (Lines 318-320)**:
```
jMock이 example.doSomething()이 확인하도록:
- 정확히 한 번 호출
- String 타입의 인수와 함께

테스트 컨텍스트 설정
```

#### 6.2 높은 수준의 프로그래밍으로 구축 [핵심 개념: Declarative vs Implementation Layers]

**이전 화제와의 관계**: 객체 조합의 어려움을 이해하고 이를 해결하는 방법을 설명합니다.

**코드 조각의 어려움** (Lines 329-335)
```
발견 (Lines 329-330):
위 코드 조각의 어려움 발견했을 것:
→ 기대가 무엇을 테스트하는지 잘 설명하지 않음

개념적 단순함 (Lines 330-331):
객체 웹 조립은 개념적으로 직관적

문제 (Lines 331-335):
주류 언어가 우리가 관심 있는 정보를 묻어버림
- 정보: 객체와 그들의 관계
- 문제: 키워드, setter, 구두점 등의 수렁

이 예시의 문제:
- 객체 할당과 연결만 함
- 조립하는 시스템의 행동 이해 도움 안 됨
- 의도를 표현하지 않음
```

**두 레이어 조직** (Lines 336-343)
```
대응:
코드를 두 레이어로 조직

1. 구현 레이어 (Implementation Layer) (Lines 337-338):
- 객체 그래프
- 행동: 객체들이 이벤트에 어떻게 응답하는지의 결합된 결과

2. 선언적 레이어 (Declarative Layer) (Lines 338-343):
- 구현 레이어의 객체를 구축
- 작은 "sugar" 메서드와 구문 사용
- 각 조각의 목적 설명
- 코드가 무엇을 할지(what) 설명
- 구현 레이어는 코드가 어떻게(how) 하는지 설명
- 효과: Java에 내장된(이 경우) 작은 도메인 특화 언어
```

**두 레이어의 다른 코딩 스타일** (Lines 344-348)
```
구현 레이어:
- 이전 장에서 설명한 전통적인 객체지향 스타일 가이드라인 고수

선언적 레이어:
- 더 유연
- "train wreck" 메서드 호출 체이닝 사용 가능
- 정적 메서드 사용 가능
- 요점 전달을 돕기 위함
```

**jMock 개선 예시** (Lines 349-361)
```
이전 섹션 예시 재작성 (Lines 359-361):
```
```java
// 원본 Java 코드 (Lines 359-361)
context.checking(new Expectations() {{
    oneOf(example).doSomething(with(any(String.class)));
}});
```
```python
# 파이썬 버전 (unittest.mock 사용)
from unittest.mock import Mock, call, ANY

# 컨텍스트 설정
context = Mock()

# Expectations 스타일의 검증
context.checking(lambda: [
    # example.doSomething이 String 인수와 함께 정확히 한 번 호출
    call(example.do_something)(ANY)
])
```

**Expectations 객체 설명** (Lines 362-364)
```
Expectations 객체:
- Builder 패턴 [Gamma94]
- expectations와 matchers의 조립을 구성
- Mockery에 로드

Figure 7.2 참조: 구문 레이어가 인터프리터를 구성
```

**선언적 레이어의 출현** (Lines 367-375)
```
대부분의 경우 (Lines 367-369):
선언적 레이어는 지속적인 "무자비한" 리팩터링에서 출현

프로세스:
1. 객체를 직접 조합하는 코드 작성으로 시작
2. 중복 계속 제거
3. 헬퍼 메서드 추가:
   - 주요 코드 본문에서 구문 노이즈 밀어냄
   - 설명 추가
4. 코드 영역이 명확하지 않을 때 주의
5. 명확해질 때까지 구조 추가 또는 이동
   - 현대 리팩터링 IDE에서 매우 쉬움
6. 최종적으로 두 레이어 구조 발견

대안 (Lines 373-375):
가끔 원하는 선언적 코드에서 시작
→ 구현을 채우기 위해 아래로 작업
→ Chapter 10의 첫 end-to-end 테스트에서 수행
```

**목적과 영감** (Lines 376-382)
```
목적 (Lines 376-378):
더 적은 코드로 더 많이 달성

열망:
제어 흐름과 데이터 조작 관점의 프로그래밍에서
→ 더 작은 프로그램으로부터 프로그램 조합으로 상승
→ 객체가 행동의 가장 작은 단위 형성

새로운 것 아님 (Lines 379-382):
- 파이프로 유틸리티 조합하여 Unix 프로그래밍 [Kernighan76]
  - Douglas McIlroy에게 파이프 아이디어 귀속
  - 1964년 메모: 분할된 정원 호스를 통과하는 데이터 비유 제안
  - http://plan9.bell-labs.com/who/dmr/mdmpipe.pdf
- Lisp에서 언어 레이어 구축 [Graham93]
- 하지만 현장에서 원하는 만큼 자주 보지 못함
```

---

### 7. 클래스는 어떤가

**이전 화제와의 관계**: 객체와 인터페이스에 집중한 후, 클래스와 상속에 대한 관점을 정리합니다.

#### 7.1 인터페이스가 클래스보다 중요 [핵심 개념: Interfaces over Classes]

**클래스와 상속에 대해 많이 말하지 않은 이유** (Lines 392-396)
```
특이점:
객체지향 소프트웨어 책치고 클래스와 상속에 대해 많이 말하지 않음

이유 (Lines 393-396):
- 애플리케이션 도메인을 객체 간 간격으로 밀어넣음
- 통신 프로토콜
- 클래스보다 인터페이스 강조
  → 다른 객체가 보는 것이기 때문
- 객체의 타입은 수행하는 역할로 정의됨
```

**클래스를 "구현 세부사항"으로 봄** (Lines 397-400)
```
관점:
객체의 클래스를 "구현 세부사항"으로 봄
→ 타입 자체가 아닌 타입 구현 방법

객체 클래스 계층 발견:
공통 행동 제거로 발견

선호:
가능하면 위임으로 리팩터링 선호
→ 코드를 더 유연하고 이해하기 쉽게 만듦

값 타입:
- 위임 사용 가능성 낮음
- 피어가 없기 때문
```

**참고 자료** (Lines 403-406)
```
클래스 작업에 대한 좋은 조언:
- [Fowler99]
- [Kerievsky04]
- [Evans03]

다중 상속을 잘 지원하는 언어에서는 설계 힘이 다름:
- Eiffel [Meyer91]
```

---

## 참조 정보

**책 이름**: Growing Object-Oriented Software, Guided by Tests
**장 번호**: Chapter 7
**장 제목**: Achieving Object-Oriented Design
**페이지 범위**: 82-93
