# Growing_object_oriented_software_guided_by_tests_Chapter 5: Maintaining the Test-Driven Cycle

## 압축 내용

TDD 사이클을 유지하려면 도메인 용어로 작성된 실패하는 인수 테스트로 각 기능을 시작하고, 가장 단순한 성공 사례부터 테스트하며, 읽고 싶은 테스트를 작성하고, 테스트 실패를 확인한 후, 입력에서 출력으로 개발하고, 메서드가 아닌 행동을 테스트하며, 테스트의 피드백에 귀 기울여 설계를 개선하고, 단위 테스트와 통합 테스트의 균형을 지속적으로 조정해야 한다.

## 핵심 내용

### 핵심 개념들
1. **Acceptance Test First** (참조: [상세 내용 1.1, 1.2])
2. **Simplest Success Case** (참조: [상세 내용 2.1])
3. **Test Readability** (참조: [상세 내용 3.1, 3.2])
4. **Outside-In Development** (참조: [상세 내용 4.1])
5. **Behavior-Driven Testing** (참조: [상세 내용 5.1])
6. **Test-Driven Design** (참조: [상세 내용 6.1])
7. **Test Balance** (참조: [상세 내용 7.1])

### 핵심 개념 설명

**1. Acceptance Test First** (참조: [상세 내용 1.1, 1.2])
- 새 기능 작업을 실패하는 인수 테스트 작성으로 시작
- 도메인 용어만 사용하여 작성 (기술적 세부사항 배제)
- 진행 중인 테스트와 회귀 테스트를 분리하여 관리
- 인수 테스트가 빨간색에서 녹색으로 바뀌는 것이 진행 상황의 척도

**2. Simplest Success Case** (참조: [상세 내용 2.1])
- 퇴화 케이스나 실패 케이스 대신 가장 단순한 성공 케이스부터 시작
- 솔루션의 실제 구조를 더 잘 이해할 수 있게 함
- 실패 케이스는 노트패드나 인덱스 카드에 기록하여 나중에 처리

**3. Test Readability** (참조: [상세 내용 3.1, 3.2])
- 읽고 싶은 테스트를 작성: 수행할 행동의 명확한 표현
- 테스트가 잘 읽힐 때까지 지원 인프라 구축은 무시
- 테스트 실패를 확인하고 진단 메시지의 명확성 검증
- 오류 메시지가 문제를 명확히 안내할 때까지 테스트 코드 조정

**4. Outside-In Development** (참조: [상세 내용 4.1])
- 입력(외부 이벤트)에서 출력(외부 응답)으로 개발
- 시스템 경계에서 시작하여 중앙 도메인 모델을 거쳐 다른 경계 객체로 진행
- 도메인 모델부터 시작하는 것보다 통합 문제를 조기에 발견

**5. Behavior-Driven Testing** (참조: [상세 내용 5.1])
- 메서드가 아닌 행동(기능)을 테스트
- 테스트 이름이 시나리오에서 객체가 어떻게 행동하는지 설명
- 클래스를 사용하여 목표를 달성하는 방법을 알아야 함

**6. Test-Driven Design** (참조: [상세 내용 6.1])
- 테스트하기 어려운 코드는 설계 개선 필요 신호
- 테스트 작성 과정을 잠재적 유지보수 문제의 조기 경고로 활용
- 테스트 작성이 어려우면 프로덕션 코드를 리팩터링

**7. Test Balance** (참조: [상세 내용 7.1])
- 단위 테스트(목 객체 사용)와 통합 테스트의 균형
- 너무 큰 단위: 조합 폭발로 개발 중단
- 너무 작은 단위: 객체 간 상호작용 문제 놓침
- 컨텍스트에 따라 테스트 전략을 지속적으로 반영하고 조정

### 핵심 개념 간 관계

**Acceptance Test First**로 시작하여 **Simplest Success Case**부터 구현하고, **Test Readability**를 유지하면서 **Outside-In Development** 방식으로 개발합니다. 이 과정에서 **Behavior-Driven Testing** 접근을 통해 메서드가 아닌 행동에 집중하고, **Test-Driven Design** 원칙에 따라 테스트의 피드백을 듣고 설계를 개선합니다. 마지막으로 **Test Balance**를 통해 단위 테스트와 통합 테스트의 적절한 균형을 유지하며 전체 TDD 사이클을 조정합니다.

## 상세 내용

### 목차
1. 인수 테스트로 기능 시작
   1.1 인수 테스트 우선 작성
   1.2 진행 중인 테스트와 회귀 테스트 분리
2. 가장 단순한 성공 케이스부터 테스트
   2.1 단순한 성공 케이스 우선 원칙
3. 읽고 싶은 테스트 작성
   3.1 테스트 가독성 우선
   3.2 테스트 실패 확인
4. 입력에서 출력으로 개발
   4.1 Outside-In 개발 방식
5. 메서드가 아닌 행동 테스트
   5.1 행동 중심 테스트
6. 테스트에 귀 기울이기
   6.1 테스트 주도 설계
7. 사이클 조정
   7.1 테스트 균형 유지

---

### 1. 인수 테스트로 기능 시작

**화제 배경**: TDD 프로세스가 시작된 후에는 이를 원활하게 유지해야 합니다. 각 새로운 기능을 어떻게 시작하고 진행할지가 핵심입니다. (Lines 13-18)

#### 1.1 인수 테스트 우선 작성 [핵심 개념: Acceptance Test First]

**인수 테스트로 시작하는 이유** (Lines 20-23)
```
새 기능 작업 시작 방법 (Figure 5.1):
1. 시스템이 아직 해당 기능을 가지고 있지 않음을 보여주는 실패하는 인수 테스트 작성
2. 기능 완료를 향한 진행 상황 추적
```

**도메인 용어 사용의 중요성** (Lines 24-32)
```
인수 테스트 작성 원칙:
- 애플리케이션 도메인의 용어만 사용
- 기반 기술(데이터베이스, 웹 서버)의 용어 사용 금지

장점:
1. 시스템이 무엇을 해야 하는지 이해 도움
2. 구현에 대한 초기 가정에 얽매이지 않음
3. 기술적 세부사항으로 테스트를 복잡하게 만들지 않음
4. 인수 테스트 스위트를 시스템의 기술 인프라 변경으로부터 보호

예시:
- 제3자 조직이 FTP와 바이너리 파일에서 웹 서비스와 XML로 프로토콜 변경
- 시스템의 애플리케이션 로직 테스트 재작업 불필요
```

**테스트 우선 작성의 이점** (Lines 33-44)
```
명확성:
- 무엇을 달성하고자 하는지 명확히 함
- 자동 검사 가능한 형태로 요구사항 표현 → 암묵적 가정 발견

집중:
- 실패하는 테스트가 제한된 기능 세트에 집중하게 함
- 기능 전달 가능성 향상

사용자 관점:
- 사용자 관점에서 시스템 바라보기
- 구현자 관점에서 기능 추측하는 것이 아닌 사용자가 필요한 것 이해
```

**인수 테스트와 단위 테스트의 차이** (Lines 45-49)
```
단위 테스트:
- 객체 또는 작은 객체 클러스터를 독립적으로 테스트
- 클래스 설계 도움
- 클래스가 작동한다는 확신 제공
- 시스템의 나머지 부분과 함께 작동하는지는 알 수 없음

인수 테스트:
- 단위 테스트된 객체의 통합 테스트
- 프로젝트를 앞으로 추진
```

#### 1.2 진행 중인 테스트와 회귀 테스트 분리 [핵심 개념: Acceptance Test First]

**이전 화제와의 관계**: 인수 테스트 작성 후, 이를 어떻게 관리하고 조직화할지 설명합니다.

**인수 테스트의 두 가지 상태** (Lines 52-59)
```
새로운 인수 테스트 (빨간색):
- 새 기능 설명
- 아직 수행할 작업 표현
- 기능 구현될 때까지 실패 예상
- 빨간색에서 녹색으로 변하는 활동이 진행 상황의 척도

완료된 인수 테스트 (녹색):
- 완료된 기능 표현
- 다시 실패하지 않아야 함
- 실패는 회귀 발생 의미 (기존 코드가 깨짐)
```

**테스트 스위트 조직** (Lines 60-65)
```
테스트 역할에 따른 조직:

단위 및 통합 테스트:
- 개발팀 지원
- 빠르게 실행
- 항상 통과

완료된 기능의 인수 테스트:
- 회귀 포착
- 항상 통과 (실행 시간 더 길 수 있음)

새로운 인수 테스트:
- 진행 중인 작업 표현
- 기능 준비될 때까지 통과하지 않음
```

**요구사항 변경 시 대응** (Lines 66-68)
- 영향받는 인수 테스트를 회귀 스위트에서 진행 중 스위트로 이동
- 새 요구사항을 반영하도록 편집
- 다시 통과하도록 시스템 변경

---

### 2. 가장 단순한 성공 케이스부터 테스트

**이전 화제와의 관계**: 인수 테스트 작성 후, 구체적으로 어떤 테스트부터 작성할지 설명합니다.

#### 2.1 단순한 성공 케이스 우선 원칙 [핵심 개념: Simplest Success Case]

**퇴화 케이스부터 시작하는 유혹** (Lines 75-83)
```
일반적인 유혹:
- 퇴화 케이스나 실패 케이스부터 시작 (종종 더 쉬움)
- XP 격언 "가능한 가장 단순한 것"의 일반적 해석 [Beck02]

문제점:
1. 퇴화 케이스는 시스템 가치에 많이 기여하지 않음
2. 아이디어의 유효성에 대한 충분한 피드백을 주지 않음
3. 실패 케이스에만 집중 → 사기 저하
   (오류 처리만 작업하면 아무것도 달성하지 못하는 느낌)
```

**단순한 성공 케이스부터 시작하는 이유** (Lines 84-89)
```
선호하는 접근:
가장 단순한 성공 케이스 테스트부터 시작

장점:
1. 작동하면 솔루션의 실제 구조를 더 잘 이해
2. 도중에 발견한 가능한 실패 처리와 추가 성공 케이스 사이의 우선순위 지정 가능

주의:
- 기능은 강건할 때까지 완료되지 않음
- 실패 처리를 신경 쓰지 않는다는 변명 아님
- 무엇을 먼저 구현할지 선택 가능
```

**작업 관리 방법** (Lines 90-94)
```
실용적 방법:
- 키보드 옆에 노트패드나 인덱스 카드 비치
- 실패 케이스, 리팩터링, 기타 기술 작업 기록
- 현재 작업에 집중하면서 세부사항 놓치지 않음
- 기능 완료 조건: 목록의 모든 항목 완료 (또는 불필요 판단)
```

**실제 사례: 달 착륙 프로그램** (Lines 96-116)
```
점진적 접근의 예 (1967년 달 착륙 프로그램):

7단계 미션:
1. 무인 Command/Service Module (CSM) 테스트
2. 무인 Lunar Module (LM) 테스트
3. 유인 CSM 저궤도 지구 궤도
4. 유인 CSM 및 LM 저궤도 지구 궤도
5. 유인 CSM 및 LM 타원형 지구 궤도 (원지점 4600mi)
6. 유인 CSM 및 LM 달 궤도
7. 유인 달 착륙

소프트웨어에서는 매번 새 로켓을 만들 필요 없이 점진적 개발 가능
```

---

### 3. 읽고 싶은 테스트 작성

**이전 화제와의 관계**: 어떤 테스트부터 작성할지 결정한 후, 테스트를 어떻게 작성할지 설명합니다.

#### 3.1 테스트 가독성 우선 [핵심 개념: Test Readability]

**테스트 작성 원칙** (Lines 122-125)
```
목표:
각 테스트가 시스템이나 객체가 수행할 행동의 가장 명확한 표현이 되도록

작성 방법:
1. 테스트가 실행되지 않거나 컴파일되지 않는 사실 무시
2. 테스트 텍스트에만 집중
3. 테스트 실행을 지원하는 코드가 이미 존재한다고 가정
```

**지원 인프라 구축** (Lines 126-130)
```
테스트가 잘 읽힐 때:
→ 테스트를 지원하는 인프라 구축

구현 충분성 판단:
- 테스트가 예상대로 실패
- 수행해야 할 작업을 설명하는 명확한 오류 메시지

그 후:
테스트를 통과시키는 코드 작성 시작

참조: Chapter 21 - 테스트 가독성 향상
```

#### 3.2 테스트 실패 확인 [핵심 개념: Test Readability]

**이전 화제와의 관계**: 테스트 작성 후, 실제로 테스트를 실행하고 실패를 확인하는 과정을 설명합니다.

**테스트 실패 확인의 중요성** (Lines 132-138)
```
절차:
1. 코드 작성 전 항상 테스트 실패 확인
2. 진단 메시지 확인

예상과 다른 실패:
→ 무언가 오해했거나 코드가 불완전함 → 수정

"올바른" 실패:
→ 진단이 도움이 되는지 확인

불명확한 실패 설명:
→ 몇 주 후 코드가 깨질 때 누군가(아마도 우리)가 고생
→ 테스트 코드 조정 및 재실행
→ 오류 메시지가 코드 문제로 안내할 때까지 반복

Figure 5.2: TDD 사이클의 일부로 진단 개선
```

**프로덕션 코드 작성 중** (Lines 141-144)
- 테스트 계속 실행하여 진행 상황 확인
- 시스템이 테스트 뒤에 구축되면서 오류 진단 확인
- 필요시 지원 코드 확장/수정하여 오류 메시지가 항상 명확하고 관련성 있도록 보장

**오류 메시지 확인을 고집하는 이유** (Lines 145-157)
```
이유 1 - 가정 확인:
- 작업 중인 코드에 대한 가정 확인
- 때로 우리가 틀림

이유 2 - 의도 표현:
- 의도 표현 강조 → 신뢰할 수 있고 유지보수 가능한 시스템 개발의 기본
- 테스트와 실패 메시지 포함
- 유용한 진단 생성 노력 → 테스트(따라서 코드)가 무엇을 해야 하는지 명확히 함

참조: Chapter 23 - 오류 진단 및 개선 방법
```

---

### 4. 입력에서 출력으로 개발

**이전 화제와의 관계**: 테스트 작성 방법을 이해한 후, 시스템을 어떤 순서로 개발할지 설명합니다.

#### 4.1 Outside-In 개발 방식 [핵심 개념: Outside-In Development]

**개발 시작점** (Lines 159-165)
```
시작:
새 행동을 트리거할 시스템으로 들어오는 이벤트 고려

프로세스:
1. 기능의 end-to-end 테스트가 도착하는 이벤트 시뮬레이션
2. 시스템 경계에서 이벤트 처리 객체 작성
3. 객체가 책임을 수행하기 위해 시스템의 나머지 부분에서 지원 서비스 필요 발견
4. 이 서비스를 구현하는 더 많은 객체 작성
5. 이 새 객체가 필요로 하는 서비스 발견
```

**시스템 전체 작업 흐름** (Lines 166-170)
```
작업 방식:
외부 이벤트 수신 객체
→ 중간 레이어
→ 중앙 도메인 모델
→ 외부 가시 응답 생성하는 다른 경계 객체

예시:
- 텍스트와 마우스 클릭 수락 → 데이터베이스에서 레코드 검색
- 큐에서 메시지 수신 → 서버에서 파일 검색
```

**도메인 모델부터 시작하는 유혹과 문제점** (Lines 171-177)
```
유혹:
- 새 도메인 모델 객체를 단위 테스트하고 애플리케이션의 나머지 부분에 연결

처음에는 쉬워 보이는 이유:
- 다른 것에 맞출 필요 없이 도메인 모델 작업 → 빠른 진행 느낌

문제점:
1. 나중에 통합 문제로 인한 피해 가능성 높음
2. 불필요하거나 잘못된 기능 구축에 시간 낭비
   → 작업 중 올바른 종류의 피드백을 받지 못했기 때문
```

---

### 5. 메서드가 아닌 행동 테스트

**이전 화제와의 관계**: 개발 순서를 이해한 후, 단위 테스트를 작성할 때 무엇에 집중해야 하는지 설명합니다.

#### 5.1 행동 중심 테스트 [핵심 개념: Behavior-Driven Testing]

**많은 테스트 작성의 문제** (Lines 179-182)
```
어려운 경험:
- 많은 테스트 작성 (높은 테스트 커버리지 생성)
- ≠ 작업하기 쉬운 코드베이스 보장

일반적인 실수:
- TDD 채택한 많은 개발자가 초기 테스트를 나중에 재방문할 때 이해 어려움
- 메서드 테스트에 대해 생각하는 것

예시:
testBidAccepted() → 무엇을 하는지는 알려주지만 무엇을 위한 것인지는 알려주지 않음
```

**더 나은 접근: 행동에 집중** (Lines 184-187)
```
초점:
테스트 대상 객체가 제공해야 하는 기능(features)

특징:
- 이웃과의 협력 필요 가능
- 하나 이상의 메서드 호출 필요 가능

목표:
- 클래스를 사용하여 목표를 달성하는 방법 알기
- 코드의 모든 경로를 실행하는 방법이 아님
```

**실제 사례: Formula One 게임** (Lines 193-208)
```
배경:
- Nat이 2주 만에 F1 레이스 전략 시뮬레이션 게임 작성
- 클라이언트에 전달 후 잊음
- 팀 웹사이트에서 가장 인기 있는 콘텐츠로 판명

확장 요구:
- 다음 F1 시즌용으로 많은 기능 추가 요청
- 각 Grand Prix 트랙 모델링
- 최신 F1 규칙 수용
- 더 나은 차량 물리 모델
- 동적 날씨, 추월, 스핀아웃 등 시뮬레이션

문제:
- 원래 버전을 테스트 우선으로 작성 → 변경 쉬울 것으로 예상
- 코드로 돌아갔을 때 테스트 이해 매우 어려움
- 각 객체의 각 메서드에 대한 테스트 작성
- 테스트에서 각 객체가 어떻게 행동해야 하는지 이해 불가
  - 객체의 책임이 무엇인지
  - 객체의 다른 메서드들이 어떻게 함께 작동하는지

교훈:
테스트 이름이 테스트되는 시나리오에서 객체가 어떻게 행동하는지 설명하도록 선택

참조: "Test Names Describe Features" (page 248)
```

---

### 6. 테스트에 귀 기울이기

**이전 화제와의 관계**: 행동 중심 테스트 작성 후, 테스트 작성 과정에서 얻는 피드백을 활용하는 방법을 설명합니다.

#### 6.1 테스트 주도 설계 [핵심 개념: Test-Driven Design]

**테스트 작성 시 경계** (Lines 213-215)
```
주의 사항:
단위 및 통합 테스트 작성 시 테스트하기 어려운 코드 영역에 경계

질문:
- 어떻게 테스트할 것인가?
- 왜 테스트하기 어려운가? ← 더 중요
```

**테스트하기 어려운 코드의 의미** (Lines 216-222)
```
경험:
코드가 테스트하기 어려울 때, 가장 가능성 높은 원인은 설계 개선 필요

이유:
1. 지금 코드를 테스트하기 어렵게 만드는 구조
   = 미래에 변경하기 어렵게 만드는 구조
2. 그 미래가 오면 변경은 더욱 어려움
   (코드 작성 당시 생각을 잊었기 때문)
3. 성공적인 시스템의 경우
   → 완전히 다른 팀이 우리 결정의 결과와 함께 살아야 할 수 있음
```

**대응 방법** (Lines 223-227)
```
접근:
1. 테스트 작성 과정 → 잠재적 유지보수 문제의 귀중한 조기 경고로 간주
2. 힌트를 사용하여 문제가 아직 신선할 때 수정

Figure 5.3:
다음 실패 테스트 작성이 어렵다면
→ 프로덕션 코드 설계 재검토
→ 종종 계속 진행하기 전에 리팩터링
```

**"예상치 못한 변경 예상" 격언의 예** (Lines 236-241)
```
원칙:
설계의 약점을 발견할 때 리팩터링하여 시스템 품질 유지
→ 어떤 변경이 발생하든 대응 가능

대안:
일반적인 "소프트웨어 부패"
→ 코드가 부패하여 팀이 고객 요구에 대응할 수 없게 됨

참조: Chapter 20 - 이 주제로 돌아감
```

---

### 7. 사이클 조정

**이전 화제와의 관계**: 전체 TDD 사이클을 이해한 후, 이를 지속적으로 조정하고 개선하는 방법을 설명합니다.

#### 7.1 테스트 균형 유지 [핵심 개념: Test Balance]

**테스트 수준의 균형 문제** (Lines 243-249)
```
두 극단의 문제:

너무 큰 단위로 테스트:
- 코드를 통한 모든 가능한 경로 시도의 조합 폭발
- 개발 중단
- 일부 경로(예: 모호한 예외 던지기)는 해당 수준에서 테스트 불가능

너무 작은 단위로 테스트 (예: 클래스 수준만):
- 테스트 더 쉬움
- 객체가 함께 작동하지 않는 문제 놓침
```

**단위 테스트와 통합 테스트의 균형** (Lines 250-255)
```
질문:
- 얼마나 많은 단위 테스트를 해야 하는가?
  (목 객체를 사용하여 외부 의존성 제거)
- 얼마나 많은 통합 테스트를 해야 하는가?

답변:
- 단일 답변 없음
- 팀과 환경의 컨텍스트에 너무 많이 의존

TDD 테스팅 부분에서 얻을 수 있는 최선:
- 코드를 깨지 않고 변경할 수 있다는 확신 (많은 것)
- 두려움은 진행을 죽임

비결:
확신이 정당화되는지 확인
```

**지속적인 반영과 조정** (Lines 256-260)
```
프로세스:
1. TDD가 얼마나 잘 작동하는지 정기적으로 반영
2. 약점 식별
3. 테스트 전략 조정

조정 예시:
- 까다로운 로직 비트 → 더 많은 단위 테스트 필요 (또는 단순화)
- 처리되지 않은 예외 → 더 많은 통합 수준 테스트 필요
- 예상치 못한 시스템 실패 → 더 많은 조사 및 전체 테스트 필요
```

---

## 참조 정보

**책 이름**: Growing Object-Oriented Software, Guided by Tests
**장 번호**: Chapter 5
**장 제목**: Maintaining the Test-Driven Cycle
**페이지 범위**: 64-71
