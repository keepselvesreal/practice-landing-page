# Growing_object_oriented_software_guided_by_tests_Chapter 6: Object-Oriented Style

## 압축 내용

유지보수 가능한 객체지향 시스템을 설계하려면 관심사의 분리(Separation of Concerns)와 높은 수준의 추상화(Higher Levels of Abstraction)를 통해 포트와 어댑터 아키텍처로 비즈니스 도메인을 기술 인프라로부터 격리하고, 캡슐화(Encapsulation)와 정보 은닉(Information Hiding)을 구분하며, 객체 내부(Internals)와 피어(Peers)를 명확히 구분하고, 단일 책임 원칙(Single Responsibility)을 따르며, 의존성(Dependencies), 알림(Notifications), 조정(Adjustments)의 세 가지 피어 관계를 이해하고, 복합 객체를 구성 요소보다 단순하게 만들며, 컨텍스트 독립성(Context Independence)을 유지하고, 올바른 정보를 은닉해야 한다.

## 핵심 내용

### 핵심 개념들
1. **Separation of Concerns** (참조: [상세 내용 1.1])
2. **Higher Levels of Abstraction** (참조: [상세 내용 1.1])
3. **Ports and Adapters Architecture** (참조: [상세 내용 1.1])
4. **Encapsulation vs Information Hiding** (참조: [상세 내용 2.1])
5. **Internals vs Peers** (참조: [상세 내용 3.1])
6. **Single Responsibility Principle** (참조: [상세 내용 4.1])
7. **Object Peer Stereotypes** (참조: [상세 내용 5.1])
8. **Composite Simpler Than the Sum of Its Parts** (참조: [상세 내용 6.1])
9. **Context Independence** (참조: [상세 내용 7.1])

### 핵심 개념 설명

**1. Separation of Concerns** (참조: [상세 내용 1.1])
- 시스템 행동 변경 시 가능한 적은 코드 변경
- 같은 이유로 변경될 코드를 함께 모음
- 예측 불가능한 변경에 대비하여 구조화

**2. Higher Levels of Abstraction** (참조: [상세 내용 1.1])
- 복잡성 회피를 통한 인간의 복잡성 다루기
- 변수와 제어 흐름 조작보다 유용한 기능의 컴포넌트 조합으로 프로그래밍
- 더 높은 수준의 추상화에서 작업

**3. Ports and Adapters Architecture** (참조: [상세 내용 1.1])
- 비즈니스 도메인 코드를 기술 인프라 의존성으로부터 격리
- 포트: 애플리케이션 모델이 외부 세계와의 관계를 자신의 용어로 설명하는 인터페이스
- 어댑터: 애플리케이션 코어와 각 기술 도메인 간의 브릿지

**4. Encapsulation vs Information Hiding** (참조: [상세 내용 2.1])
- 캡슐화: 객체의 행동이 API를 통해서만 영향받도록 보장
- 정보 은닉: API의 추상화 뒤에 구현 방법 숨김
- 두 개념은 별개이고 대체로 직교함

**5. Internals vs Peers** (참조: [상세 내용 3.1])
- 내부(Internals): API를 통해 캡슐화된 객체 내부
- 피어(Peers): 메시지 송수신으로 직접 통신하는 다른 객체들
- 명확한 API를 가진 일관된 추상화 제공

**6. Single Responsibility Principle** (참조: [상세 내용 4.1])
- 모든 객체는 단일하고 명확하게 정의된 책임을 가져야 함
- "and", "or" 없이 객체가 하는 일을 설명할 수 있어야 함
- 절(clause)이 추가되면 협력하는 객체들로 분리

**7. Object Peer Stereotypes** (참조: [상세 내용 5.1])
- 의존성(Dependencies): 객체가 책임 수행을 위해 필요한 서비스, 생성자를 통해 전달
- 알림(Notifications): 객체의 활동을 최신 상태로 유지해야 하는 피어, "발사하고 잊기"
- 조정(Adjustments): 시스템의 더 넓은 요구에 맞게 객체의 행동을 조정하는 피어

**8. Composite Simpler Than the Sum of Its Parts** (참조: [상세 내용 6.1])
- 새로운 타입은 모든 구성 요소를 합친 것보다 단순한 행동 전시
- 복합 객체의 API는 구성 요소의 존재와 상호작용 숨김
- 피어에게 더 단순한 추상화 노출

**9. Context Independence** (참조: [상세 내용 7.1])
- 객체가 실행되는 시스템에 대한 내장 지식이 없음
- 더 큰 환경에 대해 알아야 할 것은 전달됨 (생성자 또는 메서드)
- 행동 단위(객체)를 새로운 상황에 적용 가능

### 핵심 개념 간 관계

**Separation of Concerns**와 **Higher Levels of Abstraction** 원칙을 일관되게 적용하면 **Ports and Adapters Architecture**로 나아갑니다. 이 아키텍처에서는 **Encapsulation vs Information Hiding**을 구분하고, **Internals vs Peers**를 명확히 구분합니다. 각 객체는 **Single Responsibility Principle**을 따르며, 피어와는 **Object Peer Stereotypes**(Dependencies, Notifications, Adjustments)의 세 가지 관계로 통신합니다. 객체를 조합할 때는 **Composite Simpler Than the Sum of Its Parts** 원칙을 따르고, **Context Independence**를 유지하여 재사용 가능하고 변경하기 쉬운 시스템을 만듭니다.

## 상세 내용

### 목차
1. 유지보수 가능한 설계
   1.1 관심사의 분리와 높은 추상화 수준
   1.2 포트와 어댑터 아키텍처
2. 캡슐화와 정보 은닉
   2.1 캡슐화 vs 정보 은닉의 구분
   2.2 앨리어싱 문제와 캡슐화 유지
3. 내부 vs 피어
   3.1 객체 구조의 결정
   3.2 다양한 수준의 언어
4. 단일 책임 원칙
   4.1 "And", "Or", "But" 없이
5. 객체 피어 고정관념
   5.1 세 가지 피어 관계
   5.2 생성자를 통한 의존성 전달
6. 부분의 합보다 단순한 복합
   6.1 복합 객체의 단순성
7. 컨텍스트 독립성
   7.1 컨텍스트 독립적 객체
   7.2 올바른 정보 은닉

---

### 1. 유지보수 가능한 설계

**화제 배경**: 코드가 확장되면서 이를 이해하고 유지보수하기 위해서는 기능을 객체로, 객체를 패키지로, 패키지를 프로그램으로, 프로그램을 시스템으로 구조화해야 합니다. (Lines 24-28)

#### 1.1 관심사의 분리와 높은 추상화 수준 [핵심 개념: Separation of Concerns, Higher Levels of Abstraction]

**두 가지 주요 휴리스틱** (Lines 29-51)

```
1. 관심사의 분리 (Separation of Concerns) (Lines 37-45):

목표:
- 시스템 행동 변경 시 가능한 적은 코드 변경
- 관련 변경이 한 영역의 코드에 있으면 시스템 전체를 찾아다닐 필요 없음

방법:
- 같은 이유로 변경될 코드를 함께 모음
- 어떤 부분을 언제 변경할지 예측할 수 없으므로

예시:
- 인터넷 표준 프로토콜에서 메시지를 언팩하는 코드
- ≠ 메시지를 해석하는 비즈니스 코드
- → 두 개념을 다른 패키지로 분할

2. 높은 수준의 추상화 (Higher Levels of Abstraction) (Lines 46-51):

목표:
- 복잡성을 다루는 유일한 방법: 회피 (더 높은 추상화 수준에서 작업)

방법:
- 변수와 제어 흐름 조작보다 유용한 기능의 컴포넌트 조합으로 프로그래밍

비유:
- 레시피를 상세히 설명하지 않고 요리 이름으로 메뉴에서 음식 주문
```

#### 1.2 포트와 어댑터 아키텍처 [핵심 개념: Ports and Adapters Architecture]

**이전 화제와의 관계**: 두 가지 휴리스틱을 일관되게 적용하면 자연스럽게 나타나는 아키텍처 패턴을 설명합니다.

**포트와 어댑터 아키텍처** (Lines 52-60)
```
출처:
Cockburn의 "ports and adapters" 아키텍처 [Cockburn08]
Eric Evans의 "anticorruption layer" [Evans03]와 관련

구조:
비즈니스 도메인 코드를 기술 인프라 의존성으로부터 격리
- 데이터베이스
- 사용자 인터페이스
- 등

목표:
기술 개념이 애플리케이션 모델로 누출되지 않도록

방법:
1. 포트(Ports): 애플리케이션 모델의 용어로 외부 세계와의 관계를 설명하는 인터페이스 작성
2. 어댑터(Adapters): 애플리케이션 코어와 각 기술 도메인 간의 브릿지 작성
```

**브릿지(어댑터)의 구현** (Lines 61-67)
```
역할:
- 애플리케이션 모델이 정의한 인터페이스 구현
- 애플리케이션 수준 객체와 기술 수준 객체 간 매핑

예시: 주문장부 객체를 데이터베이스에 영속화 (Lines 63-66)
- 주문장부 객체를 SQL 문으로 매핑
- 방법:
  1. 애플리케이션 객체에서 값 쿼리
  2. Hibernate 같은 객체-관계형 도구 사용
     - Java 리플렉션을 사용하여 객체에서 값 추출

Figure 6.1 참조: 애플리케이션의 코어 도메인 모델이 기술 인프라에 매핑

Chapter 17 참조: 이 아키텍처로 리팩터링하는 예시
```

**인터페이스 찾기** (Lines 68-70)
- 행동의 어느 측면에 인터페이스가 있어야 하는지 찾기
- 코드를 깔끔하게 나눌 수 있도록
- 2차 수준의 휴리스틱 사용

---

### 2. 캡슐화와 정보 은닉

**이전 화제와의 관계**: 포트와 어댑터 아키텍처의 기초가 되는 캡슐화와 정보 은닉의 개념을 명확히 합니다.

#### 2.1 캡슐화 vs 정보 은닉의 구분 [핵심 개념: Encapsulation vs Information Hiding]

**두 개념의 구분** (Lines 81-92)
```
주의사항:
"encapsulation"과 "information hiding"은 종종 상호 교환적으로 사용되지만
실제로는 두 개의 별개이고 대체로 직교하는 품질을 의미

캡슐화 (Encapsulation):
정의:
- 객체의 행동이 API를 통해서만 영향받도록 보장

목적:
- 한 객체의 변경이 시스템의 다른 부분에 미치는 영향 제어
- 관련 없는 컴포넌트 간에 예상치 못한 의존성이 없도록 보장

정보 은닉 (Information Hiding):
정의:
- API의 추상화 뒤에 객체가 기능을 구현하는 방법을 숨김

목적:
- 현재 작업과 관련 없는 저수준 세부사항을 무시하여 더 높은 추상화로 작업
```

**캡슐화의 중요성** (Lines 93-97)
```
캡슐화가 없을 때 가장 인식됨:

나쁘게 캡슐화된 코드 작업 시:
- 변경의 잠재적 효과 추적에 너무 많은 시간 소비
- 객체가 생성되는 위치 확인
- 공통 데이터 보유 확인
- 내용이 참조되는 위치 확인

참조:
- [Feathers04]
- [Demeyer03]
```

#### 2.2 앨리어싱 문제와 캡슐화 유지 [핵심 개념: Encapsulation vs Information Hiding]

**이전 화제와의 관계**: 캡슐화의 개념을 이해한 후, 실제로 캡슐화를 깨뜨릴 수 있는 문제를 설명합니다.

**언어 지원과 한계** (Lines 102-108)
```
캡슐화를 위한 언어 지원:
많은 객체지향 언어가 가시성 제어 제공
→ 하지만 충분하지 않음

앨리어싱 (Aliasing) 문제:
정의:
- 객체가 가변 객체에 대한 참조를 공유하여 캡슐화 깨뜨림

필요성 vs 위험성:
- 전통적인 객체지향 시스템에 필수적 (그렇지 않으면 두 객체가 통신 불가)
- 우발적 앨리어싱은 시스템의 관련 없는 부분을 결합시킬 수 있음
  → 시스템이 신비롭게 행동하고 변경에 비유연
```

**캡슐화 유지 방법** (Lines 109-112)
```
표준 관행:
1. 불변 값 타입 정의
2. 전역 변수와 싱글톤 회피
3. 객체 간 전달 시 컬렉션과 가변 값 복사
4. 기타

참조:
이 장 후반부에 정보 은닉에 대한 추가 내용
```

---

### 3. 내부 vs 피어

**이전 화제와의 관계**: 캡슐화와 정보 은닉을 이해한 후, 객체를 조직화할 때 내부와 외부를 어떻게 구분할지 설명합니다.

#### 3.1 객체 구조의 결정 [핵심 개념: Internals vs Peers]

**내부와 외부 결정** (Lines 114-119)
```
결정해야 할 것:
각 객체의 내부와 외부를 무엇으로 할 것인가
→ 명확한 API를 가진 일관된 추상화 제공

객체의 핵심 (위에서 논의):
- API를 통해 내부에 대한 접근 캡슐화
- 시스템의 나머지 부분으로부터 세부사항 은닉

피어 (Peers):
- 다른 객체와 메시지 송수신으로 통신
- 직접 통신하는 객체들

Figure 6.2: 객체는 메시지 송수신으로 통신
```

**결정의 중요성** (Lines 122-127)
```
중요한 이유:
객체 사용 용이성에 영향 → 시스템의 내부 품질에 기여

너무 많은 내부 노출 시 문제:
- 클라이언트가 객체 작업의 일부를 수행하게 됨
- 행동이 너무 많은 객체에 분산됨 (서로 결합)
- 유지보수 비용 증가
  → 변경이 코드 전체로 파급
```

**"Train Wreck" 예시** (Lines 127-139)
```java
// Page 17의 예시 (Lines 133-136)
((EditSaveCustomizer) master.getModelisable()
  .getDockablePanel()
    .getCustomizer())
      .getSaveItem().setEnabled(Boolean.FALSE.booleanValue());

문제점:
- 모든 getter가 구조적 세부사항 노출
- master에서 customization을 활성화하는 방법을 변경하려면
  → 모든 중간 관계를 변경해야 함
```

#### 3.2 다양한 수준의 언어 [핵심 개념: Internals vs Peers]

**이전 화제와의 관계**: 객체 구조를 이해한 후, 코드 가독성을 높이는 방법을 설명합니다.

**헬퍼 메서드 작성** (Lines 141-152)
```
접근 방법:
- 코드 가독성을 높이기 위해 헬퍼 메서드 작성
- 의미를 명확히 하는 매우 작은 메서드 추가도 주저하지 않음

메서드 명명:
- 호출 코드를 가능한 자연스럽게 읽히도록 명명
- 외부 규칙에 맞출 필요 없음 (다른 코드를 지원하기 위한 것이므로)

Part III 참조

예시 (Chapter 15, Line 147):
allowing(sniperListener).sniperStateChanged(with(aSniperThatIs(BIDDING)));

설명:
- aSniperThatIs(): 로컬 메서드
  - with() 메서드에 전달될 값 구성
  - 이름이 이 컨텍스트에서 의도를 설명하도록 의도됨
- 효과: 테스트의 일부를 정의하는 매우 작은 내장 언어 구성
```

**프로그래밍 스타일의 차이** (Lines 153-162)
```
값 타입 vs 객체 타입 (page 13 참조)

다양한 수준에서 다른 프로그래밍 스타일:

객체 간 (Between objects):
- 방금 설명한 메시지 전달 스타일 사용

객체 내부 (Within an object):
- 더 함수적 스타일 경향
- 부작용이 없는 메서드와 값으로 행동 구축

부작용 없는 기능의 장점:
1. 더 작은 컴포넌트로 코드 조립 가능
2. 위험한 공유 상태의 양 최소화

결과:
- 클래스 구현 내에서 약간의 불변성 → 훨씬 안전한 코드
- 잘 작업하면 코드도 잘 읽힘

참조:
대규모 함수형 프로그램 작성은 다른 책의 주제
```

---

### 4. 단일 책임 원칙

**이전 화제와의 관계**: 객체의 적절한 기능을 선택하는 방법을 설명합니다.

#### 4.1 "And", "Or", "But" 없이 [핵심 개념: Single Responsibility Principle]

**단일 책임 원칙** (Lines 165-168)
```
원칙:
모든 객체는 단일하고 명확하게 정의된 책임을 가져야 함
[Martin02] "single responsibility" 원칙

도움:
시스템에 행동 추가 시 다음 결정
1. 기존 객체 확장
2. 객체가 호출할 새 서비스 생성
```

**휴리스틱: "And", "Or" 없이** (Lines 173-176)
```
방법:
접속사("and", "or") 사용 없이 객체가 하는 일을 설명할 수 있어야 함

문제 신호:
설명에 절(clauses)을 추가하는 경우

해결책:
객체를 협력하는 객체들로 분리
→ 일반적으로 각 절마다 하나
```

**객체 조합에의 적용** (Lines 177-181)
```
적용 범위:
여러 객체를 새로운 추상화로 조합할 때도 적용

요구사항:
단일 구조로 패키징된 행동의 책임을 명확히 설명 가능해야 함

관련 아이디어:
- "Composite Simpler Than the Sum of Its Parts" 섹션
- "Context Independence" 섹션
```

---

### 5. 객체 피어 고정관념

**이전 화제와의 관계**: 단일 책임을 가진 객체들이 어떻게 서로 통신하는지 설명합니다.

#### 5.1 세 가지 피어 관계 [핵심 개념: Object Peer Stereotypes]

**피어의 세 가지 관계 유형** (Lines 183-209)

```
전제:
- 단일 책임을 가진 객체들
- 깔끔한 API를 통해 메시지로 피어와 통신

1. 의존성 (Dependencies) (Lines 187-192):

정의:
- 객체가 책임을 수행하기 위해 피어에게 요구하는 서비스
- 이 서비스 없이는 기능 불가
- 이들 없이 객체 생성 불가능해야 함

예시:
- 그래픽 패키지는 그릴 화면이나 캔버스 필요
- 이것 없이는 의미 없음

2. 알림 (Notifications) (Lines 193-201):

정의:
- 객체의 활동을 최신 상태로 유지해야 하는 피어
- 상태 변경이나 중요한 작업 수행 시 관심 있는 피어에게 알림

특징:
- "발사하고 잊기" (fire and forget)
- 객체는 어떤 피어가 듣고 있는지 알지도 관심도 없음

유용한 이유:
- 객체들을 서로 분리 (decouple)

예시:
- UI 시스템의 버튼 컴포넌트
  - 클릭 시 등록된 리스너에게 알림 약속
  - 리스너가 무엇을 할지 모름
- 리스너
  - 호출되기를 기대
  - UI가 이벤트를 디스패치하는 방법은 모름

3. 조정 (Adjustments) (Lines 202-209):

정의:
- 시스템의 더 넓은 요구에 맞게 객체의 행동을 조정하는 피어

포함:
- 객체를 대신하여 결정하는 정책 객체 (Strategy 패턴 [Gamma94])
- 복합 객체인 경우 컴포넌트 부분

예시:
- Swing JTable과 TableCellRenderer
  - 테이블이 셀 값을 그리도록 렌더러에게 요청
  - 색상의 RGB (Red, Green, Blue) 값으로 표시
  - 렌더러 변경 시
    → 테이블의 표현 변경
    → 이제 HSB (Hue, Saturation, Brightness) 값 표시
```

**휴리스틱의 유연한 적용** (Lines 215-221)
```
주의사항:
- 고정관념은 설계를 생각하는 데 도움이 되는 휴리스틱일 뿐
- 엄격한 규칙 아님
- 객체 피어의 정확한 분류를 찾는 데 집착하지 말 것

중요한 것:
협력하는 객체들이 사용되는 컨텍스트

예시: 감사 로그 (Lines 218-221)
- 한 애플리케이션: 의존성
  (감사는 비즈니스의 법적 요구사항, 감사 추적 없이 객체 생성 불가)
- 다른 곳: 알림
  (감사는 사용자 선택, 객체는 이것 없이도 완벽히 작동)
```

**일방향 vs 양방향 관계** (Lines 222-225)
```
다른 관점:

알림:
- 일방향
- 알림 리스너는 다음을 할 수 없음:
  - 값 반환
  - 호출자를 콜백
  - 예외 던지기
- 이유: 체인의 더 아래에 다른 리스너가 있을 수 있음

의존성이나 조정:
- 위 모두 가능
- 이유: 직접적인 관계
```

#### 5.2 생성자를 통한 의존성 전달 [핵심 개념: Object Peer Stereotypes]

**이전 화제와의 관계**: 세 가지 피어 관계를 이해한 후, 이를 어떻게 구현할지 설명합니다.

**항상 유효한 객체 생성** (Lines 227-235)
```
원칙: "New or new not. There is no try." (Yoda 인용)
항상 유효한 객체 생성 보장

의존성 처리:
- 생성자를 통해 전달
- 이유:
  1. 필수적이므로 의존성 사용 가능할 때까지 인스턴스 생성 의미 없음
  2. 생성자 사용이 객체 정의에서 이 제약 강제

부분 생성의 문제:
- 객체를 부분적으로 생성한 후 속성 설정으로 마무리 → 취약
- 이유:
  1. 프로그래머가 모든 의존성 설정을 기억해야 함
  2. 새 의존성 추가를 위해 객체 변경 시
     → 기존 클라이언트 코드는 여전히 컴파일됨
     → 더 이상 유효한 인스턴스를 생성하지 않음에도
  3. 최선: NullPointerException 발생
     최악: 오해를 불러일으키는 실패
```

**알림과 조정 처리** (Lines 236-241)
```
알림과 조정:
- 편의를 위해 생성자로 전달 가능
- 또는:
  1. 안전한 기본값으로 초기화
  2. 나중에 덮어쓰기
  (참고: 의존성에는 안전한 기본값 없음)

조정:
- 일반 값으로 초기화 가능

알림:
- null 객체 [Woolf98]로 초기화 가능
- 또는 빈 컬렉션으로 초기화 가능

추가:
- 기본값 변경을 위한 메서드 추가
- 리스너 추가/제거 메서드 추가
```

---

### 6. 부분의 합보다 단순한 복합

**이전 화제와의 관계**: 객체를 조합하여 새로운 타입을 만들 때의 원칙을 설명합니다.

#### 6.1 복합 객체의 단순성 [핵심 개념: Composite Simpler Than the Sum of Its Parts]

**복합 객체의 원칙** (Lines 243-249)
```
전제:
시스템의 모든 객체(언어 내장 기본 타입 제외)는 다른 객체로 구성됨

목표:
새로운 타입이 모든 구성 요소 부분을 함께 고려한 것보다 더 단순한 행동 전시

요구사항:
1. 복합 객체의 API는 구성 요소 부분의 존재를 숨겨야 함
2. 구성 요소 부분 간의 상호작용을 숨겨야 함
3. 피어에게 더 단순한 추상화 노출

비유: 기계식 시계 (Lines 248-249)
- 출력: 2~3개의 바늘
- 입력: 하나의 풀아웃 휠
- 패키징: 수십 개의 움직이는 부품
```

**나쁜 예시: 돈 값 편집 컴포넌트** (Lines 255-267)
```
구조:
- 돈 값 편집을 위한 사용자 인터페이스 컴포넌트
- 두 개의 하위 컴포넌트:
  1. 금액
  2. 통화

나쁜 접근 - 버전 1 (Lines 259-260):
moneyEditor.getAmountField().setText(String.valueOf(money.amount());
moneyEditor.getCurrencyField().setText(money.currencyCode());

문제점:
클라이언트 코드가 하위 컴포넌트를 직접 제어할 수 있다면 유용하지 않음

나쁜 접근 - 버전 2 (Lines 264-265):
moneyEditor.setAmountField(money.amount());
moneyEditor.setCurrencyField(money.currencyCode());

개선점:
getter를 setter로 교체 ("Tell, Don't Ask" 규칙)

여전히 문제:
- 컴포넌트의 내부 구조 여전히 노출
- 클라이언트가 여전히 명시적으로 관리해야 함
```

**좋은 접근** (Lines 268-271)
```python
# 파이썬 버전
moneyEditor.setValue(money)
```
```java
// 원본 Java 코드 (Line 271)
moneyEditor.setValue(money);
```

**장점**:
- 돈 값이 표시되고 편집되는 방법에 대한 모든 것을 컴포넌트 내부에 숨김
- 클라이언트 코드 단순화

**경험 법칙** (Lines 272-275)
```
복합 객체의 API는 구성 요소의 API보다 더 복잡해서는 안 됨
(Composite Simpler Than the Sum of Its Parts)
```

**확장성** (Lines 276-278)
```
복합 객체:
더 대규모, 더 정교한 복합 객체의 컴포넌트로 사용 가능

효과:
코드가 성장함에 따라 "부분의 합보다 단순한 복합" 규칙이 추상화 수준 향상에 기여
```

---

### 7. 컨텍스트 독립성

**이전 화제와의 관계**: 복합 객체의 단순성을 이해한 후, 객체가 얼마나 많이 또는 적게 은닉해야 하는지 판단하는 방법을 설명합니다.

#### 7.1 컨텍스트 독립적 객체 [핵심 개념: Context Independence]

**두 규칙의 관계** (Lines 280-282)
```
"Composite simpler than the sum of its parts" 규칙:
→ 객체가 충분한 정보를 숨기는지 결정 도움

"Context independence" 규칙:
→ 객체가 너무 많이 숨기거나 잘못된 정보를 숨기는지 결정 도움
```

**컨텍스트 독립성의 정의와 장점** (Lines 283-285)
```
정의:
각 객체가 실행되는 시스템에 대한 내장 지식이 없음

장점:
- 시스템 변경 용이
- 행동 단위(객체)를 새로운 상황에 적용 가능
```

**컨텍스트 독립성 달성 방법** (Lines 286-298)
```
방법:
객체가 더 큰 환경에 대해 알아야 할 것은 전달되어야 함

관계 전달:
1. "영구적" (permanent): 생성 시 전달
2. "일시적" (transient): 필요한 메서드에 전달

"부모적" 접근 (Paternalistic approach):
- 각 객체는 작업 수행에 충분한 만큼만 알려줌
- 어휘와 일치하는 추상화로 감쌈

최종 도달점:
- 객체 체인이 프로세스 경계에 도달
- 시스템이 외부 세부사항을 찾는 곳:
  - 호스트 이름
  - 포트
  - 사용자 인터페이스 이벤트
```

**하나의 도메인 어휘** (Lines 299-301)
```
경고:
여러 도메인의 용어를 사용하는 클래스
→ 컨텍스트 독립성 위반 가능성

예외:
브릿징 레이어의 일부인 경우
```

**컨텍스트 독립성의 효과** (Lines 302-310)
```
객체 시스템에 대한 영향:

1. 관계의 명시화:
- 관계가 명시적이 됨
- 객체 자체와 분리하여 정의됨

2. 객체 단순화:
- 자신의 관계를 관리할 필요 없음

3. 관계 관리 단순화:
- 같은 규모의 객체들이 종종 같은 장소에서 생성되고 조합됨
- 일반적으로 매핑 레이어 팩토리 객체에서

결과:
1. 일관된 객체 → 다른 컨텍스트에 적용 가능
2. 객체 조합 방식 재구성으로 변경 가능한 시스템
```

#### 7.2 올바른 정보 은닉 [핵심 개념: Context Independence]

**이전 화제와의 관계**: 컨텍스트 독립성을 이해한 후, 잘못된 정보 은닉의 예를 통해 올바른 정보 은닉을 설명합니다.

**캡슐화 vs 정보 은닉** (Lines 312-316)
```
주의사항:
캡슐화는 거의 항상 좋은 것
하지만 때로는 정보가 잘못된 장소에 숨겨질 수 있음

문제:
- 코드 이해 어려움
- 통합 어려움
- 객체 조합으로 행동 구축 어려움

최선의 방어:
설계 논의 시 두 개념의 차이를 명확히
```

**캡슐화로 표현했을 때** (Lines 317-322)
```
예시 1:
"캐시의 데이터 구조를 CachingAuctionLoader 클래스에 캡슐화"

예시 2:
"애플리케이션 로그 파일 이름을 PricingPolicy 클래스에 캡슐화"

인상:
둘 다 합리적으로 들림
```

**정보 은닉으로 재표현했을 때** (Lines 323-328)
```
예시 1 (재표현):
"캐시에 사용되는 데이터 구조를 CachingAuctionLoader 클래스에 은닉"
→ 여전히 합리적

예시 2 (재표현):
"애플리케이션 로그 파일 이름을 PricingPolicy 클래스에 은닉"
→ 문제 드러남
```

**컨텍스트 독립성을 통한 판단** (Lines 333-337)
```
분석:
PricingPolicy 클래스에 로그 파일 세부사항을 숨기는 것은 적절하지 않음

이유:
- 서로 다른 수준의 개념
- "러시아 인형" 구조의 중첩 도메인

해결책:
로그 파일 이름이 필요하다면:
1. 패키징하여
2. 외부 구성을 이해하는 수준에서 전달
```

---

### 8. 견해가 있는 관점

**이전 화제와의 관계**: 전체 장을 마무리하며 이 장에서 설명한 객체지향 설계 원칙이 TDD와 어떻게 연결되는지 설명합니다.

**장 마무리** (Lines 339-343)
```
목적:
"좋은" 객체지향 설계에 대한 생각 설명

이유:
1. 개발 접근 방식의 기초
2. 사용자의 변화하는 요구에 쉽게 성장하고 적응할 수 있는 코드 작성 도움

다음 장 예고:
TDD 접근 방식이 이러한 원칙을 어떻게 지원하는지 보여줄 것
```

---

## 참조 정보

**책 이름**: Growing Object-Oriented Software, Guided by Tests
**장 번호**: Chapter 6
**장 제목**: Object-Oriented Style
**페이지 범위**: 72-81
