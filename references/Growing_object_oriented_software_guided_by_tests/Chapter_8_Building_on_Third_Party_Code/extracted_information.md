# Growing_object_oriented_software_guided_by_tests_Chapter 8: Building on Third-Party Code

## 압축 내용

제3자 코드를 사용할 때는 소유하지 않은 타입을 Mock하지 말고, 대신 애플리케이션 도메인 용어로 정의된 인터페이스를 구현하는 얇은 어댑터 레이어(Adapter Layer)를 작성하여 제3자 API와의 통합을 관리하고, 어댑터의 동작을 확인하기 위한 집중된 통합 테스트(Integration Tests)를 작성하며, 이벤트 기반 라이브러리의 경우 애플리케이션 객체를 Mock하여 어댑터가 도메인 간 이벤트를 올바르게 번역하는지 검증한다.

## 핵심 내용

### 핵심 개념들
1. **Don't Mock Types You Can't Change** (참조: [상세 내용 1.1])
2. **Adapter Layer** (참조: [상세 내용 2.1])
3. **Integration Tests** (참조: [상세 내용 2.1])
4. **Mock Application Objects** (참조: [상세 내용 3.1])

### 핵심 개념 설명

**1. Don't Mock Types You Can't Change** (참조: [상세 내용 1.1])
- 제3자 코드는 깊이 이해하기 어렵고 문서화가 불완전하며 버그가 있을 수 있음
- 제3자 API를 변경할 수 없으므로 설계 피드백에 대응 불가
- 제3자 타입을 Mock하면 테스트가 복잡해지고 실제 동작과 일치 보장 어려움

**2. Adapter Layer** (참조: [상세 내용 2.1])
- 애플리케이션 도메인 용어로 정의된 인터페이스를 제3자 API로 구현
- 가능한 얇게 유지하여 취약하고 테스트하기 어려운 코드 최소화
- 애플리케이션과 외부 세계 간 관계를 애플리케이션 용어로 정의

**3. Integration Tests** (참조: [상세 내용 2.1])
- 제3자 API의 동작 방식에 대한 이해를 확인하는 집중된 테스트
- 단위 테스트보다 상대적으로 적은 수
- 예외 발생이나 트랜잭션 롤백 같은 특수 상황 테스트

**4. Mock Application Objects** (참조: [상세 내용 3.1])
- 이벤트 기반 라이브러리에서 콜백 객체가 필요한 경우
- 애플리케이션에서 정의한 콜백 인터페이스만 Mock
- 어댑터가 도메인 간 이벤트를 올바르게 번역하는지 검증

### 핵심 개념 간 관계

**Don't Mock Types You Can't Change** 원칙에 따라 제3자 타입을 직접 Mock하지 않고, **Adapter Layer**를 작성하여 애플리케이션 도메인과 제3자 코드 사이의 브릿지를 만듭니다. 이 어댑터의 동작은 **Integration Tests**를 통해 검증하며, 이벤트 기반 시스템에서는 **Mock Application Objects**를 사용하여 어댑터가 이벤트를 올바르게 번역하는지 확인합니다. 이러한 접근 방식은 애플리케이션 도메인 모델을 저수준 기술 개념으로부터 보호하고, 제3자 코드 변경 시 영향을 최소화합니다.

## 상세 내용

### 목차
1. 소유한 타입만 Mock하기
   1.1 변경할 수 없는 타입을 Mock하지 말라
2. 어댑터 레이어 작성
   2.1 어댑터와 통합 테스트
3. 통합 테스트에서 애플리케이션 객체 Mock
   3.1 콜백 인터페이스 Mock

---

### 1. 소유한 타입만 Mock하기

**화제 배경**: 제3자 코드와의 통합에서 시스템 설계를 외부 API와 균형을 맞춰야 하는 상황을 설명합니다. (Lines 9-22)

#### 1.1 변경할 수 없는 타입을 Mock하지 말라 [핵심 개념: Don't Mock Types You Can't Change]

**제3자 코드에 대한 이해 부족** (Lines 25-31)
```
문제점:

1. 깊이 있는 이해 부족 (Lines 25-27):
- 소스가 있어도 모든 quirks(특이사항) 탐색할 만큼 철저히 읽을 시간 없음
- 종종 불완전하거나 부정확한 문서화

2. 버그 및 불확실성 (Lines 28-31):
- 소프트웨어에 우회해야 할 버그가 있을 수 있음
- 추상화가 어떻게 행동하기를 원하는지는 알지만
- 제3자 코드와 결합하여 테스트하기 전까지 실제로 그렇게 작동하는지 모름
```

**제3자 코드 변경의 어려움** (Lines 32-40)
```
선호하지 않는 이유 (Lines 32-34):
제3자 코드는 소스가 있어도 변경하지 않는 것을 선호

이유:
- 새 버전이 나올 때마다 private 패치 적용은 너무 번거로움

결과 (Lines 34-40):
API를 변경할 수 없으면:
→ 단위 테스트 작성에서 얻는 설계 피드백에 대응 불가

단위 테스트가 울리는 경보:
- 외부 API의 불편함에 대한 경보
- 하지만 있는 그대로 살아야 함
```

**제3자 타입 Mock의 제한된 유용성** (Lines 41-46)
```
문제:
제3자 타입의 Mock 구현을 제공하는 것
→ 호출하는 객체를 단위 테스트할 때 제한된 사용성

발견 (Lines 42-46):
외부 라이브러리를 Mock하는 테스트:
- 필요한 기능을 실행하기 위해 코드를 올바른 상태로 만들려면 복잡해야 함
- 테스트의 혼란은 설계가 올바르지 않다고 말함
- 하지만 코드를 개선하여 문제를 수정하는 대신
- 코드와 테스트 모두에서 추가 복잡성을 감수해야 함
```

**두 번째 위험: 행동 일치 보장** (Lines 47-52)
```
위험:
stub하거나 mock한 행동이 외부 라이브러리가 실제로 할 일과 일치하는지 확신해야 함

난이도 의존성:
라이브러리의 품질에 의존
- 단위 테스트가 유효하다고 확신할 만큼 잘 명세되고(구현되었는지)

한 번 맞춰도:
라이브러리를 업그레이드할 때 테스트가 유효하게 유지되도록 보장해야 함
```

---

### 2. 어댑터 레이어 작성

**이전 화제와의 관계**: 제3자 API를 Mock하지 않는다면, 이를 구동하는 코드를 어떻게 테스트할지 설명합니다.

#### 2.1 어댑터와 통합 테스트 [핵심 개념: Adapter Layer, Integration Tests]

**TDD로 설계한 인터페이스** (Lines 54-57)
```
전제:
TDD를 사용하여 객체가 필요로 하는 서비스의 인터페이스 설계

특징:
- 외부 라이브러리가 아닌 객체의 도메인 용어로 정의됨
```

**어댑터 레이어 작성** (Lines 58-64)
```
방법 (Lines 58-60):
[Gamma94]에 설명된 대로 어댑터 객체 레이어 작성
→ 제3자 API를 사용하여 이러한 인터페이스 구현

Figure 8.1 참조

목표 (Lines 59-61):
이 레이어를 가능한 얇게 유지
→ 잠재적으로 취약하고 테스트하기 어려운 코드의 양 최소화

테스트 (Lines 61-64):
- 이러한 어댑터를 집중된 통합 테스트로 테스트
- 목적: 제3자 API가 작동하는 방식에 대한 이해 확인
- 단위 테스트 수에 비해 상대적으로 적은 통합 테스트
- 메모리 내 단위 테스트만큼 빠르지 않아도 빌드를 방해하지 않아야 함
```

**이 접근의 효과** (Lines 67-77)
```
일관된 적용 결과 (Lines 67-70):
1. 애플리케이션과 외부 세계 간 관계를 정의하는 인터페이스 세트 생성
   - 애플리케이션의 용어로 정의됨
2. 저수준 기술 개념이 애플리케이션 도메인 모델로 누출되는 것을 방지

참조 (Lines 75-77):
Chapter 25: 일반적인 예시
- 애플리케이션 도메인 모델의 추상화가 영속성 API를 사용하여 구현됨
```

**예외: Mock이 도움이 되는 경우** (Lines 78-82)
```
제3자 라이브러리를 Mock하는 것이 도움이 될 수 있는 경우:

1. 트리거하기 어려운 행동 시뮬레이션 (Lines 79-80):
예: 예외 던지기

2. 호출 시퀀스 테스트 (Lines 80-82):
예: 실패 시 트랜잭션이 롤백되는지 확인

제약:
테스트 스위트에 이런 테스트가 많지 않아야 함
```

**값 타입에 대한 패턴 미적용** (Lines 83-88)
```
값 타입 (Lines 83-84):
Mock할 필요 없으므로 이 패턴 적용 안 됨

설계 결정 (Lines 84-88):
코드에서 제3자 값 타입을 얼마나 사용할지 결정해야 함

옵션:
1. 너무 근본적이어서 직접 사용
2. 제3자 서비스와 동일한 격리 원칙 따름:
   - 애플리케이션 도메인에 적합한 값 타입과
   - 외부 도메인에 적합한 값 타입 간 번역
```

---

### 3. 통합 테스트에서 애플리케이션 객체 Mock

**이전 화제와의 관계**: 어댑터 레이어를 이해한 후, 콜백이 필요한 경우의 특수한 상황을 설명합니다.

#### 3.1 콜백 인터페이스 Mock [핵심 개념: Mock Application Objects]

**어댑터의 수동성** (Lines 90-91)
```
위에서 설명한 대로:
어댑터 객체는 수동적
→ 우리 코드의 호출에 반응
```

**콜백이 필요한 경우** (Lines 91-96)
```
상황 (Lines 91-93):
때때로 어댑터 객체가 애플리케이션의 객체를 다시 호출해야 함

예시:
이벤트 기반 라이브러리
- 일반적으로 클라이언트가 콜백 객체 제공 기대
- 이벤트 발생 시 알림 받기 위함

프로세스 (Lines 93-96):
1. 애플리케이션 코드가 어댑터에 자신의 이벤트 콜백 제공
   - 애플리케이션 도메인 용어로 정의됨
2. 어댑터가 외부 라이브러리에 어댑터 콜백 전달
   - 외부 이벤트 수신
   - 애플리케이션 콜백을 위해 번역
```

**Mock 객체 사용** (Lines 97-100)
```
이러한 경우 (Lines 97-99):
제3자 코드와 통합하는 객체 테스트 시 Mock 객체 사용

제한 (Lines 98-99):
애플리케이션에서 정의한 콜백 인터페이스만 Mock

목적 (Lines 99-100):
어댑터가 도메인 간 이벤트를 올바르게 번역하는지 검증

Figure 8.2 참조: 통합 테스트에서 Mock 객체 사용
```

**다중 스레드 추가 복잡성** (Lines 101-104)
```
복잡성 추가 (Lines 101-102):
다중 스레드가 통합 테스트에 더 많은 복잡성 추가

예시 (Lines 102-104):
제3자 라이브러리가 백그라운드 스레드 시작하여 애플리케이션 코드에 이벤트 전달
→ 동기화가 어댑터 레이어 설계 노력의 중요한 측면

참조:
Chapter 26: 이에 대한 더 많은 논의
```

---

## 참조 정보

**책 이름**: Growing Object-Oriented Software, Guided by Tests
**장 번호**: Chapter 8
**장 제목**: Building on Third-Party Code
**페이지 범위**: 94-97
