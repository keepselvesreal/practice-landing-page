[
  {
    "id": 74,
    "title": "4 User-defined data types",
    "level": 1,
    "page": 113,
    "parent_id": 56,
    "children_ids": [
      75,
      80,
      84,
      89
    ],
    "start_page": 113,
    "end_page": 148,
    "page_count": 36
  },
  {
    "id": 75,
    "title": "4.1 Defining data types",
    "level": 2,
    "page": 114,
    "parent_id": 74,
    "children_ids": [
      76,
      77,
      78,
      79
    ],
    "start_page": 114,
    "end_page": 127,
    "page_count": 14
  },
  {
    "id": 76,
    "title": "4.1.1 Enumerations",
    "level": 3,
    "page": 115,
    "parent_id": 75,
    "children_ids": [],
    "start_page": 115,
    "end_page": 115,
    "page_count": 1
  },
  {
    "id": 77,
    "title": "4.1.2 Union types",
    "level": 3,
    "page": 116,
    "parent_id": 75,
    "children_ids": [],
    "start_page": 116,
    "end_page": 117,
    "page_count": 2
  },
  {
    "id": 78,
    "title": "4.1.3 Recursive types",
    "level": 3,
    "page": 118,
    "parent_id": 75,
    "children_ids": [],
    "start_page": 118,
    "end_page": 120,
    "page_count": 3
  },
  {
    "id": 79,
    "title": "4.1.4 Generic data types",
    "level": 3,
    "page": 121,
    "parent_id": 75,
    "children_ids": [],
    "start_page": 121,
    "end_page": 127,
    "page_count": 7
  },
  {
    "id": 80,
    "title": "4.2 Defining dependent data types",
    "level": 2,
    "page": 128,
    "parent_id": 74,
    "children_ids": [
      81,
      82,
      83
    ],
    "start_page": 128,
    "end_page": 135,
    "page_count": 8
  },
  {
    "id": 81,
    "title": "4.2.1 A first example: classifying vehicles by power source",
    "level": 3,
    "page": 128,
    "parent_id": 80,
    "children_ids": [],
    "start_page": 128,
    "end_page": 129,
    "page_count": 2
  },
  {
    "id": 82,
    "title": "4.2.2 Defining vectors",
    "level": 3,
    "page": 130,
    "parent_id": 80,
    "children_ids": [],
    "start_page": 130,
    "end_page": 132,
    "page_count": 3
  },
  {
    "id": 83,
    "title": "4.2.3 Indexing vectors with bounded numbers using Fin",
    "level": 3,
    "page": 133,
    "parent_id": 80,
    "children_ids": [],
    "start_page": 133,
    "end_page": 135,
    "page_count": 3
  },
  {
    "id": 84,
    "title": "4.3 Type-driven implementation of an interactive data store",
    "level": 2,
    "page": 136,
    "parent_id": 74,
    "children_ids": [
      85,
      86,
      87,
      88
    ],
    "start_page": 136,
    "end_page": 147,
    "page_count": 12
  },
  {
    "id": 85,
    "title": "4.3.1 Representing the store",
    "level": 3,
    "page": 138,
    "parent_id": 84,
    "children_ids": [],
    "start_page": 138,
    "end_page": 138,
    "page_count": 1
  },
  {
    "id": 86,
    "title": "4.3.2 Interactively maintaining state in main",
    "level": 3,
    "page": 139,
    "parent_id": 84,
    "children_ids": [],
    "start_page": 139,
    "end_page": 140,
    "page_count": 2
  },
  {
    "id": 87,
    "title": "4.3.3 Commands: parsing user input",
    "level": 3,
    "page": 141,
    "parent_id": 84,
    "children_ids": [],
    "start_page": 141,
    "end_page": 143,
    "page_count": 3
  },
  {
    "id": 88,
    "title": "4.3.4 Processing commands",
    "level": 3,
    "page": 144,
    "parent_id": 84,
    "children_ids": [],
    "start_page": 144,
    "end_page": 147,
    "page_count": 4
  },
  {
    "id": 89,
    "title": "4.4 Summary",
    "level": 2,
    "page": 148,
    "parent_id": 74,
    "children_ids": [],
    "start_page": 148,
    "end_page": 148,
    "page_count": 1
  }
]