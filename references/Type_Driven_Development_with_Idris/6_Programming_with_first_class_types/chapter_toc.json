[
  {
    "id": 105,
    "title": "6 Programming with first-class types",
    "level": 1,
    "page": 173,
    "parent_id": 56,
    "children_ids": [
      106,
      110,
      113,
      121
    ],
    "start_page": 173,
    "end_page": 207,
    "page_count": 35
  },
  {
    "id": 106,
    "title": "6.1 Type-level functions: calculating types",
    "level": 2,
    "page": 174,
    "parent_id": 105,
    "children_ids": [
      107,
      108,
      109
    ],
    "start_page": 174,
    "end_page": 180,
    "page_count": 7
  },
  {
    "id": 107,
    "title": "6.1.1 Type synonyms: giving informative names to complex types",
    "level": 3,
    "page": 175,
    "parent_id": 106,
    "children_ids": [],
    "start_page": 175,
    "end_page": 175,
    "page_count": 1
  },
  {
    "id": 108,
    "title": "6.1.2 Type-level functions with pattern matching",
    "level": 3,
    "page": 176,
    "parent_id": 106,
    "children_ids": [],
    "start_page": 176,
    "end_page": 178,
    "page_count": 3
  },
  {
    "id": 109,
    "title": "6.1.3 Using case expressions in types",
    "level": 3,
    "page": 179,
    "parent_id": 106,
    "children_ids": [],
    "start_page": 179,
    "end_page": 180,
    "page_count": 2
  },
  {
    "id": 110,
    "title": "6.2 Defining functions with variable numbers of arguments",
    "level": 2,
    "page": 181,
    "parent_id": 105,
    "children_ids": [
      111,
      112
    ],
    "start_page": 181,
    "end_page": 186,
    "page_count": 6
  },
  {
    "id": 111,
    "title": "6.2.1 An addition function",
    "level": 3,
    "page": 181,
    "parent_id": 110,
    "children_ids": [],
    "start_page": 181,
    "end_page": 182,
    "page_count": 2
  },
  {
    "id": 112,
    "title": "6.2.2 Formatted output: a type-safe printf function",
    "level": 3,
    "page": 183,
    "parent_id": 110,
    "children_ids": [],
    "start_page": 183,
    "end_page": 186,
    "page_count": 4
  },
  {
    "id": 113,
    "title": "6.3 Enhancing the interactive data store with schemas",
    "level": 2,
    "page": 187,
    "parent_id": 105,
    "children_ids": [
      114,
      115,
      116,
      117,
      118,
      119,
      120
    ],
    "start_page": 187,
    "end_page": 206,
    "page_count": 20
  },
  {
    "id": 114,
    "title": "6.3.1 Refining the DataStore type",
    "level": 3,
    "page": 188,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 188,
    "end_page": 189,
    "page_count": 2
  },
  {
    "id": 115,
    "title": "6.3.2 Using a record for the DataStore",
    "level": 3,
    "page": 190,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 190,
    "end_page": 190,
    "page_count": 1
  },
  {
    "id": 116,
    "title": "6.3.3 Correcting compilation errors using holes",
    "level": 3,
    "page": 191,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 191,
    "end_page": 195,
    "page_count": 5
  },
  {
    "id": 117,
    "title": "6.3.4 Displaying entries in the store",
    "level": 3,
    "page": 196,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 196,
    "end_page": 196,
    "page_count": 1
  },
  {
    "id": 118,
    "title": "6.3.5 Parsing entries according to the schema",
    "level": 3,
    "page": 197,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 197,
    "end_page": 200,
    "page_count": 4
  },
  {
    "id": 119,
    "title": "6.3.6 Updating the schema",
    "level": 3,
    "page": 201,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 201,
    "end_page": 202,
    "page_count": 2
  },
  {
    "id": 120,
    "title": "6.3.7 Sequencing expressions with Maybe using do notation",
    "level": 3,
    "page": 203,
    "parent_id": 113,
    "children_ids": [],
    "start_page": 203,
    "end_page": 206,
    "page_count": 4
  },
  {
    "id": 121,
    "title": "6.4 Summary",
    "level": 2,
    "page": 207,
    "parent_id": 105,
    "children_ids": [],
    "start_page": 207,
    "end_page": 207,
    "page_count": 1
  }
]