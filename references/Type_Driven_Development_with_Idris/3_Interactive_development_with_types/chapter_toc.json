[
  {
    "id": 57,
    "title": "3 Interactive development with types",
    "level": 1,
    "page": 81,
    "parent_id": 56,
    "children_ids": [
      58,
      62,
      66,
      69,
      73
    ],
    "start_page": 81,
    "end_page": 112,
    "page_count": 32
  },
  {
    "id": 58,
    "title": "3.1 Interactive editing in Atom",
    "level": 2,
    "page": 82,
    "parent_id": 57,
    "children_ids": [
      59,
      60,
      61
    ],
    "start_page": 82,
    "end_page": 89,
    "page_count": 8
  },
  {
    "id": 59,
    "title": "3.1.1 Interactive command summary",
    "level": 3,
    "page": 83,
    "parent_id": 58,
    "children_ids": [],
    "start_page": 83,
    "end_page": 83,
    "page_count": 1
  },
  {
    "id": 60,
    "title": "3.1.2 Defining functions by pattern matching",
    "level": 3,
    "page": 83,
    "parent_id": 58,
    "children_ids": [],
    "start_page": 83,
    "end_page": 86,
    "page_count": 4
  },
  {
    "id": 61,
    "title": "3.1.3 Data types and patterns",
    "level": 3,
    "page": 87,
    "parent_id": 58,
    "children_ids": [],
    "start_page": 87,
    "end_page": 89,
    "page_count": 3
  },
  {
    "id": 62,
    "title": "3.2 Adding precision to types: working with vectors",
    "level": 2,
    "page": 90,
    "parent_id": 57,
    "children_ids": [
      63,
      64,
      65
    ],
    "start_page": 90,
    "end_page": 100,
    "page_count": 11
  },
  {
    "id": 63,
    "title": "3.2.1 Refining the type of allLengths",
    "level": 3,
    "page": 91,
    "parent_id": 62,
    "children_ids": [],
    "start_page": 91,
    "end_page": 94,
    "page_count": 4
  },
  {
    "id": 64,
    "title": "3.2.2 Type-directed search: automatic refining",
    "level": 3,
    "page": 95,
    "parent_id": 62,
    "children_ids": [],
    "start_page": 95,
    "end_page": 95,
    "page_count": 1
  },
  {
    "id": 65,
    "title": "3.2.3 Type, define, refine: sorting a vector",
    "level": 3,
    "page": 96,
    "parent_id": 62,
    "children_ids": [],
    "start_page": 96,
    "end_page": 100,
    "page_count": 5
  },
  {
    "id": 66,
    "title": "3.3 Example: type-driven development of matrix functions",
    "level": 2,
    "page": 101,
    "parent_id": 57,
    "children_ids": [
      67,
      68
    ],
    "start_page": 101,
    "end_page": 107,
    "page_count": 7
  },
  {
    "id": 67,
    "title": "3.3.1 Matrix operations and their types",
    "level": 3,
    "page": 102,
    "parent_id": 66,
    "children_ids": [],
    "start_page": 102,
    "end_page": 102,
    "page_count": 1
  },
  {
    "id": 68,
    "title": "3.3.2 Transposing a matrix",
    "level": 3,
    "page": 103,
    "parent_id": 66,
    "children_ids": [],
    "start_page": 103,
    "end_page": 107,
    "page_count": 5
  },
  {
    "id": 69,
    "title": "3.4 Implicit arguments: type-level variables",
    "level": 2,
    "page": 108,
    "parent_id": 57,
    "children_ids": [
      70,
      71,
      72
    ],
    "start_page": 108,
    "end_page": 111,
    "page_count": 4
  },
  {
    "id": 70,
    "title": "3.4.1 The need for implicit arguments",
    "level": 3,
    "page": 108,
    "parent_id": 69,
    "children_ids": [],
    "start_page": 108,
    "end_page": 108,
    "page_count": 1
  },
  {
    "id": 71,
    "title": "3.4.2 Bound and unbound implicits",
    "level": 3,
    "page": 109,
    "parent_id": 69,
    "children_ids": [],
    "start_page": 109,
    "end_page": 109,
    "page_count": 1
  },
  {
    "id": 72,
    "title": "3.4.3 Using implicit arguments in functions",
    "level": 3,
    "page": 110,
    "parent_id": 69,
    "children_ids": [],
    "start_page": 110,
    "end_page": 111,
    "page_count": 2
  },
  {
    "id": 73,
    "title": "3.5 Summary",
    "level": 2,
    "page": 112,
    "parent_id": 57,
    "children_ids": [],
    "start_page": 112,
    "end_page": 112,
    "page_count": 1
  }
]