[
  {
    "id": 138,
    "title": "8 Equality: expressing relationships between data",
    "level": 1,
    "page": 234,
    "parent_id": 56,
    "children_ids": [
      139,
      146,
      152,
      156
    ],
    "start_page": 234,
    "end_page": 261,
    "page_count": 28
  },
  {
    "id": 139,
    "title": "8.1 Guaranteeing equivalence of data with equality types",
    "level": 2,
    "page": 235,
    "parent_id": 138,
    "children_ids": [
      140,
      141,
      142,
      143,
      144,
      145
    ],
    "start_page": 235,
    "end_page": 245,
    "page_count": 11
  },
  {
    "id": 140,
    "title": "8.1.1 Implementing exactLength, first attempt",
    "level": 3,
    "page": 236,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 236,
    "end_page": 236,
    "page_count": 1
  },
  {
    "id": 141,
    "title": "8.1.2 Expressing equality of Nats as a type",
    "level": 3,
    "page": 237,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 237,
    "end_page": 237,
    "page_count": 1
  },
  {
    "id": 142,
    "title": "8.1.3 Testing for equality of Nats",
    "level": 3,
    "page": 238,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 238,
    "end_page": 240,
    "page_count": 3
  },
  {
    "id": 143,
    "title": "8.1.4 Functions as proofs: manipulating equalities",
    "level": 3,
    "page": 241,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 241,
    "end_page": 241,
    "page_count": 1
  },
  {
    "id": 144,
    "title": "8.1.5 Implementing exactLength, second attempt",
    "level": 3,
    "page": 242,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 242,
    "end_page": 243,
    "page_count": 2
  },
  {
    "id": 145,
    "title": "8.1.6 Equality in general: the = type",
    "level": 3,
    "page": 244,
    "parent_id": 139,
    "children_ids": [],
    "start_page": 244,
    "end_page": 245,
    "page_count": 2
  },
  {
    "id": 146,
    "title": "8.2 Equality in practice: types and reasoning",
    "level": 2,
    "page": 246,
    "parent_id": 138,
    "children_ids": [
      147,
      148,
      149,
      150,
      151
    ],
    "start_page": 246,
    "end_page": 252,
    "page_count": 7
  },
  {
    "id": 147,
    "title": "8.2.1 Reversing a vector",
    "level": 3,
    "page": 246,
    "parent_id": 146,
    "children_ids": [],
    "start_page": 246,
    "end_page": 246,
    "page_count": 1
  },
  {
    "id": 148,
    "title": "8.2.2 Type checking and evaluation",
    "level": 3,
    "page": 247,
    "parent_id": 146,
    "children_ids": [],
    "start_page": 247,
    "end_page": 248,
    "page_count": 2
  },
  {
    "id": 149,
    "title": "8.2.3 The rewrite construct: rewriting a type using equality",
    "level": 3,
    "page": 249,
    "parent_id": 146,
    "children_ids": [],
    "start_page": 249,
    "end_page": 249,
    "page_count": 1
  },
  {
    "id": 150,
    "title": "8.2.4 Delegating proofs and rewriting to holes",
    "level": 3,
    "page": 250,
    "parent_id": 146,
    "children_ids": [],
    "start_page": 250,
    "end_page": 250,
    "page_count": 1
  },
  {
    "id": 151,
    "title": "8.2.5 Appending vectors, revisited",
    "level": 3,
    "page": 251,
    "parent_id": 146,
    "children_ids": [],
    "start_page": 251,
    "end_page": 252,
    "page_count": 2
  },
  {
    "id": 152,
    "title": "8.3 The empty type and decidability",
    "level": 2,
    "page": 253,
    "parent_id": 138,
    "children_ids": [
      153,
      154,
      155
    ],
    "start_page": 253,
    "end_page": 259,
    "page_count": 7
  },
  {
    "id": 153,
    "title": "8.3.1 Void: a type with no values",
    "level": 3,
    "page": 254,
    "parent_id": 152,
    "children_ids": [],
    "start_page": 254,
    "end_page": 254,
    "page_count": 1
  },
  {
    "id": 154,
    "title": "8.3.2 Decidability: checking properties with precision",
    "level": 3,
    "page": 255,
    "parent_id": 152,
    "children_ids": [],
    "start_page": 255,
    "end_page": 258,
    "page_count": 4
  },
  {
    "id": 155,
    "title": "8.3.3 DecEq: an interface for decidable equality",
    "level": 3,
    "page": 259,
    "parent_id": 152,
    "children_ids": [],
    "start_page": 259,
    "end_page": 259,
    "page_count": 1
  },
  {
    "id": 156,
    "title": "8.4 Summary",
    "level": 2,
    "page": 260,
    "parent_id": 138,
    "children_ids": [],
    "start_page": 260,
    "end_page": 261,
    "page_count": 2
  }
]