# 8.3.5 Other schools of TDD (pp.211-212)

---
**Page 211**

211
TDD in the real world
practice is challenging, and the academic community is still trying to find the best way
to do it.
 More recent papers explore the idea that TDD’s effects may be due not to the
“write the tests first” aspect but rather to taking baby steps toward the final goal. Fucci
et al. (2016) argue that “the claimed benefits of TDD may not be due to its distinctive
test-first dynamic, but rather due to the fact that TDD-like processes encourage fine-
grained, steady steps that improve focus and flow.”
 I suggest that you give TDD a chance. See if it fits your way of working and your
programming style. You may decide to adopt it full-time (like many of my colleagues)
or only in a few situations (like me), or you may choose never to do it (also like many
of my colleagues). It is up to you. 
8.3.5
Other schools of TDD
TDD does not tell you how to start or what tests to write. This flexibility gave rise to
various different schools of TDD. If you are familiar with TDD, you may have heard
of the London school of TDD, mockist vs. classicist TDD, and outside-in TDD. This
section summarizes their differences and points you to other material if you want to
learn more.
 In the classicist school of TDD (or the Detroit school of TDD, or inside-out TDD), devel-
opers start their TDD cycles with the different units that will compose the overall fea-
ture. More often than not, classicist TDDers begin with the entities that hold the main
business rules; they slowly work toward the outside of the feature and connect these
entities to, say, controllers, UIs, and web services. In other words, classicists go from
the inside (entities and business rules) to the outside (interface with the user).
 Classicists also avoid mocks as much as possible. For example, when implementing a
business rule that would require the interaction of two or more other classes, classicists
would focus on testing the entire behavior at once (all the classes working together)
without mocking dependencies or making sure to test the units in a fully isolated man-
ner. Classicists argue that mocks reduce the effectiveness of the test suite and make test
suites more fragile. This is the same negative argument we discussed in chapter 6.
 The London school of TDD (or outside-in TDD, or mockist TDD), on the other hand,
prefers to start from the outside (such as the UI or the controller that handles the web
service) and then slowly work toward the units that will handle the functionality. To do
so, they focus on how the different objects will collaborate. And for that to happen in
an outside-in manner, these developers use mocks to explore how the collaboration
will work. They favor testing isolated units.
 Both schools of thought use the test code to learn more about the design of the
code being developed. I like the way Test Double (2018) puts it: “In [the] Detroit
school, if an object is hard to test, then it’s hard to use; in [the] London school, if a
dependency is hard to mock, then it’s hard to use for the object that’ll be using it.”
 My style is a mixture of both schools. I start from the inside, coding entities and
business rules, and then slowly work to the outside, making the external layers call


---
**Page 212**

212
CHAPTER 8
Test-driven development
these entities. However, I favor unit testing as much as possible: I do not like the tests
of unit A breaking due to a bug in unit B. I use mocks for that, and I follow all the
practices discussed in chapter 6.
 I suggest that you learn more about both schools. Both have good points, and com-
bining them makes sense. I recommend Mancuso’s 2018 talk, which elaborates on the
differences between the schools and how the approaches can be used. 
8.3.6
TDD and proper testing
Some studies show that TDD practitioners write more test cases than non-TDD practi-
tioners. However, I do not believe that the test suites generated by TDD sessions are as
good as the strong, systematic test suites we engineered in the previous chapters after
applying different testing practices. The reasoning is simple: when doing TDD, we are
not focused on testing. TDD is a tool to help us develop, not to help us test.
 Let’s revisit figure 1.4 in chapter 1. As I mentioned earlier, TDD is part of “testing
to guide development.” In other words, you should use TDD when you want your tests
to guide you through the development process. When you are finished with your TDD
sessions and the code looks good, it is time to begin the effective and systematic test-
ing part of the process I describe: change your focus to testing, and apply specifica-
tion-based testing, structural testing, and property-based testing.
 Can you reuse the tests you created during TDD in the effective and systematic
part of the process? Sure. Doing so becomes natural.
 Combining TDD and effective testing makes even more sense when both are done
in a timely manner. You do not want to TDD something and then wait a week before
properly testing it. Can you mix short TDD cycles with short systematic and effective
testing cycles? Yes! Once you master all the techniques, you will begin to combine
them. The practices I discuss in this book are not meant to be followed linearly—they
are tools that are always at your disposal. 
Exercises
8.1
This figure illustrates the test-driven development cycle. Fill in the numbered
gaps in the figure.
8.2
Which of the following is the least important reason to do TDD?
(5)
(3)
(1)
(2)
(4)


