# 2.5 Exercises (pp.59-61)

---
**Page 59**

59
Exercises
    cart.add(new CartItem("Chocolate", 2, 2.5));
    assertThat(cart.totalPrice())   
      .isEqualTo(120 + 2.5*2);
  }
}
Again, the mechanics are the same. We just have to take more into consideration when
engineering the test cases. 
2.4.13 The role of experience and creativity
If two testers performed the specification-based testing technique I described earlier
in the same program, would they develop the same set of tests? Ideally, but possibly
not. In the substringsBetween() example, I would expect most developers to come
up with similar test cases. But it is not uncommon for developers to approach a prob-
lem from completely different yet correct angles.
 I am trying to reduce the role of experience and creativity by giving developers a
process that everybody can follow, but in practice, experience and creativity make a
difference in testing. We observed that in a small controlled experiment (Yu, Treude,
and Aniche, 2019).
 In the substringsBetween() example, experienced testers may see more compli-
cated test cases, but a novice tester may have difficulty spotting those. A more experi-
enced tester may realize that spaces in the string play no role and skip this test,
whereas a novice developer may be in doubt and write an extra “useless” test. This is
why I like the specification-based testing systematic approach I described in this
chapter: it will help you remember what to think about. But it is still up to you to do
the thinking!
Exercises
2.1
Which statement is false about applying the specification-based testing method
on the following Java method?
/**
 * Puts the supplied value into the Map,
 * mapped by the supplied key.
 * If the key is already in the map, its
 * value will be replaced by the new value.
 *
 * NOTE: Nulls are not accepted as keys;
 *  a RuntimeException is thrown when key is null.
 *
 * @param key the key used to locate the value
 * @param value the value to be stored in the HashMap
 * @return the prior mapping of the key,
 *  or null if there was none.
*/
public V put(K key, V value) {
  // implementation here
}
… as well as for 
many items in 
the cart.


---
**Page 60**

60
CHAPTER 2
Specification-based testing
A The specification does not specify any details about the value input
parameter, and thus, experience should be used to partition it (for exam-
ple, value being null or not null).
B The number of tests generated by the category/partition method can
grow quickly, as the chosen partitions for each category are later com-
bined one by one. This is not a practical problem for the put() method
because the number of categories and partitions is small.
C In an object-oriented language, in addition to using the method’s input
parameters to explore partitions, we should also consider the object’s
internal state (the class’s attributes), as it can also affect the method’s
behavior.
D With the available information, it is not possible to perform the category/
partition method, as the source code is required for the last step (adding
constraints).
2.2
Consider a find program that finds occurrences of a pattern in a file. The pro-
gram has the following syntax:
find <pattern> <file>
After reading the specification and following specification-based testing, a tes-
ter devised the following partitions:
A Pattern size: empty, single character, many characters, longer than any
line in the file
B Quoting: pattern is quoted, pattern is not quoted, pattern is improperly
quoted
C Filename: good filename, no filename with this name, omitted
D Occurrences in the file: none, exactly one, more than one
E Occurrences in a single line, assuming the line contains the pattern: one,
more than one
Now the number of combinations is too high. What actions could we take to
reduce the number of combinations?
2.3
Postal codes in some imaginary country are always composed of four numbers
and two letters: for example, 2628CD. Numbers are in the range [1000, 4000].
Letters are in the range [C, M].
Consider a program that receives two inputs—an integer (for the four num-
bers) and a string (for the two letters)—and returns true (valid postal code) or
false (invalid postal code). The boundaries for this program appear to be
straightforward:
A Anything below 1000: invalid
B
[1000, 4000]: valid
C Anything above 4000: invalid


---
**Page 61**

61
Summary
D
[A, B]: invalid
E
[C, M]: valid
F
[N, Z]: invalid
Based on what you as a tester assume about the program, what other corner or
boundary cases can you come up with? Describe these invalid cases and how
they may exercise the program based on your assumptions.
2.4
A program called FizzBuzz does the following: given an integer n, return the
string formed from the number followed by “!”. If the number is divisible by 3,
use “Fizz” instead of the number; and if the number is divisible by 5, use “Buzz”
instead of the number, and if the number is divisible by both 3 and 5, use “Fizz-
Buzz” instead of the number.
Examples:
A The integer 3 yields “Fizz!”
B The integer 4 yields “4!”
C The integer 5 yields “Buzz!”
D The integer 15 yields “FizzBuzz!”
A novice tester is trying to devise as many tests as possible for the FizzBuzz
method and comes up with the following:
A T1 = 15
B T2 = 30
C T3 = 8
D T4 = 6
E T5 = 25
Which of these tests can be removed while maintaining a good test suite? Which
concept can we use to determine the test(s) that can be removed?
2.5
A game has the following condition: numberOfPoints <= 570. Perform bound-
ary analysis on the condition. What are the on and off points?
A On point = 570, off point = 571
B On point = 571, off point = 570
C On point = 570, off point = 569
D On point = 569, off point = 570
2.6
Perform boundary analysis on the following equality: x == 10. What are the on
and off points?
Summary
Requirements are the most important artifact we can use to generate tests.
Specification-based testing techniques help us explore the requirements in a
systematic way. For example, they help us examine the domain space of the dif-
ferent input variables and how they interact with each other.


