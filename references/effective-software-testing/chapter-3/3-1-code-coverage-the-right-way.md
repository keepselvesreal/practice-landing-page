# 3.1 Code coverage, the right way (pp.64-68)

---
**Page 64**

64
CHAPTER 3
Structural testing and code coverage
 In this chapter, we learn how to systematically reflect on the source code, see
what is being exercised by the test suite we derived with the help of the specification,
and what remains to be tested. Using the structure of the source code to guide test-
ing is also known as structural testing. Understanding structural testing techniques
means understanding the coverage criteria. The remainder of this chapter explores
using code coverage information to gain more confidence that the program works
as expected.
3.1
Code coverage, the right way
Consider the following requirement for a small program that counts the number of
words in a string that end with either “r” or “s” (inspired by a CodingBat problem,
https://codingbat.com/prob/p199171):
Given a sentence, the program should count the number of words that end
with either “s” or “r”. A word ends when a non-letter appears. The program
returns the number of words.
A developer implements this requirement as shown in the following listing.
public class CountWords {
  public int count(String str) {
    int words = 0;
    char last = ' ';
    for (int i = 0; i < str.length(); i++) {   
      if (!isLetter(str.charAt(i)) &&   
       (last == 's' || last == 'r')) {
          words++;
      }
      last = str.charAt(i);   
    }
    if (last == 'r' || last == 's') {    
      words++;
    }
    return words;
  }
}
Now, consider a developer who does not know much about specification-based testing
techniques and writes the following two JUnit tests for the implementation.
 
 
 
Listing 3.1
Implementing the CountWords program
Loops through 
each character 
in the string
If the current character is a non-
letter and the previous character 
was “s” or “r”, we have a word!
Stores the current 
character as the 
“last” one
Counts one more 
word if the string 
ends in “r” or “s”


---
**Page 65**

65
Code coverage, the right way
@Test
void twoWordsEndingWithS() {           
  int words = new CountLetters().count("dogs cats");
  assertThat(words).isEqualTo(2);
}
@Test
void noWordsAtAll() {                           
  int words = new CountLetters().count("dog cat");
  assertThat(words).isEqualTo(0);
}
This test suite is far from complete—for example, it does not exercise words ending in
“r”. Structural testing shows its value in such situations: we can identify parts of the test
code that our test suite does not exercise, determine why this is the case, and create
new test cases.
 Identifying which parts of the code our tests exercise is straightforward today,
thanks to the many production-ready code coverage tools on the market for all pro-
gramming languages and environments. For example, figure 3.1 shows the report
generated by JaCoCo (www.jacoco.org/jacoco), a very popular code coverage tool for
Java, after running the two tests in listing 3.2.
The background color of each line indicates its coverage (the colors appear as shades
of gray in the printed book):
A green background indicates that a line is completely covered by the test suite.
In the figure, all lines with the exception of the two ifs are green.
A yellow background means the line is partially covered by the test suite. For
example, in the figure, the two if statement lines are only partially covered.
Listing 3.2
Initial (incomplete) tests for CountWords
Two words ending in “s”  
(dogs and cats): we expect 
the program to return 2.
No words ending in “s” 
or “r” in the string: the 
program returns 0.
Diamonds indicate that this is a branching instruction
and there may be many cases to cover.
The color indicates whether the line is covered.
Figure 3.1
Code coverage achieved by the two tests in the CountWords implementation. The 
two if lines are only partially covered.


---
**Page 66**

66
CHAPTER 3
Structural testing and code coverage
A red background means the line is not covered. In the figure, there are no red
lines, which means all lines are exercised by at least one test.
Lines with no background color (such as }) are lines the coverage tool does not
see. Behind the scenes, coverage tools are instrumenting the compiled byte-
code of the program. Things like closing brackets and method declaration lines
are not really counted.
JaCoCo also uses a diamond to identify a line that may branch the program, including
the for and if statements in figure 3.1, as well as while, for, do-while, ternary ifs,
lambda expressions, and so on. Hovering your mouse over the diamond shows the
details.
 As previously mentioned, the first if statement has a yellow background, indicat-
ing that although the line is covered, not all of its branches are. When I look at the
details of the report, the tool says that one out of six combinations (three conditions
in the if statement times two options, true and false) is not covered. See figure 3.2.
The current test suite does not fully exercise the last == 'r' condition. This is useful
information; thanks to structural testing, the tester can now figure out why this test
case did not emerge before.
Reasons to miss a test case
Here are some pragmatic reasons a developer may miss a test case:
The developer made a mistake. The specification was clear about the
requirement.
The specification did not mention the case, and it is unclear whether the
behavior is expected. The developer must decide whether to bring it to the
requirements engineer. Is it a mistake in the implementation?
Figure 3.2
JaCoCo shows how many branches we are missing.


---
**Page 67**

67
Code coverage, the right way
Moving on with the example, we write a test case that exercises the “words that end in
‘r’” partition as follows.
@Test
void wordsThatEndInR() {   
  int words = new CountWords().count("car bar");
  assertThat(words).isEqualTo(2);
}
With the newly added test case in the test suite, we rerun the coverage tool. Figure 3.3
shows the new JaCoCo report. Every line is now fully covered: we have covered all the
lines and conditions of the code under test. If parts of the code were still not covered,
we would repeat the process: identify uncovered parts, understand why they are not
covered, and write a test that exercises that piece of code. 
The specification did not mention the case, but the code has a reason to exist.
For example, implementation details such as performance and persistence
often force developers to write code that is not reflected in the (functional)
requirement. The developer should add a new test to the test suite, which will
exercise the implementation-specific behavior that may cause bugs.
Listing 3.3
Testing for words that end in "r"
Words that end in “r” 
should be counted.
All lines are green, which means all lines and branches
of the method are covered by at least one test case.
Figure 3.3
Code coverage of the three tests for the CountWords implementation. The test suite 
now achieves full coverage of branches and conditions.


---
**Page 68**

68
CHAPTER 3
Structural testing and code coverage
3.2
Structural testing in a nutshell
Based on what we just did, let me define a simple approach that any developer can fol-
low (see figure 3.4):
1
Perform specification-based testing, as discussed in the previous chapter.
2
Read the implementation, and understand the main coding decisions made by the
developer.
3
Run the devised test suite with a code coverage tool.
4
For each piece of code that is not covered:
a
Understand why that piece of code was not tested. Why didn’t you see this test
case during specification-based testing? Consult with the requirements engi-
neer if you need more clarity.
b
Decide whether the piece of code deserves a test. Testing or not testing that
piece of code is now a conscious decision on your part.
c
If a test is needed, implement an automated test case that covers the missing
piece.
5
Go back to the source code and look for other interesting tests you can devise based on
the code. For each identified piece of the code, perform the substeps of step 4.
The most important thing about this approach is that structural testing complements the
test suite previously devised via specification-based testing. The code coverage tool is an auto-
mated way to identify parts that are not covered.
 Just like the approach I proposed in chapter 2, this one is meant to be iterative and
not to restrain you to a single way of working. It is not uncommon to go back to the
specification and devise additional interesting test cases.
Speciﬁcation-
based testing
(c apter
h
2)
Read the
implementation
Identify the non-
covered parts
Understand why
it is not tested
Should it
be tested?
Write a test
Look for other
interesting cases
7
For all
on-cove
n
red code
Yes
1
2
3-4
4c
4b
4a
5
Figure 3.4
Applying structural testing in a nutshell. Arrows indicate the 
iterative nature of the process. The diamond represents the moment where the 
developer decides whether to write the test case.


