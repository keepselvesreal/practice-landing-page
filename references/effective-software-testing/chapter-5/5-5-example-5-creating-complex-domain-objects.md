# 5.5 Example 5: Creating complex domain objects (pp.136-137)

---
**Page 136**

136
CHAPTER 5
Property-based testing
We now only need a @Property test method that runs the different sequences of
actions generated by the addsAndRemoves method.
@Property
void sequenceOfAddsAndRemoves(
  @ForAll("addsAndRemoves") 
  ActionSequence<Basket> actions) {
    actions.run(new Basket());
}
And we are finished. As soon as we run the test, jqwik randomly invokes sequences of
adds and removes, passing random Products and quantities and ensuring that the
value of the basket is always correct.
 This was a long, complex property-based test, and you may be wondering if it is
worth the effort. For this specific Basket implementation, I would probably write thor-
ough example-based tests. But I hope this example illustrates the power of property-
based testing. Although they tend to be more complicated than traditional example-
based tests, you will get used to it, and you will soon be writing them quickly. 
5.5
Example 5: Creating complex domain objects
Building more complex objects may come in handy when testing business systems.
This can be done using jqwik’s Combinators feature, which we’ll use in the following
listing. Imagine that we have the following Book class, and we need to generate differ-
ent books for a property-based test.
public class Book {
  private final String title;
  private final String author;
  private final int qtyOfPages;
  public Book(String title, String author, int qtyOfPages) {
    this.title = title;
    this.author = author;
    this.qtyOfPages = qtyOfPages;
  }
  // getters...
}
One way to do this would be to have a property test that receives three parameters: a
String for title, a String for author, and an Integer for quantity of pages. Inside
the property test, we would instantiate the Book class. Jqwik offers a better way to do
that, as shown in the next listing.
Listing 5.20
Property-based test that generates adds and removes
Listing 5.21
A simple Book class
The property receives 
a sequence of Basket 
actions defined by the 
addsAndRemoves method.


---
**Page 137**

137
Property-based testing in the real world
public class BookTest {
  @Property
  void differentBooks(@ForAll("books") Book book) {
    // different books!
    System.out.println(book);
    // write your test here!
  }
  @Provide
  Arbitrary<Book> books() {
    Arbitrary<String> titles = Arbitraries.strings().withCharRange(
      ➥ 'a', 'z')
        .ofMinLength(10).ofMaxLength(100); 
    Arbitrary<String> authors = Arbitraries.strings().withCharRange(
      ➥ 'a', 'z')
        .ofMinLength(5).ofMaxLength(21);   
    Arbitrary<Integer> qtyOfPages = Arbitraries.integers().between(
      ➥ 0, 450); 
    return Combinators.combine(titles, authors, qtyOfPages)
        .as((title, author, pages) -> new Book(title, author, pages)); 
  }
}
The Combinators API lets us combine different generators to build a more complex
object. All we have to do is to build specific Arbitrarys for each of the attributes of the
complex class we want to build: in this case, one Arbitrary<String> for the title,
another Arbitrary<String> for the author, and one Arbitrary<Integer> for the num-
ber of pages. After that, we use the Combinators.combine() method, which receives a
series of Arbitrarys and returns an Arbitrary of the complex object. The magic hap-
pens in the as() method, which gives us the values we use to instantiate the object.
 Note how flexible jqwik is. You can build virtually any object you want. Moreover,
nothing prevents you from building even more realistic input values: for example,
instead of building random author names, we could develop something that returns
real people’s names. Try implementing such an arbitrary yourself. 
5.6
Property-based testing in the real world
Let me give you some tips on writing property-based tests.
5.6.1
Example-based testing vs. property-based testing
Property-based testing seems much fancier than example-based testing. It also explores
the input domain much better. Should we only use property-based testing from now on?
 In practice, I mix example-based testing and property-based testing. In the testing
workflow I propose, I use example-based testing when doing specification-based and
structural testing. Example-based tests are naturally simpler than property-based tests,
Listing 5.22
Using the Combinators API to generate complex objects
Instantiates
one arbitrary
for each of the
Book’s fields
Combines them
to generate an
instance of Book


