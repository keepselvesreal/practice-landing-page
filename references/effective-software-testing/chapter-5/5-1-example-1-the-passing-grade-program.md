# 5.1 Example 1: The passing grade program (pp.118-122)

---
**Page 118**

118
CHAPTER 5
Property-based testing
5.1
Example 1: The passing grade program
Consider the following requirement, inspired by a similar problem in Kaner et al.’s
book (2013):
A student passes an exam if they get a grade >= 5.0. Grades below that are a
fail. Grades fall in the range [1.0, 10.0].
A simple implementation for this program is shown in the following listing.
public class PassingGrade {
  public boolean passed(float grade) {
    if (grade < 1.0 || grade > 10.0) 
      throw new IllegalArgumentException();
    return grade >= 5.0;
  }
}
If we were to apply specification-based testing to this program, we would probably
devise partitions such as “passing grade,” “failing grade,” and “grades outside the
range.” We would then devise a single test case per partition. With property-based test-
ing, we want to formulate properties that the program should have. I see the following
properties for this requirement:

fail—For all numbers ranging from 1.0 (inclusive) to 5.0 (exclusive), the pro-
gram should return false.

pass—For all numbers ranging from 5.0 (inclusive) to 10.0 (inclusive), the pro-
gram should return true.

invalid—For all invalid grades (which we define as any number below 1.0 or
greater than 10.0), the program must throw an exception.
Can you see the difference between what we do in specification-based testing and
what we aim to do in property-based testing? Let’s write a suite test by test, starting
with the fail property. For that, we will use jqwik (https://jqwik.net), a popular prop-
erty-based testing framework for Java.
NOTE
Property-based testing frameworks are available in many different lan-
guages, although their APIs vary significantly (unlike unit testing frameworks
like JUnit, which all look similar). If you are applying this knowledge to
another language, your task is to study the framework that is available in your
programming language. The way to think and reason is the same across dif-
ferent languages.
Before I show the concrete implementation, let me break down property-based testing
step by step, using jqwik’s lingo:
Listing 5.1
Implementation of the PassingGrade program
Note the pre-condition 
check here.


---
**Page 119**

119
Example 1: The passing grade program
1
For each property we want to express, we create a method and annotate it with
@Property. These methods look like JUnit tests, but instead of containing a sin-
gle example, they contain an overall property.
2
Properties use randomly generated data. Jqwik includes several generators for
various types (including Strings, Integers, Lists, Dates, and so on.). Jqwik
allows you to define different sets of constraints and restrictions to these param-
eters: for example, to generate only positive Integers or only Strings with a
length between 5 and 10 characters. The property method receives all the
required data for that test as parameters.
3
The property method calls the method under test and asserts that the method’s
behavior is correct.
4
When the test runs, jqwik generates a large amount of random data (following
the characteristics you defined) and calls the test for it, looking for an input
that would break the property. If jqwik finds an input that makes your test fail,
the tool reports this input back to the developer. The developer then has an
example of an input that breaks their program.
The following listing shows the code for the fail property.
public class PassingGradesPBTest {
  private final PassingGrade pg = new PassingGrade();
  @Property
  void fail( 
   @ForAll 
   @FloatRange(min = 1f, max = 5f, maxIncluded = false) 
   float grade) { 
    assertThat(pg.passed(grade)).isFalse();
  }
}
We annotate the test method with @Property instead of @Test. The test method
receives a grade parameter that jqwik will set, following the rules we give it. We then
annotate the grade parameter with two properties. First, we say that this property
should hold for all (@ForAll) grades. This is jqwik’s terminology. If we left only the
@ForAll annotation, jqwik would try any possible float as input. However, for this fail
property, we want numbers varying from 1.0 to 5.0, which we specify using the @Float-
Range annotation. The test then asserts that the program returns false for all the pro-
vided grades.
Listing 5.2
A property-based test for the fail property
Defines the characteristics of the values 
we want to generate via annotations
Any parameter to be 
generated by jqwik 
must be annotated 
with ForAll.
We want random floats 
in a [1.0, 5.0] interval 
(max value excluded), 
which we define in the 
FloatRange annotation.
The grade parameter will be
generated according to the rules
specified in the annotations.


---
**Page 120**

120
CHAPTER 5
Property-based testing
 When we run the test, jqwik randomly provides values for the grade parameter, fol-
lowing the ranges we specified. With its default configuration, jqwik randomly gener-
ates 1,000 different inputs for this method. If this is your first time with property-based
testing, I suggest that you write some print statements in the body of the test method
to see the values generated by the framework. Note how random they are and how
much they vary.
 Correspondingly, we can test the pass property using a similar strategy, as shown next.
@Property
void pass(
  @ForAll
  @FloatRange(min = 5f, max = 10f, maxIncluded = true) 
  float grade) {
  assertThat(pg.passed(grade)).isTrue();
}
Finally, to make jqwik generate numbers that are outside of the valid range of grades,
we need to use a smarter generator (as FloatRange does not allow us to express things
like “grade < 1.0 or grade > 10.0”). See the invalidGrades() provider method in the
following listing: methods annotated with @Provide are used to express more com-
plex inputs that need to be generated.
@Property
void invalid(
 @ForAll("invalidGrades") 
 float grade) {
  assertThatThrownBy(() -> {
    pg.passed(grade);
  }).isInstanceOf(IllegalArgumentException.class); 
}
@Provide 
private Arbitrary<Float> invalidGrades() {
  return Arbitraries.oneOf( 
      Arbitraries.floats().lessThan(1f), 
      Arbitraries.floats().greaterThan(10f) 
  );
}
The @Property test method is straightforward: for all grades generated, we assert that
an exception is thrown. The challenge is generating random grades. We express this
in the invalidGrades provider method, which should return either a grade smaller
than 1 or a grade greater than 10. Also, note that the method returns an Arbitrary.
Listing 5.3
A property-based test for the pass property
Listing 5.4
A property-based test for the invalidGrades property
We want random 
floats in the range 
of [5.0, 10.0], max 
value included.
The @ForAll annotation receives 
the name of a Provider method 
that will generate the data.
Asserts that an 
exception is thrown 
for any value outside 
the boundary
A provider method needs to be 
annotated with @Provide.
Makes the method 
randomly return …
… a float that is 
less than 1.0 …
… or greater than 10.0.


---
**Page 121**

121
Example 1: The passing grade program
An Arbitrary is how jqwik handles arbitrary values that need to be generated. If you
need, say, arbitrary floats, your provider method should return an Arbitrary<Float>.
 To give the two options to jqwik, we use the Arbitraries.oneOf() method. The
Arbitraries class contains dozens of methods that help build arbitrary data. The
oneOf() method receives a list of arbitrary values it may return. Behind the scenes,
this method ensures that the distribution of data points generated is fairly distributed:
for example, it generates as many “smaller than 1” inputs as “greater than 10” inputs.
Then, we use another helper, the Arbitraries.floats() method, to generate ran-
dom floats. Finally, we use the lessThan() and greaterThan() methods to generate
numbers less than 1 and greater than 10, respectively.
NOTE
I suggest exploring the methods that the Arbitraries class provides!
Jqwik is a very extensive framework and contains lots of methods to help you
build any property you need. I will not discuss every feature of the framework, as
that would be an entire book by itself. Instead, I recommend that you dive into
jqwik’s excellent user guide: https://jqwik.net/docs/current/user-guide.html.
When we run the tests, all of them pass, since our implementation is correct. Now,
let’s introduce a bug in the code to see the jqwik output. For example, let’s change
return grade >= 5.0 to return grade > 5.0, a simple off-by-one mistake. When we run
our test suite again, the pass property test fails as expected! Jqwik also produces nice
output to help us debug the problem.
|-------------------jqwik-------------------
tries = 11                    | \# of calls to property
checks = 11                   | \# of not rejected calls
generation = RANDOMIZED       | parameters are randomly generated
after-failure = PREVIOUS_SEED | use the previous seed
when-fixed-seed = ALLOW       | fixing the random seed is allowed
edge-cases\#mode = MIXIN      | edge cases are mixed in
edge-cases\#total = 2         | \# of all combined edge cases
edge-cases\#tried = 1         | \# of edge cases tried in current run
seed = 7015333710778187630    | random seed to reproduce generated values
Sample
------
  arg0: 5.0
The output shows that jqwik found a counterexample in attempt number 11. Only 11
trials were enough to find the bug! Jqwik then shows a set of configuration parameters
that may be useful when reproducing and debugging more complex cases. In particu-
lar, note the seed information: you can reuse that seed later to force jqwik to come up
with the same sequence of inputs. Below the configuration, we see the sample that
caused the bug: the value 5.0, as expected.
Listing 5.5
An example of a jqwik test failure


---
**Page 122**

122
CHAPTER 5
Property-based testing
NOTE
If you are connecting the dots with previous chapters, you may be won-
dering about boundary testing. Jqwik is smart enough to also generate
boundary values! If we ask jqwik to generate, say, floats smaller than 1.0,
jqwik will generate 1.0 as a test. If we ask jqwik to generate any integer, jqwik
will try the maximum and minimum possible integers as well as 0 and nega-
tive numbers. 
5.2
Example 2: Testing the unique method
The Apache Commons Lang offers the unique method (http://mng.bz/XWGM). Fol-
lowing is its adapted Javadoc:
Returns an array consisting of the unique values in data. The return array is
sorted in descending order. Empty arrays are allowed, but null arrays result in
a NullPointerException. Infinities are allowed.
Parameters:

data: Array to scan
The method returns a descending list of values included in the input array. It
throws a NullPointerException if data is null.
You can see its implementation next.
public static int[] unique(int[] data) {
  TreeSet<Integer> values = new TreeSet<Integer>(); 
  for (int i = 0; i < data.length; i++) {
     values.add(data[i]);
  }
  final int count = values.size();
  final int[] out = new int[count]; 
  Iterator<Integer> iterator = values.iterator();
  int i = 0;
  while (iterator.hasNext()) { 
     out[count - ++i] = iterator.next();
  }
  return out;
}
Let’s go straight to property-based testing. Here, we focus on the main property of the
method: given an array of integers, the method returns a new array containing only
the unique values of the original array, sorted in descending order. This is the prop-
erty we will embed in a jqwik test.
 Our test works as follows. First we create a random list of integers. To ensure that
the list has repeated numbers, we create a list of size 100 and limit the range of integers
Listing 5.6
Implementation of the unique method
Uses a treeset to 
filter out repeated 
elements
Creates the new array 
using the size of the tree
Visits the treeset and 
adds the elements to 
the new array


