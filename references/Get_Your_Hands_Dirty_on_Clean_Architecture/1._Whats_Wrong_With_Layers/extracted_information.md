# 1장: What's Wrong With Layers? - 추출된 정보

## 압축 내용
계층형 아키텍처는 견고한 패턴이지만 데이터베이스 중심 설계, 지름길 허용, 테스트 복잡도 증가, 유스케이스 은폐, 병렬 작업 제약이라는 다섯 가지 구조적 함정으로 인해 시간이 지남에 따라 유지보수성이 저하되는 경향이 있다.

## 핵심 내용

### 핵심 개념
- **데이터베이스 중심 설계(Database-Driven Design)**: 계층형 아키텍처에서 persistence 계층이 기반이 되어 비즈니스 로직보다 데이터베이스 구조를 먼저 설계하게 만드는 구조적 문제
- **계층 간 지름길(Shortcuts Between Layers)**: 상위 계층의 컴포넌트를 하위 계층으로 밀어내려 접근할 수 있게 만드는 편법
- **테스트 복잡도(Test Complexity)**: 계층을 건너뛰거나 의존성이 증가하면서 테스트 설정이 복잡해지고 mock 대상이 늘어나는 현상
- **유스케이스 은폐(Hidden Use Cases)**: 도메인 로직이 여러 계층에 흩어지고 broad service가 생성되어 특정 유스케이스를 찾기 어려워지는 문제
- **병렬 작업 제약(Parallel Work Difficulty)**: persistence → domain → web 순서의 의존성 때문에 여러 개발자가 동시에 작업하기 어려운 구조적 한계

### 핵심 개념 설명

**데이터베이스 중심 설계**는 계층형 아키텍처의 구조적 특성상 persistence 계층을 기반으로 모든 것이 구축되면서, 개발자가 비즈니스 행위(behavior)보다 상태(state)를 먼저 모델링하게 만든다. ORM 프레임워크와 결합되면 도메인 엔티티와 persistence 엔티티가 혼재되어 eager/lazy loading, transaction, cache flushing 같은 persistence 관심사가 도메인 로직에 침투한다. (페이지 10-12, 줄 30-69)

**계층 간 지름길**은 계층형 아키텍처가 "상위 계층은 하위 계층만 접근 가능"이라는 단일 규칙만 강제하기 때문에, 필요한 컴포넌트를 하위 계층으로 밀어내리는 편법을 허용한다. 한 번 허용되면 반복되며, Broken Windows Theory에 따라 심리적 장벽이 낮아져 persistence 계층에 helper/utility 컴포넌트가 과도하게 축적된다. (페이지 12-13, 줄 70-96)

**테스트 복잡도**는 web 계층에서 persistence 계층을 직접 호출하거나 도메인 로직을 web 계층에 구현하면서 발생한다. 단일 필드 조작 같은 "간단한" 작업에서 시작되지만, 테스트에서 domain과 persistence 계층을 모두 mock해야 하고 의존성이 증가하면서 테스트 작성보다 mock 설정에 더 많은 시간이 소요된다. (페이지 13-14, 줄 97-116)

**유스케이스 은폐**는 도메인 로직이 web(계층 건너뛰기), persistence(컴포넌트 밀어내리기) 계층에 흩어지고, 계층형 아키텍처가 service의 "너비"를 제한하지 않아 하나의 broad service가 여러 유스케이스를 담당하게 되면서 발생한다. 기능 추가나 변경 시 적절한 위치를 찾기 어렵고, UserService 대신 RegisterUserService 같은 narrow service가 있으면 탐색이 훨씬 쉬워진다. (페이지 14-15, 줄 117-142)

**병렬 작업 제약**은 계층형 아키텍처의 하향식 의존성(persistence → domain → web) 때문에 persistence 계층부터 순차적으로 개발해야 하며, 3명의 개발자가 있어도 한 번에 한 명만 작업할 수 있다. 인터페이스 우선 정의로 병렬 작업이 가능하지만 Database-Driven Design에서는 persistence와 domain 로직이 혼재되어 분리 작업이 불가능하다. (페이지 15-16, 줄 143-178)

### 핵심 개념 간 관계

데이터베이스 중심 설계는 persistence 계층을 기반으로 만들면서 **병렬 작업 제약**의 근본 원인이 되고, ORM 엔티티와 도메인 모델의 혼재는 **테스트 복잡도**를 증가시킨다. **계층 간 지름길**은 persistence 계층에 helper를 축적시켜 의존성을 증가시키고 **테스트 복잡도**를 악화시킨다. 계층 건너뛰기는 도메인 로직을 여러 계층에 분산시켜 **유스케이스 은폐**를 유발하며, broad service는 병합 충돌을 일으켜 **병렬 작업 제약**을 심화시킨다. 이 다섯 가지 문제는 상호 연결되어 시간이 지남에 따라 유지보수성을 점진적으로 저하시킨다.

## 상세 핵심 내용

### 중요 개념

- **데이터베이스 중심 설계(Database-Driven Design)**
- **계층 간 지름길(Shortcuts Between Layers)**
- **테스트 복잡도(Test Complexity)**
- **유스케이스 은폐(Hidden Use Cases)**
- **병렬 작업 제약(Parallel Work Difficulty)**
- **ORM과 도메인 로직 혼재(ORM-Domain Logic Coupling)**
- **Broken Windows Theory**
- **Broad vs. Narrow Services**
- **계층 건너뛰기(Layer Skipping)**

### 중요 개념 설명

**데이터베이스 중심 설계**는 전통적 계층형 아키텍처에서 persistence 계층이 최하위 기반이 되어 모든 상위 계층이 이에 의존하는 구조다. 비즈니스는 본질적으로 행위(behavior)를 모델링하는 것이지만, 이 구조는 개발자가 데이터베이스 구조를 먼저 설계하고 그 위에 도메인 로직을 구현하도록 유도한다. 비즈니스 관점에서는 도메인 로직을 먼저 구축하여 이해도를 검증한 후 persistence와 web 계층을 추가해야 하지만, 의존성의 자연스러운 흐름이 이를 방해한다. (페이지 10-11, 줄 30-49)

**ORM과 도메인 로직 혼재**는 JPA/Hibernate 같은 ORM 프레임워크를 계층형 아키텍처와 결합할 때 발생한다. Persistence 계층의 ORM 엔티티를 domain 계층이 직접 사용할 수 있기 때문에, service가 persistence model을 business model로 사용하게 된다. 그 결과 도메인 서비스가 eager/lazy loading, transaction, cache flushing 같은 persistence housekeeping 작업까지 처리해야 하며, persistence 코드와 domain 코드가 사실상 융합(fused)되어 한쪽을 변경하기 어렵다. (페이지 11-12, 줄 50-69)

**계층 간 지름길**은 계층형 아키텍처의 유일한 전역 규칙이 "동일 계층 또는 하위 계층만 접근"이라는 점에서 비롯된다. 상위 계층의 컴포넌트가 필요하면 그것을 하위 계층으로 밀어내려 접근할 수 있다. 한 번 허용되면 두 번째, 세 번째도 허용되며, 마감일 압박과 결합되면 threshold가 급격히 낮아진다. (페이지 12-13, 줄 70-83)

**Broken Windows Theory**는 하나의 깨진 창문이 방치되면 더 많은 파손이 발생하는 심리적 효과로, 소프트웨어에서는 한 번 취해진 지름길이 다른 개발자들의 심리적 장벽을 낮춰 반복을 유발한다. 이로 인해 persistence 계층(또는 최하위 계층)이 helper, utility 컴포넌트로 비대해진다. (페이지 12-13, 줄 77-83, 88-96)

**계층 건너뛰기**는 web 계층에서 domain 계층을 우회하고 persistence 계층을 직접 호출하는 패턴이다. 단일 필드 조작 같은 "간단한" 작업에서 시작되지만 두 가지 문제를 야기한다: (1) web 계층에 도메인 로직을 구현하여 책임을 혼재시키고 핵심 비즈니스 로직을 애플리케이션 전체에 분산시킨다, (2) 테스트에서 domain과 persistence 계층을 모두 mock해야 하며 web 컴포넌트가 여러 persistence 컴포넌트에 의존하면서 복잡도가 가중된다. (페이지 13-14, 줄 98-116)

**테스트 복잡도**는 계층 건너뛰기와 의존성 증가로 인해 발생한다. Web 컴포넌트가 시간이 지남에 따라 여러 persistence 컴포넌트에 대한 의존성을 축적하면, 의존성을 이해하고 mock하는 데 실제 테스트 코드를 작성하는 것보다 더 많은 시간이 소요된다. 복잡한 테스트 설정은 "테스트를 작성할 시간이 없다"는 핑계의 첫 단계다. (페이지 13-14, 줄 111-116)

**유스케이스 은폐**는 도메인 로직이 여러 계층에 흩어지고(web: 계층 건너뛰기, persistence: 컴포넌트 밀어내리기), broad service가 생성되면서 특정 기능의 위치를 찾기 어려워지는 문제다. 개발자는 새 코드를 작성하는 시간보다 기존 코드를 변경하는 데 더 많은 시간을 소비하므로, 아키텍처가 코드베이스 탐색을 돕지 못하면 생산성이 저하된다. (페이지 14-15, 줄 117-133)

**Broad vs. Narrow Services**: 계층형 아키텍처는 domain service의 "너비"에 제약을 두지 않아, 시간이 지나면서 하나의 service가 여러 유스케이스를 담당하는 broad service가 된다. Broad service는 persistence 계층에 대한 의존성이 많고 web 계층의 많은 컴포넌트가 이에 의존하여 테스트가 어렵고 책임 있는 service를 찾기도 어렵다. UserService에서 user registration 유스케이스를 찾는 것보다 RegisterUserService를 여는 것이 훨씬 쉽다. (페이지 14-15, 줄 134-142)

**병렬 작업 제약**은 계층형 아키텍처의 하향식 의존성 때문에 발생한다. Persistence 계층을 기반으로 모든 것이 구축되므로, persistence → domain → web 순서로 개발해야 하며 한 번에 한 명의 개발자만 작업할 수 있다. 인터페이스를 먼저 정의하여 병렬 작업이 가능하지만, Database-Driven Design에서는 persistence와 domain 로직이 혼재되어 각각을 독립적으로 작업할 수 없다. Broad service는 다른 기능 작업 시 동일 service를 동시 편집하게 만들어 병합 충돌과 잠재적 regression을 유발한다. (페이지 15-16, 줄 143-178)

### 중요 개념 간 관계

데이터베이스 중심 설계는 persistence 계층을 최하위 기반으로 만들어 **병렬 작업 제약**의 근본 원인이 되며, **ORM과 도메인 로직 혼재**를 통해 persistence와 domain을 분리할 수 없게 만들어 병렬 작업을 더욱 어렵게 한다. ORM 혼재는 domain service가 persistence housekeeping 작업을 처리하게 만들어 **테스트 복잡도**를 증가시킨다.

**계층 간 지름길**은 **Broken Windows Theory**에 의해 반복되며, persistence 계층에 helper/utility를 축적시켜 의존성을 증가시키고 **테스트 복잡도**를 악화시킨다.

**계층 건너뛰기**는 도메인 로직을 web과 persistence 계층에 분산시켜 **유스케이스 은폐**를 유발하고, domain과 persistence 계층을 모두 mock해야 하므로 **테스트 복잡도**를 직접적으로 증가시킨다.

**Broad service**는 여러 유스케이스를 담당하여 **유스케이스 은폐**를 심화시키고, 많은 persistence 의존성으로 **테스트 복잡도**를 증가시키며, 동시 편집으로 병합 충돌을 일으켜 **병렬 작업 제약**을 악화시킨다.

이 문제들은 서로 강화하며, 엄격한 자율 규율(strict self-discipline) 없이는 시간이 지남에 따라 유지보수성이 점진적으로 저하된다. 마감일 압박은 이 자율 규율을 약화시키는 주요 요인이다.

## 상세 내용

### 1. 서론: 계층형 아키텍처의 보편성과 질문 제기

계층형 아키텍처(layered architecture)는 컴퓨터 과학 수업, 튜토리얼, 모범 사례에서 오랫동안 가르쳐져 왔으며, 많은 개발자가 과거나 현재 프로젝트에서 이를 사용하고 있다. 전통적인 3계층 구조는 web 계층(요청 수신 및 라우팅), domain/business 계층(비즈니스 로직 처리), persistence 계층(도메인 엔티티의 상태 조회/수정)으로 구성된다. (페이지 10, 줄 3-12)

계층형 아키텍처가 올바르게 구현되면 견고한(solid) 패턴이다. 도메인 로직을 web과 persistence 계층으로부터 독립적으로 만들 수 있으며, web이나 persistence 기술을 도메인 로직에 영향 없이 교체할 수 있고, 기존 기능에 영향 없이 새 기능을 추가할 수 있다. Uncle Bob의 말처럼, 좋은 계층형 아키텍처는 옵션을 열어두고(keeping options open) 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 한다. (페이지 10, 줄 13-19)

하지만 저자의 경험상 계층형 아키텍처는 너무 많은 개방된 측면(open flanks)을 가지고 있어 나쁜 습관이 스며들고 시간이 지남에 따라 소프트웨어를 점점 더 변경하기 어렵게 만든다. (페이지 10, 줄 20-23)

**참조**: 페이지 10, 줄 3-23

### 2. 데이터베이스 중심 설계 (Database-Driven Design)

이전 화제와의 관계: 계층형 아키텍처의 첫 번째 문제점으로, persistence 계층이 기반이 되는 구조적 특성에서 비롯된다.

#### 2.1 Persistence 계층의 기반 위치

계층형 아키텍처의 정의상, 기반(foundation)은 데이터베이스다. Web 계층은 domain 계층에 의존하고, domain 계층은 persistence 계층에 의존하며, 따라서 데이터베이스에 의존한다. 모든 것이 persistence 계층 위에 구축된다. (페이지 11, 줄 30-34)

**참조**: 페이지 11, 줄 30-34

#### 2.2 행위 vs. 상태 모델링

애플리케이션 구축의 목표는 비즈니스를 지배하는 규칙이나 "정책(policies)"의 모델을 만들어 사용자가 쉽게 상호작용하도록 하는 것이다. 우리는 주로 행위(behavior)를 모델링하려는 것이지 상태(state)가 아니다. 상태는 중요한 부분이지만, 행위가 상태를 변경하고 따라서 비즈니스를 구동한다. 그런데 왜 도메인 로직이 아니라 데이터베이스를 아키텍처의 기반으로 만드는가? (페이지 11, 줄 35-40)

**참조**: 페이지 11, 줄 35-40

#### 2.3 개발 순서의 문제

지난 유스케이스 구현을 돌이켜보면, 도메인 로직보다 persistence 계층을 먼저 구현했을 가능성이 크다. 데이터베이스 구조를 먼저 생각하고 그 위에 도메인 로직을 구현했을 것이다. 이는 의존성의 자연스러운 흐름에 따른 것이므로 전통적 계층형 아키텍처에서는 합리적이다. 하지만 비즈니스 관점에서는 전혀 말이 되지 않는다! (페이지 11, 줄 41-46)

도메인 로직을 무엇보다 먼저 구축해야 한다. 그래야만 올바르게 이해했는지 알 수 있다. 올바른 도메인 로직을 구축하고 있다는 것을 알게 된 후에야 그 주변에 persistence와 web 계층을 구축해야 한다. (페이지 11, 줄 47-49)

**참조**: 페이지 11, 줄 41-49

#### 2.4 ORM과의 결합

데이터베이스 중심 아키텍처의 구동력(driving force)은 ORM(Object-Relational Mapping) 프레임워크의 사용이다. 저자는 JPA와 Hibernate를 일상적으로 사용하며 이런 프레임워크를 좋아한다. 하지만 ORM 프레임워크를 계층형 아키텍처와 결합하면, 비즈니스 규칙과 persistence 측면을 혼합하기 쉽다. (페이지 11-12, 줄 50-54)

**참조**: 페이지 11-12, 줄 50-54

#### 2.5 ORM 엔티티와 도메인 모델의 혼재

일반적으로 persistence 계층의 일부로 ORM 관리 엔티티가 있다(그림 2). 계층이 하위 계층에 접근할 수 있으므로, domain 계층이 이 엔티티들을 사용할 수 있다. 허용되면 사용될 것이다. (페이지 12, 줄 60-62)

```java
// Java 코드 예시 (책에 명시적으로 제시되지 않았지만 개념 설명을 위한 일반적인 패턴)
// Persistence Layer - ORM Entity
@Entity
public class User {
    @Id private Long id;
    private String name;
    // JPA annotations, lazy loading configurations
}

// Domain Layer - Service using persistence entity directly
public class UserService {
    public void updateUser(User user) {  // ORM entity as business model
        // Domain logic mixed with persistence concerns
        // Handling eager/lazy loading, transactions, cache flushing
    }
}
```

```python
# Python 버전 (SQLAlchemy 예시)
# Persistence Layer - ORM Entity
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    # SQLAlchemy configurations, lazy loading settings

# Domain Layer - Service using persistence entity directly
class UserService:
    def update_user(self, user: User):  # ORM entity as business model
        # Domain logic mixed with persistence concerns
        # Handling session management, lazy loading, transactions
        pass
```

이는 persistence 계층과 domain 계층 사이에 강한 결합(strong coupling)을 만든다. Service가 persistence model을 business model로 사용하며, 도메인 로직뿐만 아니라 eager vs. lazy loading, database transaction, cache flushing 같은 housekeeping 작업도 처리해야 한다. Persistence 코드가 사실상 domain 코드에 융합(fused)되어 한쪽을 다른 쪽 없이 변경하기 어렵다. 이는 유연성을 유지하고 옵션을 열어두어야 하는 아키텍처 목표의 정반대다. (페이지 12, 줄 63-69)

**참조**: 페이지 12, 줄 55-69

### 3. 지름길에 취약함 (Prone to Shortcuts)

이전 화제와의 관계: 데이터베이스 중심 설계가 구조적 문제라면, 지름길 허용은 규칙 강제의 약점에서 비롯된 문제다.

#### 3.1 계층형 아키텍처의 단일 규칙

전통적 계층형 아키텍처에서 유일한 전역 규칙은 특정 계층에서 동일 계층 또는 하위 계층의 컴포넌트만 접근할 수 있다는 것이다. 개발팀이 합의한 다른 규칙들이 있을 수 있고 일부는 도구로 강제될 수도 있지만, 계층형 아키텍처 스타일 자체는 그런 규칙을 우리에게 강제하지 않는다. (페이지 12-13, 줄 70-74)

**참조**: 페이지 12-13, 줄 70-74

#### 3.2 컴포넌트 밀어내리기

상위 계층의 특정 컴포넌트에 접근이 필요하면, 그 컴포넌트를 한 계층 아래로 밀어내리면(push down) 접근할 수 있다. 문제 해결! 한 번 하는 것은 괜찮을 수 있다. 하지만 한 번 하면 두 번째의 문이 열린다. 다른 누군가가 허용되었다면 나도 허용되지 않을까? (페이지 13, 줄 75-78)

개발자로서 이런 지름길을 가볍게 취하지는 않는다. 하지만 할 수 있는 옵션이 있다면 누군가는 할 것이며, 특히 마감일이 다가오는 상황에서 그렇다. 무언가가 이전에 행해졌다면, 누군가가 그것을 다시 할 threshold가 급격히 낮아진다. 이것은 "Broken Windows Theory"라는 심리적 효과다 - 11장 "의식적으로 지름길 취하기"에서 더 다룬다. (페이지 13, 줄 79-83)

**참조**: 페이지 13, 줄 75-83

#### 3.3 비대해지는 Persistence 계층

수년간의 개발과 유지보수 끝에 persistence 계층은 그림 3처럼 될 가능성이 크다. Persistence 계층(또는 더 일반적으로: 최하위 계층)은 컴포넌트를 계층을 통해 밀어내리면서 비대해진다(grow fat). Helper나 utility 컴포넌트가 특정 계층에 속하지 않는 것처럼 보이므로 완벽한 후보다. (페이지 13, 줄 88-93)

아키텍처에서 "지름길 모드"를 비활성화하려면, 계층은 최선의 선택이 아니다. 적어도 추가적인 아키텍처 규칙을 강제하지 않고서는. "강제"는 시니어 개발자가 코드 리뷰를 하는 것이 아니라 규칙이 깨지면 빌드가 실패하는 것을 의미한다. (페이지 13, 줄 94-96)

**참조**: 페이지 13, 줄 88-96

### 4. 테스트하기 어려워짐 (Grows Hard to Test)

이전 화제와의 관계: 지름길 허용이 규칙 강제의 약점이라면, 테스트 어려움은 계층 건너뛰기라는 실제 행위의 결과다.

#### 4.1 계층 건너뛰기

계층형 아키텍처 내에서 흔한 진화는 계층을 건너뛰는 것이다. 단일 엔티티 필드만 조작하므로 domain 계층을 귀찮게 할 필요가 없다며 web 계층에서 persistence 계층을 직접 접근한다. (페이지 13-14, 줄 98-100)

**참조**: 페이지 13-14, 줄 98-100

#### 4.2 계층 건너뛰기의 문제점

다시 말하지만, 처음 몇 번은 괜찮아 보이지만 자주 발생하면(그리고 누군가 첫 단계를 밟으면 발생할 것이다) 두 가지 단점이 있다. (페이지 14, 줄 106-107)

첫째, 단일 필드 조작이라도 web 계층에 도메인 로직을 구현하는 것이다. 유스케이스가 미래에 확장되면? 대부분 web 계층에 더 많은 도메인 로직을 추가하게 되어, 책임을 혼합하고 핵심 도메인 로직을 애플리케이션 전체에 분산시킨다. (페이지 14, 줄 108-110)

둘째, web 계층 테스트에서 domain 계층뿐만 아니라 persistence 계층도 mock해야 한다. 이는 단위 테스트에 복잡성을 추가한다. 복잡한 테스트 설정은 시간이 없다는 이유로 테스트를 작성하지 않는 첫 단계다. (페이지 14, 줄 111-113)

Web 컴포넌트가 시간이 지남에 따라 성장하면서 여러 persistence 컴포넌트에 대한 많은 의존성을 축적하여 테스트 복잡성을 더한다. 어느 시점에서는 의존성을 이해하고 mock하는 데 실제 테스트 코드를 작성하는 것보다 더 많은 시간이 걸린다. (페이지 14, 줄 114-116)

**참조**: 페이지 14, 줄 106-116

### 5. 유스케이스를 숨김 (Hides the Use Cases)

이전 화제와의 관계: 계층 건너뛰기가 테스트를 어렵게 만든다면, 유스케이스 은폐는 도메인 로직 분산과 broad service의 결과다.

#### 5.1 코드베이스 탐색의 중요성

개발자로서 우리는 새로운 유스케이스를 구현하는 새 코드를 만드는 것을 좋아한다. 하지만 일반적으로 새 코드를 만드는 것보다 기존 코드를 변경하는 데 훨씬 더 많은 시간을 소비한다. 이는 수십 년 된 코드베이스를 다루는 레거시 프로젝트뿐만 아니라 초기 유스케이스가 구현된 후의 새로운 greenfield 프로젝트에도 해당된다. (페이지 14, 줄 118-121)

기능을 추가하거나 변경할 적절한 장소를 자주 찾기 때문에, 아키텍처가 코드베이스를 빠르게 탐색하는 데 도움을 주어야 한다. (페이지 14-15, 줄 122-124)

**참조**: 페이지 14-15, 줄 118-124

#### 5.2 도메인 로직의 분산

위에서 이미 논의했듯이, 계층형 아키텍처에서는 도메인 로직이 계층 전반에 흩어지기 쉽다. "쉬운" 유스케이스를 위해 도메인 로직을 건너뛰면 web 계층에 존재할 수 있다. 특정 컴포넌트를 domain과 persistence 계층 모두에서 접근할 수 있도록 밀어내렸다면 persistence 계층에 존재할 수 있다. 이미 새 기능을 추가할 적절한 장소를 찾기 어렵게 만든다. (페이지 15, 줄 125-133)

**참조**: 페이지 15, 줄 125-133

#### 5.3 Broad Service의 문제

하지만 더 있다. 계층형 아키텍처는 domain service의 "너비"에 규칙을 강제하지 않는다. 시간이 지나면서 이는 종종 여러 유스케이스를 담당하는 매우 broad한 service로 이어진다(그림 5). (페이지 15, 줄 134-135)

Broad service는 persistence 계층에 대한 많은 의존성을 가지고 있으며 web 계층의 많은 컴포넌트가 이에 의존한다. 이는 service를 테스트하기 어렵게 만들 뿐만 아니라, 작업하려는 유스케이스를 담당하는 service를 찾기도 어렵게 만든다. (페이지 15, 줄 137-139)

각각 단일 유스케이스를 담당하는 고도로 특화된 narrow domain service가 있다면 얼마나 쉬울까? UserService에서 user registration 유스케이스를 검색하는 대신, RegisterUserService를 열고 작업을 시작하면 된다. (페이지 15, 줄 140-142)

**참조**: 페이지 15, 줄 134-142

### 6. 병렬 작업을 어렵게 함 (Makes Parallel Work Difficult)

이전 화제와의 관계: 유스케이스 은폐가 코드베이스 탐색을 어렵게 만든다면, 병렬 작업 제약은 계층형 아키텍처의 구조적 의존성 순서에서 비롯된 근본적인 문제다.

#### 6.1 병렬 작업의 필요성

경영진은 보통 후원하는 소프트웨어가 특정 날짜까지 완료되기를 기대한다. 실제로는 특정 예산 내에서도 완료되기를 기대하지만, 여기서 복잡하게 만들지는 말자. (페이지 15, 줄 143-145)

소프트웨어 개발 경력에서 "완료된" 소프트웨어를 본 적이 없다는 사실은 제쳐두고, 특정 날짜까지 완료되려면 보통 병렬로 작업해야 함을 의미한다. (페이지 15-16, 줄 146-148)

**참조**: 페이지 15-16, 줄 143-148

#### 6.2 The Mythical Man-Month의 교훈

아마도 책을 읽지 않았더라도 "The Mythical Man-Month"의 이 유명한 결론을 알 것이다: "늦은 소프트웨어 프로젝트에 인력을 추가하면 더 늦어진다." (페이지 16, 줄 149-152)

이는 (아직) 늦지 않은 소프트웨어 프로젝트에도 어느 정도 적용된다. 50명의 큰 그룹이 모든 맥락에서 10명의 작은 팀보다 5배 빠를 것으로 기대할 수는 없다. 매우 큰 애플리케이션에서 하위 팀으로 나뉘어 소프트웨어의 분리된 부분을 작업할 수 있다면 가능할 수 있지만, 대부분의 맥락에서는 서로의 발을 밟게 될 것이다. (페이지 16, 줄 156-161)

하지만 건강한 규모에서는 프로젝트에 더 많은 사람이 있으면 확실히 더 빠를 것으로 기대할 수 있다. 경영진이 우리에게 그것을 기대하는 것은 옳다. (페이지 16, 줄 162-163)

**참조**: 페이지 16, 줄 149-163

#### 6.3 계층형 아키텍처의 병렬 작업 제약

이 기대를 충족하려면, 아키텍처가 병렬 작업을 지원해야 한다. 이는 쉽지 않다. 계층형 아키텍처는 여기서 정말로 우리를 돕지 못한다. (페이지 16, 줄 164-165)

애플리케이션에 새 유스케이스를 추가한다고 상상해보자. 3명의 개발자가 있다. 한 명은 web 계층, 한 명은 domain 계층, 세 번째는 persistence 계층에 필요한 기능을 추가할 수 있다, 맞나? (페이지 16, 줄 166-168)

음, 계층형 아키텍처에서는 보통 그렇게 작동하지 않는다. 모든 것이 persistence 계층 위에 구축되므로, persistence 계층을 먼저 개발해야 한다. 그다음 domain 계층이 오고 마지막으로 web 계층이 온다. 따라서 한 번에 한 명의 개발자만 기능을 작업할 수 있다! (페이지 16, 줄 169-172)

**참조**: 페이지 16, 줄 164-172

#### 6.4 인터페이스 우선 정의의 한계

아, 하지만 개발자가 먼저 인터페이스를 정의할 수 있다고 말할 것이다. 그러면 각 개발자가 실제 구현을 기다리지 않고 이 인터페이스에 대해 작업할 수 있다. 물론 가능하다. 하지만 위에서 논의한 Database-Driven Design을 하지 않는 경우에만 가능하다. Persistence 로직이 domain 로직과 너무 혼재되어 있어서 각 측면을 별도로 작업할 수 없다면. (페이지 16, 줄 173-176)

코드베이스에 broad service가 있다면, 다른 기능을 병렬로 작업하는 것조차 어려울 수 있다. 다른 유스케이스를 작업하면 동일한 service가 병렬로 편집되어 병합 충돌과 잠재적 regression으로 이어진다. (페이지 16, 줄 177-178)

**참조**: 페이지 16, 줄 173-178

### 7. 결론: 유지보수 가능한 소프트웨어 구축에 어떻게 도움이 되는가?

이전 화제와의 관계: 앞선 다섯 가지 문제점을 종합하여 계층형 아키텍처의 실용적 교훈을 제시한다.

과거에 계층형 아키텍처를 구축했다면, 이 장에서 논의된 단점들 중 일부에 공감할 수 있을 것이고, 더 추가할 수도 있을 것이다. (페이지 16, 줄 179-181)

올바르게 수행되고 추가적인 규칙이 강제된다면, 계층형 아키텍처는 매우 유지보수 가능하며 코드베이스를 변경하거나 추가하는 것을 쉽게 만들 수 있다. (페이지 16, 줄 182-183)

하지만 논의는 계층형 아키텍처가 많은 것들이 잘못될 수 있도록 허용한다는 것을 보여준다. 매우 엄격한 자율 규율(strict self-discipline) 없이는 시간이 지남에 따라 퇴화하고 유지보수성이 떨어지기 쉽다. 그리고 이 자율 규율은 보통 관리자가 개발팀 주변에 새로운 마감일을 그릴 때마다 조금씩 덜 엄격해진다. (페이지 16, 줄 184-187)

계층형 아키텍처의 함정을 염두에 두면, 다음에 지름길을 취하는 것에 반대하고 더 유지보수 가능한 솔루션을 구축하는 것을 주장할 때 도움이 될 것이다 - 계층형 아키텍처든 다른 아키텍처 스타일이든. (페이지 16, 줄 188-190)

**참조**: 페이지 16, 줄 179-190
