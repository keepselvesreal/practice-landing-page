Line 1: 
Line 2: --- 페이지 91 ---
Line 3: 63
Line 4: Structural testing
Line 5: and code coverage
Line 6: In the previous chapter, we discussed using software requirements as the main
Line 7: element to guide the testing. Once specification-based testing is done, the next
Line 8: step is to augment the test suite with the help of the source code. There are several rea-
Line 9: sons to do so.
Line 10:  First, you may have forgotten a partition or two when analyzing the require-
Line 11: ments, and you may notice that while looking at the source code. Second, when
Line 12: implementing code, you take advantage of language constructs, algorithms, and
Line 13: data structures that are not explicit in the documentation. Implementation-specific
Line 14: details should also be exercised to increase the likelihood of ensuring the pro-
Line 15: gram’s full correctness.
Line 16: This chapter covers
Line 17: Creating test cases based on the code structure
Line 18: Combining structural testing and specification-
Line 19: based testing
Line 20: Using code coverage properly
Line 21: Why some developers (wrongly) dislike code 
Line 22: coverage
Line 23: 
Line 24: --- 페이지 92 ---
Line 25: 64
Line 26: CHAPTER 3
Line 27: Structural testing and code coverage
Line 28:  In this chapter, we learn how to systematically reflect on the source code, see
Line 29: what is being exercised by the test suite we derived with the help of the specification,
Line 30: and what remains to be tested. Using the structure of the source code to guide test-
Line 31: ing is also known as structural testing. Understanding structural testing techniques
Line 32: means understanding the coverage criteria. The remainder of this chapter explores
Line 33: using code coverage information to gain more confidence that the program works
Line 34: as expected.
Line 35: 3.1
Line 36: Code coverage, the right way
Line 37: Consider the following requirement for a small program that counts the number of
Line 38: words in a string that end with either “r” or “s” (inspired by a CodingBat problem,
Line 39: https://codingbat.com/prob/p199171):
Line 40: Given a sentence, the program should count the number of words that end
Line 41: with either “s” or “r”. A word ends when a non-letter appears. The program
Line 42: returns the number of words.
Line 43: A developer implements this requirement as shown in the following listing.
Line 44: public class CountWords {
Line 45:   public int count(String str) {
Line 46:     int words = 0;
Line 47:     char last = ' ';
Line 48:     for (int i = 0; i < str.length(); i++) {   
Line 49:       if (!isLetter(str.charAt(i)) &&   
Line 50:        (last == 's' || last == 'r')) {
Line 51:           words++;
Line 52:       }
Line 53:       last = str.charAt(i);   
Line 54:     }
Line 55:     if (last == 'r' || last == 's') {    
Line 56:       words++;
Line 57:     }
Line 58:     return words;
Line 59:   }
Line 60: }
Line 61: Now, consider a developer who does not know much about specification-based testing
Line 62: techniques and writes the following two JUnit tests for the implementation.
Line 63:  
Line 64:  
Line 65:  
Line 66: Listing 3.1
Line 67: Implementing the CountWords program
Line 68: Loops through 
Line 69: each character 
Line 70: in the string
Line 71: If the current character is a non-
Line 72: letter and the previous character 
Line 73: was “s” or “r”, we have a word!
Line 74: Stores the current 
Line 75: character as the 
Line 76: “last” one
Line 77: Counts one more 
Line 78: word if the string 
Line 79: ends in “r” or “s”
Line 80: 
Line 81: --- 페이지 93 ---
Line 82: 65
Line 83: Code coverage, the right way
Line 84: @Test
Line 85: void twoWordsEndingWithS() {           
Line 86:   int words = new CountLetters().count("dogs cats");
Line 87:   assertThat(words).isEqualTo(2);
Line 88: }
Line 89: @Test
Line 90: void noWordsAtAll() {                           
Line 91:   int words = new CountLetters().count("dog cat");
Line 92:   assertThat(words).isEqualTo(0);
Line 93: }
Line 94: This test suite is far from complete—for example, it does not exercise words ending in
Line 95: “r”. Structural testing shows its value in such situations: we can identify parts of the test
Line 96: code that our test suite does not exercise, determine why this is the case, and create
Line 97: new test cases.
Line 98:  Identifying which parts of the code our tests exercise is straightforward today,
Line 99: thanks to the many production-ready code coverage tools on the market for all pro-
Line 100: gramming languages and environments. For example, figure 3.1 shows the report
Line 101: generated by JaCoCo (www.jacoco.org/jacoco), a very popular code coverage tool for
Line 102: Java, after running the two tests in listing 3.2.
Line 103: The background color of each line indicates its coverage (the colors appear as shades
Line 104: of gray in the printed book):
Line 105: A green background indicates that a line is completely covered by the test suite.
Line 106: In the figure, all lines with the exception of the two ifs are green.
Line 107: A yellow background means the line is partially covered by the test suite. For
Line 108: example, in the figure, the two if statement lines are only partially covered.
Line 109: Listing 3.2
Line 110: Initial (incomplete) tests for CountWords
Line 111: Two words ending in “s”  
Line 112: (dogs and cats): we expect 
Line 113: the program to return 2.
Line 114: No words ending in “s” 
Line 115: or “r” in the string: the 
Line 116: program returns 0.
Line 117: Diamonds indicate that this is a branching instruction
Line 118: and there may be many cases to cover.
Line 119: The color indicates whether the line is covered.
Line 120: Figure 3.1
Line 121: Code coverage achieved by the two tests in the CountWords implementation. The 
Line 122: two if lines are only partially covered.
Line 123: 
Line 124: --- 페이지 94 ---
Line 125: 66
Line 126: CHAPTER 3
Line 127: Structural testing and code coverage
Line 128: A red background means the line is not covered. In the figure, there are no red
Line 129: lines, which means all lines are exercised by at least one test.
Line 130: Lines with no background color (such as }) are lines the coverage tool does not
Line 131: see. Behind the scenes, coverage tools are instrumenting the compiled byte-
Line 132: code of the program. Things like closing brackets and method declaration lines
Line 133: are not really counted.
Line 134: JaCoCo also uses a diamond to identify a line that may branch the program, including
Line 135: the for and if statements in figure 3.1, as well as while, for, do-while, ternary ifs,
Line 136: lambda expressions, and so on. Hovering your mouse over the diamond shows the
Line 137: details.
Line 138:  As previously mentioned, the first if statement has a yellow background, indicat-
Line 139: ing that although the line is covered, not all of its branches are. When I look at the
Line 140: details of the report, the tool says that one out of six combinations (three conditions
Line 141: in the if statement times two options, true and false) is not covered. See figure 3.2.
Line 142: The current test suite does not fully exercise the last == 'r' condition. This is useful
Line 143: information; thanks to structural testing, the tester can now figure out why this test
Line 144: case did not emerge before.
Line 145: Reasons to miss a test case
Line 146: Here are some pragmatic reasons a developer may miss a test case:
Line 147: The developer made a mistake. The specification was clear about the
Line 148: requirement.
Line 149: The specification did not mention the case, and it is unclear whether the
Line 150: behavior is expected. The developer must decide whether to bring it to the
Line 151: requirements engineer. Is it a mistake in the implementation?
Line 152: Figure 3.2
Line 153: JaCoCo shows how many branches we are missing.
Line 154: 
Line 155: --- 페이지 95 ---
Line 156: 67
Line 157: Code coverage, the right way
Line 158: Moving on with the example, we write a test case that exercises the “words that end in
Line 159: ‘r’” partition as follows.
Line 160: @Test
Line 161: void wordsThatEndInR() {   
Line 162:   int words = new CountWords().count("car bar");
Line 163:   assertThat(words).isEqualTo(2);
Line 164: }
Line 165: With the newly added test case in the test suite, we rerun the coverage tool. Figure 3.3
Line 166: shows the new JaCoCo report. Every line is now fully covered: we have covered all the
Line 167: lines and conditions of the code under test. If parts of the code were still not covered,
Line 168: we would repeat the process: identify uncovered parts, understand why they are not
Line 169: covered, and write a test that exercises that piece of code. 
Line 170: The specification did not mention the case, but the code has a reason to exist.
Line 171: For example, implementation details such as performance and persistence
Line 172: often force developers to write code that is not reflected in the (functional)
Line 173: requirement. The developer should add a new test to the test suite, which will
Line 174: exercise the implementation-specific behavior that may cause bugs.
Line 175: Listing 3.3
Line 176: Testing for words that end in "r"
Line 177: Words that end in “r” 
Line 178: should be counted.
Line 179: All lines are green, which means all lines and branches
Line 180: of the method are covered by at least one test case.
Line 181: Figure 3.3
Line 182: Code coverage of the three tests for the CountWords implementation. The test suite 
Line 183: now achieves full coverage of branches and conditions.
Line 184: 
Line 185: --- 페이지 96 ---
Line 186: 68
Line 187: CHAPTER 3
Line 188: Structural testing and code coverage
Line 189: 3.2
Line 190: Structural testing in a nutshell
Line 191: Based on what we just did, let me define a simple approach that any developer can fol-
Line 192: low (see figure 3.4):
Line 193: 1
Line 194: Perform specification-based testing, as discussed in the previous chapter.
Line 195: 2
Line 196: Read the implementation, and understand the main coding decisions made by the
Line 197: developer.
Line 198: 3
Line 199: Run the devised test suite with a code coverage tool.
Line 200: 4
Line 201: For each piece of code that is not covered:
Line 202: a
Line 203: Understand why that piece of code was not tested. Why didn’t you see this test
Line 204: case during specification-based testing? Consult with the requirements engi-
Line 205: neer if you need more clarity.
Line 206: b
Line 207: Decide whether the piece of code deserves a test. Testing or not testing that
Line 208: piece of code is now a conscious decision on your part.
Line 209: c
Line 210: If a test is needed, implement an automated test case that covers the missing
Line 211: piece.
Line 212: 5
Line 213: Go back to the source code and look for other interesting tests you can devise based on
Line 214: the code. For each identified piece of the code, perform the substeps of step 4.
Line 215: The most important thing about this approach is that structural testing complements the
Line 216: test suite previously devised via specification-based testing. The code coverage tool is an auto-
Line 217: mated way to identify parts that are not covered.
Line 218:  Just like the approach I proposed in chapter 2, this one is meant to be iterative and
Line 219: not to restrain you to a single way of working. It is not uncommon to go back to the
Line 220: specification and devise additional interesting test cases.
Line 221: Speciﬁcation-
Line 222: based testing
Line 223: (c apter
Line 224: h
Line 225: 2)
Line 226: Read the
Line 227: implementation
Line 228: Identify the non-
Line 229: covered parts
Line 230: Understand why
Line 231: it is not tested
Line 232: Should it
Line 233: be tested?
Line 234: Write a test
Line 235: Look for other
Line 236: interesting cases
Line 237: 7
Line 238: For all
Line 239: on-cove
Line 240: n
Line 241: red code
Line 242: Yes
Line 243: 1
Line 244: 2
Line 245: 3-4
Line 246: 4c
Line 247: 4b
Line 248: 4a
Line 249: 5
Line 250: Figure 3.4
Line 251: Applying structural testing in a nutshell. Arrows indicate the 
Line 252: iterative nature of the process. The diamond represents the moment where the 
Line 253: developer decides whether to write the test case.
Line 254: 
Line 255: --- 페이지 97 ---
Line 256: 69
Line 257: Code coverage criteria
Line 258:  Before I show another running example of structural testing and discuss how to
Line 259: pragmatically use it in our daily lives, the next section introduces the coverage criteria
Line 260: we use with this approach. 
Line 261: 3.3
Line 262: Code coverage criteria
Line 263: Whenever we identify a line of code that is not covered, we have to decide how thor-
Line 264: ough (or rigorous) we want to be when covering that line. Let’s revisit an if statement
Line 265: from the CountWords program.
Line 266: if (!Character.isLetter(str.charAt(i)) &&
Line 267:  (last == 's' || last == 'r'))
Line 268: A developer may decide to only cover the line—in other words, if a test passes through
Line 269: that if line, the developer will consider it covered. A single test case can do this. A
Line 270: slightly more thorough developer may cover the if being evaluated to true and
Line 271: false; doing so requires two test cases. A third developer may explore each condition
Line 272: in the if statement. This particular if has three conditions requiring at least two tests
Line 273: each, for a total of six tests. Finally, a very thorough tester may decide to cover every
Line 274: possible execution path of this statement. Given that it has three different conditions,
Line 275: doing so requires 2 × 2 × 2 = 8 test cases.
Line 276:  Let’s formalize this discussion. Note that you’ve already seen some of these terms.
Line 277: 3.3.1
Line 278: Line coverage
Line 279: A developer who aims to achieve line coverage wants at least one test case that cov-
Line 280: ers the line under test. It does not matter if that line contains a complex if statement
Line 281: full of conditions. If a test touches that line in any way, the developer can count the
Line 282: line as covered. 
Line 283: 3.3.2
Line 284: Branch coverage
Line 285: Branch coverage takes into consideration the fact that branching instructions (ifs,
Line 286: fors, whiles, and so on) make the program behave in different ways, depending how
Line 287: the instruction is evaluated. For a simple if(a && b) statement, having a test case T1
Line 288: that makes the if statement true and another test case T2 that makes the statement
Line 289: false is enough to consider the branch covered.
Line 290:  Figure 3.5 illustrates a control-flow graph (CFG) of the CountWords program. You
Line 291: can see that for each if instruction, two edges come out of the node: one represent-
Line 292: ing where the flow goes if the statement is evaluated to true and another representing
Line 293: where the program goes if the statement is evaluated to false. Covering all the edges
Line 294: in the graph means achieving 100% branch coverage. 
Line 295: Listing 3.4
Line 296: An if expression from the CountWords program
Line 297: 
Line 298: --- 페이지 98 ---
Line 299: 70
Line 300: CHAPTER 3
Line 301: Structural testing and code coverage
Line 302: 3.3.3
Line 303: Condition + branch coverage
Line 304: Condition + branch coverage considers not only possible branches but also each con-
Line 305: dition of each branch statement. For example, the first if statement in the Count-
Line 306: Words program contains three conditions: !Character.isLetter(str.charAt(i)),
Line 307: last == 's', and last == 'r'. Therefore, a developer aiming for condition + branch
Line 308: coverage should create a test suite that exercises each of those individual conditions
Line 309: being evaluated to true and false at least once and the entire branch statement
Line 310: being true and false at least once.
Line 311:  Note that blindly looking only at the conditions (and ignoring how they are com-
Line 312: bined) may result in test suites that do not cover everything. Imagine a simple if(A || B).
Line 313: A test suite composed of two tests (T1 that makes A true and B false and T2 that
Line 314: makes A false and B true) covers the two conditions, as each condition is exercised
Line 315: as true and false. However, the test suite does not fully cover the branch, as in both
Line 316: tests, the evaluation of the entire if statement is always true. This is why we use condi-
Line 317: tion + branch coverage, and not only (basic) condition coverage.
Line 318:  
Line 319: int         0
Line 320: words    ;
Line 321: =
Line 322: char        ''
Line 323: last =
Line 324: ;
Line 325: for int     0
Line 326: (    i =  ;
Line 327: i++)
Line 328: words++;
Line 329: last
Line 330: t(i);
Line 331: = str.charA
Line 332: words++;
Line 333: return words;
Line 334: true
Line 335: false
Line 336: false
Line 337: false
Line 338: true
Line 339: true
Line 340: (last == 'r'
Line 341: ||
Line 342: ==
Line 343: last
Line 344: 's')
Line 345: (!isLetter
Line 346: (str.charAt(i))
Line 347: && (l
Line 348: ==
Line 349: ast
Line 350: 's'
Line 351: ||            ))
Line 352: last == 'r'
Line 353: i<str.length()
Line 354: Rectangles
Line 355: represent
Line 356: code blocks
Line 357: Diamonds represent
Line 358: decision blocks
Line 359: Arrows
Line 360: represent
Line 361: the flow
Line 362: Figure 3.5
Line 363: A control-flow graph of the CountWords program
Line 364: 
Line 365: --- 페이지 99 ---
Line 366: 71
Line 367: Code coverage criteria
Line 368:  In the extended CFG in figure 3.6, branch nodes contain only a single condition.
Line 369: The complicated if is broken into three nodes. 
Line 370: 3.3.4
Line 371: Path coverage
Line 372: A developer aiming for path coverage covers all the possible paths of execution of the
Line 373: program. While ideally this is the strongest criterion, it is often impossible or too
Line 374: expensive to achieve. In a single program with three conditions, where each condition
Line 375: could be independently evaluated to true or false, we would have 23 = 8 paths to
Line 376: cover. In a program with 10 conditions, the total number of combinations would be
Line 377: 210 = 1024. In other words, we would need to devise more than a thousand tests!
Line 378:  Path coverage also gets more complicated for programs with loops. In a program
Line 379: with an unbounded loop, the loop might iterate hundreds of times. A rigorous tester
Line 380: aiming for path coverage would have to try the program with the loop executing one
Line 381: time, two times, three times, and so on. 
Line 382: int         0
Line 383: words    ;
Line 384: =
Line 385: char       ''
Line 386: last =
Line 387: ;
Line 388: for int     0
Line 389: (    i =  ;
Line 390: i++
Line 391: words++;
Line 392: last
Line 393: t(i);
Line 394: = str.charA
Line 395: words++;
Line 396: return words;
Line 397: true
Line 398: true
Line 399: false
Line 400: false
Line 401: i<str.length()
Line 402: last == 'r'
Line 403: last       )
Line 404: == 's'
Line 405: !isLetter
Line 406: (str.charAt(i))
Line 407: last == 's'
Line 408: last == 'r'
Line 409: Decision blocks now contain
Line 410: just a single condition.
Line 411: true
Line 412: true
Line 413: false
Line 414: false
Line 415: false
Line 416: false
Line 417: true
Line 418: true
Line 419: Figure 3.6
Line 420: The extended control-flow graph of the CountWords program. Each condition 
Line 421: is in its own node. Covering all the edges in the graph means achieving 100% condition + 
Line 422: branch coverage.
Line 423: 
Line 424: --- 페이지 100 ---
Line 425: 72
Line 426: CHAPTER 3
Line 427: Structural testing and code coverage
Line 428: 3.4
Line 429: Complex conditions and the MC/DC coverage criterion
Line 430: Devising test suites that maximize the number of bugs they can identify while minimiz-
Line 431: ing the effort/cost of building the test suite is part of any tester’s job. The question is,
Line 432: what can we do about complex, lengthy if statements? Modified condition/decision
Line 433: coverage (MC/DC) is a good answer.
Line 434:  The MC/DC criterion looks at combinations of conditions, as path coverage does.
Line 435: However, instead of testing all possible combinations, we identify the important combi-
Line 436: nations that need to be tested. MC/DC exercises each of these conditions so that it
Line 437: can, independently of the other conditions, affect the outcome of the entire decision.
Line 438: Every possible condition of each parameter must influence the outcome at least once.
Line 439: (For details, read Kelly Hayhurst’s 2001 paper.)
Line 440: 3.4.1
Line 441: An abstract example
Line 442: Let’s take a simple abstract example: if(A && (B || C)), where A, B, and C all evaluate
Line 443: to booleans. MC/DC dictates the following:
Line 444: For condition A:
Line 445: – There must be one test case where A = true (say, T1).
Line 446: – There must be one test case where A = false (say, T2).
Line 447: – T1 and T2 (which we call independence pairs) must have different outcomes
Line 448: (for example, T1 makes the entire decision evaluate to true, and T2 makes
Line 449: the entire decision evaluate to false).
Line 450: – Variables B and C in T1 must be equivalent (either both evaluate to true or
Line 451: both evaluate to false) to B and C in T2. In other words, B and C must have
Line 452: the same truth values in T1 and T2.
Line 453: For condition B:
Line 454: – There must be one test case where B = true (say, T3).
Line 455: – There must be one test case where B = false (say, T4).
Line 456: – T3 and T4 must have different outcomes.
Line 457: – Variables A and C in T3 must be equivalent to A and C in T4.
Line 458: For condition C:
Line 459: – There must be one test case where C = true (say, T5).
Line 460: – There must be one test case where C = false (say, T6).
Line 461: – T5 and T6 have different outcomes.
Line 462: – Variables A and B in T5 must be equivalent to A and B in T6.
Line 463: If conditions have only binary outcomes (that is, true or false), the number of tests
Line 464: required to achieve 100% MC/DC coverage is N + 1, where N is the number of condi-
Line 465: tions in the decision (as shown by Chilenski [2001]). Note that N + 1 is smaller than
Line 466: the total number of possible combinations (2N). So, to devise a test suite that achieves
Line 467: 100% MC/DC, we must create N + 1 test cases that, when combined, exercise all the
Line 468: combinations independently from the others. 
Line 469: 
Line 470: --- 페이지 101 ---
Line 471: 73
Line 472: Complex conditions and the MC/DC coverage criterion
Line 473: 3.4.2
Line 474: Creating a test suite that achieves MC/DC
Line 475: The question is how to (mechanically) select such test cases. Let’s continue using the
Line 476: same if statement from the CountWords program (from listing 3.4). The statement
Line 477: takes three booleans as input: (1) whether the current character is a letter and
Line 478: whether this letter is (2) “s” or (3) “r”. Generically, this is the same as the A && (B || C)
Line 479: example we just discussed.
Line 480:  To test this program, we first use a truth table to see all the combinations and their
Line 481: outcomes. In this case, we have three decisions, and 23 = 8. Therefore, we have tests T1
Line 482: to T8, as listed in table 3.1.
Line 483: Our goal is to apply the MC/DC criterion to these test cases and select N + 1 tests,
Line 484: which in this case means 3 + 1 = 4. To determine which four tests satisfy MC/DC, we
Line 485: need to go condition by condition, beginning by selecting the pairs of combinations
Line 486: (or tests) for the isLetter part of the condition:
Line 487: For T1, isLetter, last == s, and last == r are all true, and decision (that is,
Line 488: the outcome of the entire boolean expression) is also true. We now look for
Line 489: another test in the table where the value of isLetter is the opposite of the
Line 490: value in T1 but the other values (last == s and last == r) are the same. This
Line 491: means look for a test where isLetter is false, last == s is true, last == r is
Line 492: true, and decision is false. This combination appears in T5.
Line 493: Thus, we have found a pair of tests, T1 and T5 (an independence pair), where
Line 494: isLetter is the only parameter that is different and the outcome (decision)
Line 495: changes. In other words, for this pair of tests, isLetter independently influences
Line 496: the outcome (decision). Let’s keep the pair {T1, T5} in our list of test cases.
Line 497: We could stop here and move to the next variable. But finding all indepen-
Line 498: dence pairs for isLetter may help us reduce the final number of test cases, as
Line 499: you will see. So let’s continue and look at the next test. In T2, isLetter is true,
Line 500: Table 3.1
Line 501: Truth table for the if expression from the CountWords program
Line 502: Test case
Line 503: isLetter
Line 504: last == s
Line 505: last == r
Line 506: decision
Line 507: T1
Line 508: true
Line 509: true
Line 510: true
Line 511: true
Line 512: T2
Line 513: true
Line 514: true
Line 515: false
Line 516: true
Line 517: T3
Line 518: true
Line 519: false
Line 520: true
Line 521: true
Line 522: T4
Line 523: true
Line 524: false
Line 525: false
Line 526: false
Line 527: T5
Line 528: false
Line 529: true
Line 530: true
Line 531: false
Line 532: T6
Line 533: false
Line 534: true
Line 535: false
Line 536: false
Line 537: T7
Line 538: false
Line 539: false
Line 540: true
Line 541: false
Line 542: T8
Line 543: false
Line 544: false
Line 545: false
Line 546: false
Line 547: 
Line 548: --- 페이지 102 ---
Line 549: 74
Line 550: CHAPTER 3
Line 551: Structural testing and code coverage
Line 552: last == s is true, last == r is false, and decision is true. We repeat the pro-
Line 553: cess and search for a test where isLetter is the opposite of the value in T2 but
Line 554: last == s and last == r remain the same. We find this combination in T6.
Line 555: We have found another pair of tests, T2 and T6, where isLetter is the only
Line 556: parameter that is different and the outcome (decision) also changes, which we
Line 557: also add to our list of test cases.
Line 558: We repeat the process for T3 (isLetter is true, last == s is false, last == r is
Line 559: true) and find that the isLetter parameter in T7 (isLetter is false, last ==
Line 560: s is false, last == r is true) is the opposite of the value in T3 and changes the
Line 561: outcome (decision).
Line 562: The pair for T4 (isLetter is true, last == s is false, last == r is false) is T8
Line 563: (isLetter is false, last == s is false, last == r is false). The outcome of
Line 564: both tests is the same (decision is false), which means the pair {T4, T8} does
Line 565: not show how isLetter can independently affect the overall outcome.
Line 566: We do not find another new or suitable pair when repeating the process for T5, T6,
Line 567: T7, and T8, so we move on from the isLetter parameter to the last == s parameter.
Line 568: We repeat the same process, but now we search for the opposite value of parameter
Line 569: last == s, while isLetter and last == r stay the same:
Line 570: For T1 (isLetter is true, last == s is true, last == r is true), we search for a
Line 571: test where isLetter is true, last == s is false, last == r is true). This appears
Line 572: to be the case in T3. However, the outcome is the same for both test cases.
Line 573: Therefore, {T1, T3} does not show how the last == s parameter independently
Line 574: affects the outcome.
Line 575: After repeating all the steps for the other tests, we find that only {T2, T4} have
Line 576: different values for the last == s parameter where the outcome also changes.
Line 577: Finally, we move to the last == r parameter. As with the last == s parameter, one pair
Line 578: of combinations works: {T3, T4}. I highly recommend carrying out the entire process
Line 579: yourself to get a feel for how it works.
Line 580:  We now have all the pairs for each parameter:
Line 581: 
Line 582: isLetter: {1, 5}, {2, 6}, {3, 7}
Line 583: 
Line 584: last == s: {2, 4}
Line 585: 
Line 586: last == r: {3, 4}
Line 587: Having a single independence pair per variable (isLetter, last == s, and last == r)
Line 588: is enough. We want to minimize the total number of tests, and we know we can
Line 589: achieve this with N + 1 tests. We do not have any choices with conditions last == s and
Line 590: last == r, as we found only one pair of tests for each parameter. This means we need
Line 591: tests T2, T3, and T4. Finally, we need to find the appropriate pair of tests for isLetter.
Line 592: Note that any of the test pairs (T1-T5, T2-T6, or T3-T7) would work. However, we want
Line 593: to reduce the total number of tests in the test suite (and again, we know we only need
Line 594: four in this case).
Line 595: 
Line 596: --- 페이지 103 ---
Line 597: 75
Line 598: Criteria subsumption, and choosing a criterion
Line 599:  If we were to pick T1 or T5, we would have to include the other as well, as they are
Line 600: opposites. Therefore, they are unnecessarily increasing the number of tests. To ensure
Line 601: that our test suite contains at most four test cases, we can add either T6 or T7, as their
Line 602: opposites (T2 and T3) are already included in our test cases. I picked T6 randomly.
Line 603: (You can have more than one set of tests that achieves 100% MC/DC, and all solutions
Line 604: are equally acceptable.)
Line 605:  Therefore, the tests we need for 100% MC/DC coverage are {T2, T3, T4, T6}.
Line 606: These are the only four tests we need—certainly cheaper than the eight tests we would
Line 607: need for path coverage. Now that we know which tests we need to implement, we can
Line 608: automate them.
Line 609: NOTE
Line 610: I have a video on YouTube that explains MC/DC visually: www.youtube
Line 611: .com/watch?v=HzmnCVaICQ4. 
Line 612: 3.5
Line 613: Handling loops and similar constructs
Line 614: You may wonder what to do in the case of loops, such as for and while. The code
Line 615: block inside the loop may be executed different numbers of times, making testing
Line 616: more complicated.
Line 617:  Think of a while(true) loop, which can be non-terminating. To be rigorous, we
Line 618: would have to test the program with the loop block executed one time, two times,
Line 619: three times, and so on. Or imagine a for(i = 0; i < 10; i++) loop with a break inside
Line 620: the body. We would have to test what happened if the loop body executed up to 10
Line 621: times. How can we handle a long-lasting loop (that runs for many iterations) or an
Line 622: unbounded loop (that is executed an unknown number of times)?
Line 623:  Given that exhaustive testing is impossible, testers often rely on the loop
Line 624: boundary adequacy criterion to decide when to stop testing a loop. A test suite satisfies
Line 625: this criterion if and only if for every loop
Line 626: There is a test case that exercises the loop zero times.
Line 627: There is a test case that exercises the loop once.
Line 628: There is a test case that exercises the loop multiple times.
Line 629: Pragmatically speaking, my experience shows that the main challenge comes when
Line 630: devising the test case for the loop being executed multiple times. Should the test case
Line 631: force the loop to iterate 2, 5, or 10 times? This decision requires a good understand-
Line 632: ing of the program and its requirement. With optimal understanding of the specs, you
Line 633: should be able to devise good tests for the loop. Do not be afraid to create two or
Line 634: more tests for the “multiple times” case. Do whatever you need to do to ensure that
Line 635: the loop works as expected. 
Line 636: 3.6
Line 637: Criteria subsumption, and choosing a criterion
Line 638: You may have noticed that some of the criteria we have discussed are more rigorous
Line 639: than others. For example, a single test is enough to achieve 100% line coverage, but two
Line 640: tests are needed for 100% branch coverage. Some strategies subsume other strategies.
Line 641: 
Line 642: --- 페이지 104 ---
Line 643: 76
Line 644: CHAPTER 3
Line 645: Structural testing and code coverage
Line 646: Formally, a strategy X subsumes strategy Y if all elements that Y exercises are also exer-
Line 647: cised by X. Figure 3.7 illustrates the relationships among the coverage criteria.
Line 648: Branch coverage subsumes line coverage, which means 100% branch coverage always
Line 649: implies 100% line coverage. However, 100% line coverage does not imply 100%
Line 650: branch coverage. Moreover, 100% condition + branch coverage always implies 100%
Line 651: branch coverage and 100% line coverage. Following this train of thought, we see that
Line 652: path coverage subsumes all other criteria. This is logical as path coverage covers all
Line 653: possible paths of the program. Next, we see that MC/DC is stronger than condition +
Line 654: branch coverage, as MC/DC ensures the independence of each condition. And condi-
Line 655: tion + branch coverage subsumes both branch and condition coverage independently.
Line 656: Finally, all other criteria, except basic condition coverage, subsume line coverage,
Line 657: which is the weakest criterion in the figure.
Line 658:  You now understand the trade-offs of choosing one criterion over another. A
Line 659: weaker criterion may be cheaper and faster to achieve but leave many parts of the
Line 660: code uncovered. On the other hand, a stronger criterion may cover the code more
Line 661: rigorously at a higher cost. It is up to you, the developer, to decide which criterion
Line 662: to use.
Line 663: NOTE
Line 664: Basic condition coverage does not necessarily subsume line coverage,
Line 665: for the same reason we always use condition + branch coverage together. We
Line 666: can achieve 100% basic condition coverage in a simple if(A || B) by having
Line 667: two tests, T1={true, false} and T2={false, true}. But both tests make the deci-
Line 668: sion block true, so the false branch and its lines are not exercised. 
Line 669: MC/DC
Line 670: Branch + condition
Line 671: coverage
Line 672: Statement/line
Line 673: coverage
Line 674: Path coverage
Line 675: Branch
Line 676: coverage
Line 677: Condition
Line 678: coverage
Line 679: Arrows indicate the
Line 680: subsumption relations. This
Line 681: means if you achieve one,
Line 682: you achieve the other, too.
Line 683: Line coverage is our
Line 684: weakest criterion.
Line 685: Path coverage is our
Line 686: strongest criterion
Line 687: and subsumes all
Line 688: others.
Line 689: Figure 3.7
Line 690: The different coverage criteria and their subsumption relations
Line 691: 
Line 692: --- 페이지 105 ---
Line 693: 77
Line 694: Specification-based and structural testing: A running example
Line 695: 3.7
Line 696: Specification-based and structural testing: 
Line 697: A running example
Line 698: Let’s try specification-based testing and structural testing together on a real-world exam-
Line 699: ple: the leftPad() function from Apache Commons Lang (http://mng.bz/zQ2g):
Line 700: Left-pad a string with a specified string. Pad to a size of size.
Line 701: 
Line 702: str—The string to pad out; may be null.
Line 703: 
Line 704: size—The size to pad to.
Line 705: 
Line 706: padStr—The string to pad with. Null or empty is treated as a single space.
Line 707: The method returns a left-padded string, the original string if no padding is
Line 708: necessary, or null if a null string is input.
Line 709: For example, if we give "abc" as the string input, a dash "-" as the pad string, and 5 as
Line 710: the size, the program will output "--abc".
Line 711:  A developer on your team comes up with the implementation in listing 3.5. For
Line 712: now, suppose you are testing code written by others, so you need to build an under-
Line 713: standing of the code before you can test it properly. Specification-based testing and
Line 714: structural testing are applied the same way, regardless of whether you wrote the code.
Line 715: In later chapters, we discuss test-driven development and how you can use tests to
Line 716: guide you through implementation.
Line 717: public static String leftPad(final String str, final int size,
Line 718:   String padStr) {
Line 719:   if (str == null) {   
Line 720:     return null;
Line 721:   }
Line 722:   if (padStr==null || padStr.isEmpty()) {   
Line 723:     padStr = SPACE;
Line 724:   }
Line 725:   final int padLen = padStr.length();
Line 726:   final int strLen = str.length();
Line 727:   final int pads = size - strLen;
Line 728:   if (pads <= 0) {          
Line 729:     // returns original String when possible
Line 730:     return str;
Line 731:   }
Line 732:   if (pads == padLen) {            
Line 733:     return padStr.concat(str);
Line 734:   } else if (pads < padLen) {    
Line 735:     return padStr.substring(0, pads).concat(str);
Line 736: Listing 3.5
Line 737: leftPad implementation from the Apache Commons
Line 738: If the string to pad is 
Line 739: null, we return null 
Line 740: right away.
Line 741: If the pad string is 
Line 742: null or empty, we 
Line 743: make it a space.
Line 744: There is no 
Line 745: need to pad 
Line 746: this string.
Line 747: If the number of characters to 
Line 748: pad matches the size of the 
Line 749: pad string, we concatenate it.
Line 750: If we cannot fit the entire 
Line 751: pad string, we add only 
Line 752: the part that fits.
Line 753: 
Line 754: --- 페이지 106 ---
Line 755: 78
Line 756: CHAPTER 3
Line 757: Structural testing and code coverage
Line 758:   } else {                
Line 759:     final char[] padding = new char[pads];
Line 760:     final char[] padChars = padStr.toCharArray();
Line 761:     for (int i = 0; i < pads; i++) {
Line 762:       padding[i] = padChars[i % padLen];
Line 763:     }
Line 764:     return new String(padding).concat(str);
Line 765:   }
Line 766: }
Line 767: Now it is time for some systematic testing. As we know, the first step is to apply
Line 768: specification-based testing. Let’s follow the process discussed in chapter 2 (I suggest
Line 769: you try to do it yourself and compare your solution to mine):
Line 770: 1
Line 771: We read the requirements. We understand that the program adds a given char-
Line 772: acter/string to the beginning (left) of the string, up to a specific size. The pro-
Line 773: gram has three input parameters: str, representing the original string to be
Line 774: padded; size, representing the desired size of the returned string; and padStr,
Line 775: representing the string used to pad. The program returns a String. The pro-
Line 776: gram has specific behavior if any of the inputs is null. (If we had implemented
Line 777: the feature ourselves, we would probably skip this step, as we would already
Line 778: have a complete understanding of the requirements.)
Line 779: 2
Line 780: Based on all the observations in step 1, we derive the following list of partitions:
Line 781: – str parameter
Line 782: Null
Line 783: Empty string
Line 784: Non-empty string
Line 785: – size parameter
Line 786: Negative number
Line 787: Positive number
Line 788: – padStr parameter
Line 789: Null
Line 790: Empty
Line 791: Non-empty
Line 792: – str, size parameters
Line 793: 
Line 794: size < len(str)
Line 795: 
Line 796: size > len(str)
Line 797: 3
Line 798: There are several boundaries:
Line 799: – size being precisely 0
Line 800: – str having length 1
Line 801: – padStr having length 1
Line 802: – size being precisely the length of str
Line 803: We have to add the pad 
Line 804: string more than once. We 
Line 805: go character by character 
Line 806: until the string is fully 
Line 807: padded.
Line 808: 
Line 809: --- 페이지 107 ---
Line 810: 79
Line 811: Specification-based and structural testing: A running example
Line 812: 4
Line 813: We can devise single tests for exceptional cases such as null, empty, and nega-
Line 814: tive size. We also have a boundary related to padStr: we can exercise padStr
Line 815: with a single character only once and have all other tests use a pad with a single
Line 816: character (otherwise, the number of combinations would be too large). We
Line 817: obtain the following tests:
Line 818: – T1: str is null.
Line 819: – T2: str is empty.
Line 820: – T3: negative size.
Line 821: – T4: padStr is null.
Line 822: – T5: padStr is empty.
Line 823: – T6: padStr has a single character.
Line 824: – T7: size is equal to the length of str.
Line 825: – T8: size is equal to 0.
Line 826: – T9: size is smaller than the length of str.
Line 827: Now we automate the tests. I used a parameterized test, but it is fine if you prefer nine
Line 828: traditional JUnit tests.
Line 829: public class LeftPadTest {
Line 830:   @ParameterizedTest
Line 831:   @MethodSource("generator")
Line 832:   void test(String originalStr, int size, String padString,
Line 833:    String expectedStr) {               
Line 834:     assertThat(leftPad(originalStr, size, padString))
Line 835:         .isEqualTo(expectedStr);
Line 836:   }
Line 837:   static Stream<Arguments> generator() {     
Line 838:     return Stream.of(
Line 839:       of(null, 10, "-", null),  
Line 840:       of("", 5, "-", "-----"),  
Line 841:       of("abc", -1, "-", "abc"),      
Line 842:       of("abc", 5, null, "  abc"),      
Line 843:       of("abc", 5, "", " abc"),         
Line 844:       of("abc", 5, "-", "--abc"),    
Line 845:       of("abc", 3, "-", "abc"),      
Line 846:       of("abc", 0, "-", "abc"),     
Line 847:       of("abc", 2, "-", "abc")     
Line 848:     );
Line 849:   }
Line 850: }
Line 851: It is time to augment the test suite through structural testing. Let’s use a code cover-
Line 852: age tool to tell us what we have already covered (see figure 3.8). The report shows that
Line 853: we are missing some branches: the if (pads == padLen) and else if (pads < padLen)
Line 854: expressions.
Line 855: Listing 3.6
Line 856: Tests for LeftPad after specification-based testing
Line 857: The parameterized 
Line 858: test, similar to the 
Line 859: ones we have written 
Line 860: before
Line 861: The nine tests we created 
Line 862: are provided by the 
Line 863: method source.
Line 864: T1
Line 865: T2
Line 866: T3
Line 867: T4
Line 868: T5
Line 869: T6
Line 870: T7
Line 871: T8
Line 872: T9
Line 873: 
Line 874: --- 페이지 108 ---
Line 875: 80
Line 876: CHAPTER 3
Line 877: Structural testing and code coverage
Line 878: This is useful information. Why didn’t we cover these lines? What did we miss? As a
Line 879: developer, you should triangulate what you see in the source with the specification
Line 880: and your mental model of the program. In this case, we conclude that we did not
Line 881: exercise padStr being smaller, greater, or equal to the remaining space in str. What a
Line 882: tricky boundary! This is why structural testing is essential: it helps identify partitions
Line 883: and boundaries we may have missed.
Line 884:  With that information in mind, we derive three more test cases:
Line 885: T10: the length of padStr is equal to the remaining spaces in str.
Line 886: T11: the length of padStr is greater than the remaining spaces in str.
Line 887: T12: the length of padStr is smaller than the remaining spaces in str (this test
Line 888: may be similar to T6).
Line 889: We add these three extra test cases to our parameterized test, as shown in listing 3.7.
Line 890: When we run the coverage tool again, we get a report similar to the one in figure 3.9.
Line 891: We now cover all the branches.
Line 892: static Stream<Arguments> generator() {
Line 893:   return Stream.of(
Line 894:     // ... others here
Line 895: Listing 3.7
Line 896: Three new test cases for leftPad
Line 897: The red lines indicate parts of the
Line 898: code that are still not covered!
Line 899: Figure 3.8
Line 900: Code coverage achieved by the specification-based tests for the leftPad method. The 
Line 901: two return lines near the arrow are not covered; the if and else if, also near the arrow, are 
Line 902: only partially covered. The remaining lines are fully covered.
Line 903: 
Line 904: --- 페이지 109 ---
Line 905: 81
Line 906: Specification-based and structural testing: A running example
Line 907:     of("abc", 5, "--", "--abc"), // T10
Line 908:     of("abc", 5, "---", "--abc"), // T11
Line 909:     of("abc", 5, "-", "--abc") // T12
Line 910:   );
Line 911: }
Line 912: NOTE
Line 913: Interestingly, if you look at the entire class, JaCoCo does not give
Line 914: 100% coverage, but only 96%. The report highlights the first line of the file:
Line 915: the declaration of the class, public class LeftPadUtils {. The leftPad
Line 916: method is static, so none of our tests instantiate this class. Given that we know
Line 917: the context, we can ignore the fact that this line is not covered. This is a good
Line 918: example of why only looking at the numbers makes no sense. We discuss this
Line 919: further, later in the chapter.
Line 920: With all the branches covered, we now look for other interesting cases to test. The
Line 921: implementation contains interesting decisions that we may decide to test. In particu-
Line 922: lar, we observe an if (pads <= 0) block with the code comment “returns original
Line 923: String when possible”. As a tester, you may decide to test this specific behavior: “If the
Line 924: string is not padded, the program should return the same String instance.” That can
Line 925: be written as a JUnit test as follows.
Line 926:  
Line 927:  
Line 928: All lines are green.
Line 929: Everything is
Line 930: covered!
Line 931: Figure 3.9
Line 932: Code coverage of the leftPad method after specification-based and structural tests. We 
Line 933: now achieve 100% branch coverage.
Line 934: 
Line 935: --- 페이지 110 ---
Line 936: 82
Line 937: CHAPTER 3
Line 938: Structural testing and code coverage
Line 939: @Test
Line 940: void sameInstance() {
Line 941:   String str = "sometext";
Line 942:   assertThat(leftPad(str, 5, "-")).isSameAs(str);
Line 943: }
Line 944: We are now much more confident that our test suite covers all the critical behavior of
Line 945: the program. Structural testing and code coverage helped us identify parts of the code
Line 946: that we did not test (or partitions we missed) during our specification-based testing—
Line 947: and that is what structural testing is all about. 
Line 948: 3.8
Line 949: Boundary testing and structural testing
Line 950: The most challenging part of specification-based testing is identifying boundaries.
Line 951: They are tricky to find, given the way we write specifications. Luckily, they are much
Line 952: easier to find in source code, given how precise code has to be. All the boundary test-
Line 953: ing ideas we discussed in the previous chapter apply here.
Line 954:  The idea of identifying and testing on and off points fits nicely in structural testing.
Line 955: For example, we can analyze the if statements in the leftPad program:
Line 956: 
Line 957: if (pads <= 0)—The on point is 0 and evaluates the expression to true. The off
Line 958: point is the nearest point to the on point that makes the expression evaluate to
Line 959: false. In this case, given that pads is an integer, the nearest point is 1.
Line 960: 
Line 961: if (pads == padLen)—The on point is padLen. Given the equality and that padLen
Line 962: is an integer, we have two off points: one that happens when pads == padLen - 1
Line 963: and another that happens when pads = padLen + 1.
Line 964: 
Line 965: if (pads < padLen)—The on point is again padLen. The on point evaluates the
Line 966: expression to false. The off point is, therefore, pads == padLen - 1.
Line 967: As a tester, you may want to use this information to see whether you can augment your
Line 968: test suite.
Line 969:  We discussed the loop boundary criterion earlier, which helps us try different pos-
Line 970: sible boundaries. If a loop has a less conventional, more complicated expression, con-
Line 971: sider applying on and off analysis there as well. 
Line 972: 3.9
Line 973: Structural testing alone often is not enough
Line 974: If code is the source of all truth, why can’t we just do structural testing? This is a very
Line 975: interesting question. Test suites derived only with structural testing can be reasonably
Line 976: effective, but they may not be strong enough. Let’s look at an example (see the
Line 977: “counting clumps” problem, inspired by a CodingBat assignment: https://codingbat
Line 978: .com/prob/p193817):
Line 979:  
Line 980: Listing 3.8
Line 981: Another extra test for leftPad
Line 982: 
Line 983: --- 페이지 111 ---
Line 984: 83
Line 985: Structural testing alone often is not enough
Line 986: The program should count the number of clumps in an array. A clump is a
Line 987: sequence of the same element with a length of at least 2.
Line 988: 
Line 989: nums—The array for which to count the clumps. The array must be non-
Line 990: null and length > 0; the program returns 0 if any pre-condition is violated.
Line 991: The program returns the number of clumps in the array.
Line 992: The following listing shows an implementation.
Line 993: public static int countClumps(int[] nums) {
Line 994:   if (nums == null || nums.length == 0) {   
Line 995:     return 0;
Line 996:   }
Line 997:   int count = 0;
Line 998:   int prev = nums[0];
Line 999:   boolean inClump = false;
Line 1000:   for (int i = 1; i < nums.length; i++) {
Line 1001:     if (nums[i] == prev && !inClump) {   
Line 1002:       inClump = true;
Line 1003:       count += 1;
Line 1004:     }
Line 1005:     if (nums[i] != prev) {   
Line 1006:       prev = nums[i];
Line 1007:       inClump = false;
Line 1008:     }
Line 1009:   }
Line 1010:   return count;
Line 1011: }
Line 1012: Suppose we decide not to look at the requirements. We want to achieve, say, 100%
Line 1013: branch coverage. Three tests are enough to do that (T1–T3). Maybe we also want to
Line 1014: do some extra boundary testing and decide to exercise the loop, iterating a single
Line 1015: time (T4):
Line 1016: T1: an empty array
Line 1017: T2: a null array
Line 1018: T3: an array with a single clump of three elements in the middle (for example,
Line 1019: [1,2,2,2,1])
Line 1020: T4: an array with a single element
Line 1021: To check that for yourself, write down these three tests as (JUnit) automated test cases
Line 1022: and run your favorite code coverage tool as in the following.
Line 1023: @ParameterizedTest
Line 1024: @MethodSource("generator")
Line 1025: void testClumps(int[] nums, int expectedNoOfClumps) {
Line 1026:   assertThat(Clumps.countClumps(nums))
Line 1027: Listing 3.9
Line 1028: Implementing the code clumps requirement
Line 1029: Listing 3.10
Line 1030: 100% branch coverage for the clump-counting problem
Line 1031: If null or empty 
Line 1032: (pre-condition), 
Line 1033: return 0 right away.
Line 1034: If the current number is the 
Line 1035: same as the previous number, 
Line 1036: we have identified a clump.
Line 1037: If the current number 
Line 1038: differs from the previous 
Line 1039: one, we are not in a clump.
Line 1040: 
Line 1041: --- 페이지 112 ---
Line 1042: 84
Line 1043: CHAPTER 3
Line 1044: Structural testing and code coverage
Line 1045:       .isEqualTo(expectedNoOfClumps);
Line 1046: }
Line 1047: static Stream<Arguments> generator() {   
Line 1048:   return Stream.of(
Line 1049:     of(new int[]{}, 0), // empty
Line 1050:     of(null, 0), // null
Line 1051:     of(new int[]{1,2,2,2,1}, 1), // one clump
Line 1052:     of(new int[]{1}, 0) // one element
Line 1053:   );
Line 1054: }
Line 1055: This test suite is reasonable and exercises the main behavior of the program, but note
Line 1056: how weak it is. It achieves 100% branch coverage, but it misses many interesting test
Line 1057: cases. Even without performing systematic specification testing, in a program that
Line 1058: counts clumps, it is natural to try the program with multiple clumps instead of just
Line 1059: one. We could try it with the last clump happening at the last item of the array or with
Line 1060: an array that has a clump starting in the first position. Such specific cases cannot be
Line 1061: captured by pure structural testing guided mainly by coverage. This is yet another rea-
Line 1062: son not to rely blindly on coverage. Structural testing shows its value when combined
Line 1063: with knowledge of the specification. 
Line 1064: 3.10
Line 1065: Structural testing in the real world
Line 1066: Now that you have a clear picture of structural testing, the coverage criteria you can
Line 1067: use for guidance, and how to use structural testing in combination with specification-
Line 1068: based testing, let me discuss a few interesting points.
Line 1069: 3.10.1 Why do some people hate code coverage?
Line 1070: I find it interesting that some people rage against code coverage. A prevalent opinion
Line 1071: is, “If I write a test case with no assertions, I achieve 100% coverage, but I am not test-
Line 1072: ing anything!” This is true. If your tests have no assertions, they do not test anything,
Line 1073: but the production code is exercised. However, I consider that a flawed argument. It
Line 1074: assumes the very worst (unrealistic) scenario possible. If you are writing test suites with
Line 1075: no assertions, you have bigger problems to take care of before you can enjoy the ben-
Line 1076: efits of structural testing.
Line 1077:  Between the lines, people use such an argument to explain that you should not
Line 1078: look at the coverage number blindly, because it can mislead you. That I fully agree
Line 1079: with. Here, the misconception is how people see code coverage. If code coverage is
Line 1080: only a number you should achieve, you may end up writing less useful test cases and
Line 1081: gaming the metric (something that Bouwers, Visser, and Van Deursen have argued
Line 1082: in 2012).
Line 1083:  I hope this chapter has clarified how structural testing and code coverage should
Line 1084: be used: to augment specification-based testing, quickly identify parts of the code that
Line 1085: are not currently exercised by the test suite, and identify partitions you missed when
Line 1086: The four test 
Line 1087: cases we defined
Line 1088: 
Line 1089: --- 페이지 113 ---
Line 1090: 85
Line 1091: Structural testing in the real world
Line 1092: doing specification-based testing. Achieving a high coverage number may be a conse-
Line 1093: quence of you doing that, but the purpose is different. If you leave a line uncovered, it
Line 1094: is because you thought about it and decided not to cover it.
Line 1095: EMPIRICAL EVIDENCE IN FAVOR OF CODE COVERAGE
Line 1096: Understanding whether structural coverage helps and whether high coverage num-
Line 1097: bers lead to better-tested software has been the goal of many empirical software engi-
Line 1098: neering researchers. Interestingly, while researchers have not yet found a magical
Line 1099: coverage number that we should aim for, some evidence points toward the benefits of
Line 1100: structural testing. I quote four of these studies:
Line 1101: Hutchins et al. (1994)—“Within the limited domain of our experiments, test sets
Line 1102: achieving coverage levels over 90% usually showed significantly better fault
Line 1103: detection than randomly chosen test sets of the same size. In addition, signifi-
Line 1104: cant improvements in the effectiveness of coverage-based tests usually occurred
Line 1105: as coverage increased from 90% to 100%. However, the results also indicate
Line 1106: that 100% code coverage alone is not a reliable indicator of the effectiveness of
Line 1107: a test set.”
Line 1108: Namin and Andrews (2009)—“Our experiments indicate that coverage is some-
Line 1109: times correlated with effectiveness when test suite size is controlled for, and that
Line 1110: using both size and coverage yields a more accurate prediction of effectiveness
Line 1111: than test suite size alone. This, in turn, suggests that both size and coverage are
Line 1112: important to test suite effectiveness.”
Line 1113: Inozemtseva and Holmes (2014)—“We found that there is a low to moderate cor-
Line 1114: relation between coverage and effectiveness when the number of test cases in
Line 1115: the suite is controlled for. In addition, we found that stronger forms of coverage
Line 1116: do not provide greater insight into the effectiveness of the suite. Our results
Line 1117: suggest that coverage, while useful for identifying under-tested parts of a pro-
Line 1118: gram, should not be used as a quality target because it is not a good indicator of
Line 1119: test suite effectiveness.”
Line 1120: Gopinath et al. (2020)—“This paper finds a correlation between lightweight,
Line 1121: widely available coverage criteria (statement, block, branch, and path coverage)
Line 1122: and mutation kills for hundreds of Java programs (…). For both original and
Line 1123: generated suites, statement coverage is the best predictor for mutation kills,
Line 1124: and in fact does a relatively good job of predicting suite quality.”
Line 1125: Although developing sound experiments to show whether coverage helps is difficult,
Line 1126: and we are not quite there yet (see Chen et al.’s 2020 paper for a good statistical expla-
Line 1127: nation of why it is hard), the current results make sense to me. Even with the small
Line 1128: code examples we have been exploring, we can see a relationship between covering all
Line 1129: the partitions via specification-based testing and covering the entire source code. The
Line 1130: opposite is also true: if you cover a significant part of the source code, you also cover
Line 1131: most of the partitions. Therefore, high coverage implies more partitions being tested.
Line 1132: 
Line 1133: --- 페이지 114 ---
Line 1134: 86
Line 1135: CHAPTER 3
Line 1136: Structural testing and code coverage
Line 1137:  The empirical results also show that coverage alone is not always a strong indica-
Line 1138: tor of how good a test suite is. We also noticed that in the test cases we derived for
Line 1139: the CountWords problem at the beginning of this chapter. We purposefully did bad
Line 1140: specification-based testing and then augmented the test suite with structural testing.
Line 1141: We ended up with three test cases that achieve 100% condition + branch coverage.
Line 1142: But is the test suite strong enough? I don’t think so. I can think of many extra test
Line 1143: cases that would touch the same lines and branches again but would nonetheless
Line 1144: make the test suite much more effective against possible bugs.
Line 1145:  On the other hand, although 100% coverage does not necessarily mean the system
Line 1146: is properly tested, having very low coverage does mean your system is not properly
Line 1147: tested. Having a system with, say, 10% coverage means there is much to be done as far
Line 1148: as testing.
Line 1149:  I suggest reading Google’s code coverage best practices (Arguelles, Ivankovic, and
Line 1150: Bender, 2020). Their perceptions are in line with everything we have discussed here. 
Line 1151: 3.10.2 What does it mean to achieve 100% coverage?
Line 1152: I have purposefully skipped talking much about achieving 100% line coverage or
Line 1153: branch coverage or other coverage. I do not believe that achieving a number should
Line 1154: be the goal. Nevertheless, given how prevalent those numbers are in practice, it is
Line 1155: important to understand them. First, let’s talk about the metrics themselves.
Line 1156: NOTE
Line 1157: Formulas vary among the tools on the market. Check your tool’s man-
Line 1158: ual to better understand the precise numbers you get.
Line 1159: If the entire test suite covers all the lines in the program (or in the class or method
Line 1160: under test), that suite achieves 100% line coverage. A simple formula to calculate the
Line 1161: line coverage of a given program or method is to divide the number of lines covered
Line 1162: by the total number of lines:
Line 1163: You can calculate this number at the method level, class level, package level, system
Line 1164: level, or whatever level you are interested in.
Line 1165:  Similar to line coverage, a formula to calculate the achieved branch coverage of a
Line 1166: program or method is the number of branches covered divided by the total number
Line 1167: of branches:
Line 1168: In a simple program such as if(x) { do A } else { do B }, the total number of branches
Line 1169: is two (the single if statement branches the program in two ways). Therefore, if one
Line 1170: 
Line 1171: --- 페이지 115 ---
Line 1172: 87
Line 1173: Structural testing in the real world
Line 1174: test in your test suite covers, say x = true, your test suite achieves 1/2 × 100% = 50%
Line 1175: branch coverage. Note that due to criteria subsumption, which we discussed earlier, if
Line 1176: you cover all the branches of the program, you also cover all the lines.
Line 1177:  Finally, a formula to calculate the condition + branch coverage of a given program or
Line 1178: method is the sum of all branches and conditions covered, divided by the total num-
Line 1179: ber of branches and conditions:
Line 1180: In a simple program such as if(x || y) { do A } else { do B }, the total number of
Line 1181: branches is two (the single if statement branches the program in two ways) and the
Line 1182: total number of conditions is four (two conditions for x and two conditions for y).
Line 1183: Therefore, if you have two tests in your test suite—T1: (true, true) and T2: (false,
Line 1184: true)—the test suite achieves (1 + 3)/(2 + 4) × 100% = 66.6% condition + branch cov-
Line 1185: erage. The test suite covers only one branch of the program (the true branch, as both
Line 1186: T1 and T2 make the if expression evaluate to true), and three of the four conditions
Line 1187: (x is exercised as true and false, but y is only exercised as true).
Line 1188:  Figure 3.10 shows a simple illustration of line coverage, branch coverage, and
Line 1189: condition + branch coverage. When someone says, “My test suite achieves 80% con-
Line 1190: dition + branch coverage,” you now understand that 80% of the branches and con-
Line 1191: ditions are covered by at least one test case. And when someone says, “My test suite
Line 1192: achieves 100% line coverage,” you know that 100% of the lines are covered by at
Line 1193: least one test case. 
Line 1194: if(x)
Line 1195: Do A
Line 1196: Do B
Line 1197: true
Line 1198: false
Line 1199: Suppose a t
Line 1200: T1 mak
Line 1201: ue.
Line 1202: est
Line 1203: es the
Line 1204: tr
Line 1205: if
Line 1206: • Line cover
Line 1207: = 66.6%
Line 1208: age: 2/3
Line 1209: • Branch coverage: 1/2 = 50%
Line 1210: if(x || y)
Line 1211: Do A
Line 1212: Do B
Line 1213: true
Line 1214: false
Line 1215: Imagine a test T1 where
Line 1216: .
Line 1217: x = true
Line 1218: • Line cover
Line 1219: = 66.6%
Line 1220: age: 2/3
Line 1221: • Branch cover
Line 1222: e:
Line 1223: ag
Line 1224: 1/2 = 50%
Line 1225: • Branch + c
Line 1226: c
Line 1227: erage: (1 + 2)/(2 + 4) = 50%
Line 1228: ondition ov
Line 1229: Figure 3.10
Line 1230: Two control-flow graphs of simple programs and how the different coverage 
Line 1231: criteria are calculated
Line 1232: 
Line 1233: --- 페이지 116 ---
Line 1234: 88
Line 1235: CHAPTER 3
Line 1236: Structural testing and code coverage
Line 1237: 3.10.3 What coverage criterion to use
Line 1238: This is a popular question among practitioners and researchers. If we settle for a
Line 1239: less-rigorous criterion, such as line coverage instead of branch coverage, we might
Line 1240: miss something. Plus this question brings the focus back to the metric, which we do
Line 1241: not want.
Line 1242:  Which criterion to use depends on the context: what you are testing at that
Line 1243: moment and how rigorous you want the testing to be. Structural testing is meant to
Line 1244: complement specification-based testing. When you dive into the source code and look
Line 1245: for uncovered parts, you may decide to use branch coverage for a specific if expres-
Line 1246: sion but MC/DC for another if expression. This makes the approach less systematic
Line 1247: (and, therefore, more prone to errors and different developers using different crite-
Line 1248: ria), but it is the most pragmatic approach I know. You may want to perform some risk
Line 1249: assessment to determine how important it is to be thorough.
Line 1250:  My rule of thumb is branch coverage: I always try to at least reach all the branches
Line 1251: of the program. Whenever I see a more complicated expression, I evaluate the need
Line 1252: for condition + branch coverage. If I see an even more complex expression, I consider
Line 1253: MC/DC. 
Line 1254: 3.10.4 MC/DC when expressions are too complex and 
Line 1255: cannot be simplified
Line 1256: MC/DC is increasingly valuable as expressions become more complicated. Listing 3.11
Line 1257: shows an example of a complex expression that I extracted from Chilenski’s 2001
Line 1258: paper. It is an anonymized version of a condition found in a level A flight simulation
Line 1259: program and contains an impressive 76 conditions. Achieving path coverage in such a
Line 1260: complex expression is impossible (276 = 7.5 × 1022 test cases), so smart approaches
Line 1261: such as MC/DC come in handy.
Line 1262: Bv or (Ev != El) or Bv2 or Bv3 or Bv4 or Bv5 or Bv6 or Bv7 or Bv8 or Bv9 or
Line 1263: Bv10 or Bv11 or Bv12 or Bv13 or Bv14 or Bv15 or Bv16 or Bv17 or Bv18 or
Line 1264: Bv19 or Bv20 or Bv21 or Bv22 or Bv23 or Bv24 or Bv25 or Bv26 or Bv27 or
Line 1265: Bv28 or Bv29 or Bv30 or Bv31 or Bv32 or Bv33 or Bv34 or Bv35 or Bv36 or
Line 1266: Bv37 or Bv38 or Bv39 or Bv40 or Bv41 or Bv42 or Bv43 or Bv44 or Bv45 or
Line 1267: Bv46 or Bv47 or Bv48 or Bv49 or Bv50 or Bv51 or (Ev2 = El2) or
Line 1268: ((Ev3 = El2) and (Sav != Sac)) or Bv52 or Bv53 or Bv54 or Bv55 or Bv56
Line 1269: or Bv57 or Bv58 or Bv59 or Bv60 or Bv61 or Bv62 or Bv63 or Bv64 or Bv65
Line 1270: or Ev4 != El3 or Ev5 = El4 or Ev6 = El4 or Ev7 = El4 or Ev8 = El4 or
Line 1271: Ev9 = El4 or Ev10 = El4
Line 1272: Pragmatically speaking, testing such a complex expression, with or without MC/DC, is
Line 1273: a challenge, and you should avoid doing so when possible. Sometimes you can break
Line 1274: an expression into smaller bits that you can then test. But in cases where breaking
Line 1275: complex expressions is not possible, MC/DC shines.
Line 1276: Listing 3.11
Line 1277: Complex expression from flight simulation software
Line 1278: 
Line 1279: --- 페이지 117 ---
Line 1280: 89
Line 1281: Structural testing in the real world
Line 1282: For completeness, here are some final remarks about MC/DC. First, in the example in
Line 1283: section 3.1, we apply unique-cause MC/DC criteria: we identify an independence pair
Line 1284: (T1, T2) where only a single condition and the final outcome change between T1 and
Line 1285: T2. That may not be possible in all cases. For example, consider (A && B) || (A && C).
Line 1286: Ideally, we would demonstrate the independence of the first A, B, the second A, and C.
Line 1287: But it is impossible to change the first A and not change the second A. Thus, we can-
Line 1288: not demonstrate the independence of each A in the expression. In such cases, we
Line 1289: allow A to vary, but we fix all other variables (this is called masked MC/DC).
Line 1290:  Second, note that it may not be possible to achieve MC/DC in some expressions,
Line 1291: such as (A and B) or (A and not B). While the independence pairs (TT, FT) would
Line 1292: show the independence of A, there are no pairs that show the independence of B. In
Line 1293: such cases, revisit the expression, as it may have been poorly designed. In this exam-
Line 1294: ple, the expression could be reformulated to simply A.
Line 1295:  Finally, mathematically speaking, N + 1 is the theoretical lower bound for the num-
Line 1296: ber of tests you may need when applying MC/DC. In other words, you may need more
Line 1297: than N + 1 test cases to achieve MC/DC in some expressions. However, the empirical
Line 1298: study by Chilenski (2001) shows that the majority of expressions in practice require
Line 1299: N + 1 tests. This has been my observation, too: N + 1 is most of the times the number
Line 1300: of required test cases. 
Line 1301: 3.10.5 Other coverage criteria
Line 1302: Throughout this chapter, we have used the program’s control flow as a way to derive
Line 1303: different tests. Another way of approaching structural testing is to look at the data flow:
Line 1304: examining how the data flows to different parts of the program.
Line 1305:  For example, imagine that a variable is defined, then modified one, two, or three
Line 1306: times in other parts of the program, and then used again later. You may want to
Line 1307: ensure that you exercise all the possible ways this variable is touched. Trying to sum-
Line 1308: marize data-flow coverage in one sentence is unfair, and a lot of energy has been spent
Line 1309: coming up with criteria, but this should give you some intuition about it.
Line 1310: MC/DC in SQLite
Line 1311: A nice story of the benefits of MC/DC was told by Richard Hipp, the creator and pri-
Line 1312: mary developer of SQLite, the most popular embedded database. In the Corecursive
Line 1313: #066 podcast, Richard says, “I had this idea, I’m going to write tests to bring SQLite
Line 1314: up to the quality of 100% MC/DC, and that took a year of 60-hour weeks. That was
Line 1315: hard, hard work. I was putting in 12-hour days every single day. I was getting so tired
Line 1316: of this because with this sort of thing, it’s the old joke of, you get 95% of the func-
Line 1317: tionality with the first 95% of your budget, and the last 5% on the second 95% of your
Line 1318: budget. It’s kind of the same thing. It’s pretty easy to get up to 90 or 95% test cov-
Line 1319: erage. Getting that last 5% is really, really hard, and it took about a year for me to get
Line 1320: there, but once we got to that point, we stopped getting bug reports from Android.”
Line 1321: What a powerful success story of MC/DC.
Line 1322: 
Line 1323: --- 페이지 118 ---
Line 1324: 90
Line 1325: CHAPTER 3
Line 1326: Structural testing and code coverage
Line 1327:  I do not discuss data-flow coverage in this book, but I suggest you read more about
Line 1328: it. Pezzè and Young (2008) give a nice explanation. 
Line 1329: 3.10.6 What should not be covered?
Line 1330: We have talked a lot about what to test and cover. Let’s quickly discuss what not to
Line 1331: cover. Achieving 100% coverage may be impossible or not even desirable. For exam-
Line 1332: ple, the code snippet in listing 3.12 returns the full path of a specific directory. The
Line 1333: code may throw a URISyntaxException, which we catch and wrap around a Runtime-
Line 1334: Exception. (For the Java experts, we are converting a checked exception to an
Line 1335: unchecked exception.)
Line 1336: public static String resourceFolder(String path) {
Line 1337:   try {
Line 1338:     return Paths.get(ResourceUtils.class
Line 1339:       .getResource("/").toURI()).toString() + path;
Line 1340:   } catch (URISyntaxException e) {
Line 1341:     throw new RuntimeException(e);
Line 1342:   }
Line 1343: }
Line 1344: To achieve 100% line coverage, we would need to exercise the catch block. For that to
Line 1345: happen, we would have to somehow force the toURI method to throw the exception.
Line 1346: We could use mocks (discussed later in this book), but I cannot see any advantage in
Line 1347: doing that. It is more important to test what would happen to the rest of the system if
Line 1348: resourceFolder threw a RuntimeException. That is much easier to do, as we have
Line 1349: more control over the resourceFolder method than the Java toURI() method.
Line 1350: Therefore, this piece of code it is not worth covering and shows why blindly aiming for
Line 1351: 100% coverage makes no sense.
Line 1352:  In Java, in particular, I tend not to write dedicated tests for equals and hashCode
Line 1353: methods or straightforward getters and setters. These are tested implicitly by the tests
Line 1354: that exercise the other methods that use them.
Line 1355:  To close this discussion, I want to reinforce that, for me, all code should be covered
Line 1356: until proven otherwise. I start from the idea that I should have 100% coverage. Then, if I
Line 1357: see that a piece of code does not need to be covered, I make an exception. But be
Line 1358: careful—experience shows that bugs tend to appear in areas you do not cover well. 
Line 1359: 3.11
Line 1360: Mutation testing
Line 1361: All the coverage criteria discussed in this chapter consider how much of the produc-
Line 1362: tion code is exercised by a test. What they all miss is whether the assertions that these
Line 1363: tests make are good and strong enough to capture bugs. If we introduce a bug in the
Line 1364: code, even in a line covered by a test, will the test break?
Line 1365:  As mentioned earlier, coverage alone is not enough to determine whether a test
Line 1366: suite is good. We have been thinking about how far our test suite goes to evaluate the
Line 1367: Listing 3.12
Line 1368: A method that does not deserve full coverage
Line 1369: 
Line 1370: --- 페이지 119 ---
Line 1371: 91
Line 1372: Mutation testing
Line 1373: strength of our test suite. Now let’s think of the test suite’s fault detection capability. How
Line 1374: many bugs can it reveal?
Line 1375:  This is the idea behind mutation testing. In a nutshell, we purposefully insert a bug
Line 1376: in the existing code and check whether the test suite breaks. If it does, that’s a point
Line 1377: for the test suite. If it does not (all tests are green even with the bug in the code), we
Line 1378: have found something to improve in our test suite. We then repeat the process: we
Line 1379: create another buggy version of the problem by changing something else in the code,
Line 1380: and we check whether the test suite captures that bug.
Line 1381:  These buggy versions are mutants of the original, supposedly correct, version of the
Line 1382: program. If the test suite breaks when executed against a mutant, we say that the test
Line 1383: suite kills that mutant. If it does not break, we say that the mutant survives. A test suite
Line 1384: achieves 100% mutation coverage if it kills all possible mutants.
Line 1385:  Mutation testing makes two interesting assumptions. First, the competent programmer
Line 1386: hypothesis assumes that the program is written by a competent programmer and that
Line 1387: the implemented version is either correct or differs from the correct program by a
Line 1388: combination of simple errors. Second, the coupling effect says that a complex bug is
Line 1389: caused by a combination of many small bugs. Therefore, if your test suite can catch
Line 1390: simple bugs, it will also catch the more complex ones.
Line 1391:  Pitest is the most popular open source tool for mutation testing in Java (https://
Line 1392: pitest.org/quickstart/mutators). Here are a few examples of mutators from its manual:
Line 1393: Conditionals boundary—Relational operators such as < and <= are replaced by
Line 1394: other relational operators.
Line 1395: Increment—It replaces i++ with i-- and vice versa.
Line 1396: Invert negatives—It negates variables: for example, i becomes -i.
Line 1397: Math operators—It replaces mathematical operators: for example, a plus
Line 1398: becomes a minus.
Line 1399: True returns—It replaces entire boolean variables with true.
Line 1400: Remove conditionals—It replaces entire if statements with a simple if(true) {…}.
Line 1401: Running Pitest is simple, as it comes with plugins for Maven and Gradle. For example,
Line 1402: I ran it against the LeftPad implementation and tests we wrote earlier; figure 3.11
Line 1403: shows the resulting report. As in a code coverage report, a line’s background color
Line 1404: indicates whether all the mutants were killed by the test suite.
Line 1405:  The next step is to evaluate the surviving mutants. It is very important to analyze
Line 1406: each surviving mutant, as some may not be useful.
Line 1407:  Remember that mutation testing tools do not know your code—they simply mutate
Line 1408: it. This sometimes means they create mutants that are not useful. For example, in the
Line 1409: line that contains int pads = size - strLen, Pitest mutated the size variable to size++.
Line 1410: Our test suite does not catch this bug, but this is not a useful mutant: the size variable is
Line 1411: not used after this line, so incrementing it has no effect on the program.
Line 1412:  You should view mutation testing in the same way as coverage tools: it can augment
Line 1413: the test suite engineered based on the program’s requirements.
Line 1414: 
Line 1415: --- 페이지 120 ---
Line 1416: 92
Line 1417: CHAPTER 3
Line 1418: Structural testing and code coverage
Line 1419: Mutation testing faces various challenges in practice, including the cost. To use muta-
Line 1420: tion testing, we must generate many mutants and execute the whole test suite with
Line 1421: each one. This makes mutation testing quite expensive. Considerable research is ded-
Line 1422: icated to lowering the cost of mutation testing, such as reducing the number of
Line 1423: mutants to try, detecting equivalent mutants (mutants that are identical to the original
Line 1424: program in terms of behavior), and reducing the number of test cases or test case exe-
Line 1425: cutions (see the work of Ferrari, Pizzoleto, and Offutt, 2018). As a community, we are
Line 1426: taking steps toward a solution, but we are not there yet.
Line 1427:  Despite the cost, mutation testing is highly beneficial. In a very recent paper by
Line 1428: Parsai and Demeyer (2020), the authors demonstrate that mutation coverage reveals
Line 1429: additional weaknesses in the test suite compared to branch coverage and that it can
Line 1430: do so with an acceptable performance overhead during project build. Even large com-
Line 1431: panies like Google are investing in mutation testing in their systems, as reported by
Line 1432: Petrovic´ and Ivankovic´ (2018).
Line 1433:  Researchers are also exploring mutation testing in areas other than Java backend
Line 1434: code. Yandrapally and Mesbah (2021) propose mutations for the Document Object
Line 1435: Model (DOM) in HTML pages to assess whether web tests (which we discuss in
Line 1436: Figure 3.11
Line 1437: Part of a report generated by Pitest. Lines 26, 31, 32, 36, 38, 39, 43, and 44 have surviving mutants.
Line 1438: 
Line 1439: --- 페이지 121 ---
Line 1440: 93
Line 1441: Exercises
Line 1442: chapter 9) are strong enough. In addition, Tuya and colleagues (2006) proposed the
Line 1443: use of mutation in SQL queries.
Line 1444:  I suggest that you try to apply mutation testing, especially in more sensitive parts of
Line 1445: your system. While running mutation testing for the entire system can be expensive,
Line 1446: running it for a smaller set of classes is feasible and may give you valuable insights
Line 1447: about what else to test. 
Line 1448: Exercises
Line 1449: 3.1
Line 1450: Consider the following piece of code, which plays a game of Blackjack:
Line 1451: 01. public int play(int left, int right) {
Line 1452: 02.    int ln = left;
Line 1453: 03.    int rn = right;
Line 1454: 04.    if (ln > 21)
Line 1455: 05.        ln = 0;
Line 1456: 06.    if (rn > 21)
Line 1457: 07.        rn = 0;
Line 1458: 08.    if (ln > rn)
Line 1459: 09.        return ln;
Line 1460: 10.    else
Line 1461: 11.       return rn;
Line 1462: 12. }
Line 1463: What is the line coverage of a test where left=22 and right=21? In the calcula-
Line 1464: tion, disregard the lines with the function signature and the last curly bracket
Line 1465: (lines 1 and 12).
Line 1466: A 60%
Line 1467: B 80%
Line 1468: C 70%
Line 1469: D 100%
Line 1470: 3.2
Line 1471: Consider the following remove method:
Line 1472: public boolean remove(Object o) {
Line 1473:   if (o == null) {
Line 1474:     for (Node<E> x = first; x != null; x = x.next) {
Line 1475:       if (x.item == null) {
Line 1476:         unlink(x);
Line 1477:         return true;
Line 1478:       }
Line 1479:     }
Line 1480:   } else {
Line 1481:     for (Node<E> x = first; x != null; x = x.next) {
Line 1482:       if (o.equals(x.item)) {
Line 1483:         unlink(x);
Line 1484:         return true;
Line 1485:       }
Line 1486:     }
Line 1487:   }
Line 1488:   return false;
Line 1489: }
Line 1490: 
Line 1491: --- 페이지 122 ---
Line 1492: 94
Line 1493: CHAPTER 3
Line 1494: Structural testing and code coverage
Line 1495: This is the implementation of the Java Platform, Standard Edition 8 Develop-
Line 1496: ment Kit (JDK 8) LinkedList remove method.
Line 1497: Create a test suite (a set of tests) that achieves 100% line coverage. Use as few
Line 1498: tests as possible. Feel free to write them as JUnit tests or as a set of inputs and
Line 1499: expected outputs.
Line 1500: 3.3
Line 1501: Following is Java’s implementation of the LinkedList’s computeIfPresent()
Line 1502: method:
Line 1503: public V computeIfPresent(K key,
Line 1504: ➥ BiFunction<? super K, ? super V, ? extends V> rf) {
Line 1505:   if (rf == null) {
Line 1506:     throw new NullPointerException();
Line 1507:   }
Line 1508:   Node<K,V> e;
Line 1509:   V oldValue;
Line 1510:   int hash = hash(key);
Line 1511:   e = getNode(hash, key);
Line 1512:   oldValue = e.value;
Line 1513:   if (e != null && oldValue != null) {
Line 1514:     V v = rf.apply(key, oldValue);
Line 1515:     if (v != null) {
Line 1516:       e.value = v;
Line 1517:       afterNodeAccess(e);
Line 1518:       return v;
Line 1519:     } else {
Line 1520:       removeNode(hash, key, null, false, true);
Line 1521:     }
Line 1522:   }
Line 1523:   return null;
Line 1524: }
Line 1525: What is the minimum number of tests required to achieve 100% branch cover-
Line 1526: age?
Line 1527: A 2
Line 1528: B 3
Line 1529: C 4
Line 1530: D 6
Line 1531: 3.4
Line 1532: Consider the expression (A & B) | C with the following truth table:
Line 1533: Test case
Line 1534: A
Line 1535: B
Line 1536: C
Line 1537: (A & B) | C
Line 1538: 1
Line 1539: T
Line 1540: T
Line 1541: T
Line 1542: T
Line 1543: 2
Line 1544: T
Line 1545: T
Line 1546: F
Line 1547: T
Line 1548: 3
Line 1549: T
Line 1550: F
Line 1551: T
Line 1552: T
Line 1553: 
Line 1554: --- 페이지 123 ---
Line 1555: 95
Line 1556: Exercises
Line 1557: What test suite(s) achieve 100% MC/DC? The numbers correspond to the test
Line 1558: case column in the truth table. Select all that apply.
Line 1559: A {2, 3, 4, 6}
Line 1560: B {2, 4, 5, 6}
Line 1561: C {1, 3, 4, 6}
Line 1562: D {3, 4, 5, 8}
Line 1563: 3.5
Line 1564: Draw the truth table for the expression A && (A || B).
Line 1565: Is it possible to achieve MC/DC coverage for this expression? Why or why not?
Line 1566: What would you tell the developer who wrote this expression?
Line 1567: 3.6
Line 1568: Consider the following method:
Line 1569: public String sameEnds(String string) {
Line 1570:   int length = string.length();
Line 1571:   int half = length / 2;
Line 1572:   String left = "";
Line 1573:   String right = "";
Line 1574:   int size = 0;
Line 1575:   for (int i = 0; i < half; i++) {
Line 1576:     left = left + string.charAt(i);
Line 1577:     right = string.charAt(length - 1 - i) + right;
Line 1578:     if (left.equals(right)) {
Line 1579:       size = left.length();
Line 1580:     }
Line 1581:   }
Line 1582:   return string.substring(0, size);
Line 1583: }
Line 1584: Which of the following statements is not correct?
Line 1585: A It is possible to devise a single test case that achieves 100% line coverage
Line 1586: and 100% decision coverage.
Line 1587: B It is possible to devise a single test case that achieves 100% line coverage
Line 1588: and 100% (basic) condition coverage.
Line 1589: 4
Line 1590: T
Line 1591: F
Line 1592: F
Line 1593: F
Line 1594: 5
Line 1595: F
Line 1596: T
Line 1597: T
Line 1598: T
Line 1599: 6
Line 1600: F
Line 1601: T
Line 1602: F
Line 1603: F
Line 1604: 7
Line 1605: F
Line 1606: F
Line 1607: T
Line 1608: T
Line 1609: 8
Line 1610: F
Line 1611: F
Line 1612: F
Line 1613: F
Line 1614: Test case
Line 1615: A
Line 1616: B
Line 1617: C
Line 1618: (A & B) | C
Line 1619: 
Line 1620: --- 페이지 124 ---
Line 1621: 96
Line 1622: CHAPTER 3
Line 1623: Structural testing and code coverage
Line 1624: C It is possible to devise a single test case that achieves 100% line coverage
Line 1625: and 100% decision + condition coverage.
Line 1626: D It is possible to devise a single test case that achieves 100% line coverage
Line 1627: and 100% path coverage.
Line 1628: 3.7
Line 1629: Which of the following statements concerning the subsumption relations between
Line 1630: test adequacy criteria is true?
Line 1631: A MC/DC subsumes statement coverage.
Line 1632: B Statement coverage subsumes branch coverage.
Line 1633: C Branch coverage subsumes path coverage.
Line 1634: D Basic condition coverage subsumes branch coverage.
Line 1635: 3.8
Line 1636: A test suite satisfies the loop boundary adequacy criterion if for every loop L:
Line 1637: A Test cases iterate L zero times, once, and more than once.
Line 1638: B Test cases iterate L once and more than once.
Line 1639: C Test cases iterate L zero times and one time.
Line 1640: D Test cases iterate L zero times, once, more than once, and N, where N is
Line 1641: the maximum number of iterations.
Line 1642: 3.9
Line 1643: Which of the following statements is correct about the relationship between
Line 1644: specification-based testing and structural testing?
Line 1645: A A testing process should prioritize structural testing because it’s cheaper yet
Line 1646: highly effective (maybe even more effective than specification-based testing).
Line 1647: B Specification-based testing can only be effectively performed when we have
Line 1648: proper models of the program under test. A simple user story is not enough.
Line 1649: C Boundary analysis can only be done if testers have access to the source
Line 1650: code, and thus it should be considered a structural testing technique.
Line 1651: D None of the other answers is true.
Line 1652: Summary
Line 1653: Structural testing uses the source code to augment the test suite engineered via
Line 1654: specification-based testing.
Line 1655: The overall idea of structural testing is to analyze which parts of the code are
Line 1656: not yet covered and reflect on whether they should be covered or not.
Line 1657: Some coverage criteria are less rigorous and therefore less expensive (for exam-
Line 1658: ple, line coverage). Others are more rigorous but also more expensive (such as
Line 1659: MC/DC coverage). As a developer, you have to decide which criteria to use.
Line 1660: Code coverage should not be used as a number to be achieved. Rather, cover-
Line 1661: age tools should be used to support developers in performing structural testing
Line 1662: (that is, understanding what parts are not covered and why).
Line 1663: Mutation testing ensures that our test suite is strong enough: in other words,
Line 1664: that it can catch as many bugs as possible.