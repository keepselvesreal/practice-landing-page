# 4장: 계약 설계 - 추출된 정보

## 핵심 내용
- 명확한 계약(전제조건·사후조건·불변식)이 클래스 간 상호작용을 안전하게 만든다.
- 계약은 방어적 프로그래밍을 체계화해 예외 상황을 즉시 드러내고 디버깅 비용을 줄인다.
- 계약 강도(강한/약한) 선택은 클라이언트 편의성 vs 내부 복잡도 간의 트레이드오프다.
- 상속 시 LSP를 지키려면 하위 타입의 전제조건은 약화, 사후조건은 강화해야 한다.
- 입력 검증과 계약은 목적이 다르며, 두 접근을 함께 활용해야 전체 품질이 확보된다.

## 상세 핵심 내용

### 전제조건과 사후조건 설계
- `TaxCalculator` 사례로 음수 입력 차단(전제조건), 음수 결과 방지(사후조건)를 구현.
- `assert` vs `if-throw` 선택은 실행 환경·예외 처리 전략·도구 지원에 따라 결정.
- 강한 전제조건은 호출자에게 부담을 주지만 내부 구현을 단순화하고, 약한 전제조건은 반대로 동작.

### 불변식 정의와 유지
- `Basket` 클래스는 총액이 항상 0 이상이어야 한다는 불변식을 다양한 메서드에서 보장.
- 불변식 검증 코드를 공통 메서드(`invariant()`)로 추출해 중복을 줄이고 가독성 향상.
- 메서드 실행 중 일시적 위반은 허용되지만 종료 시 불변식이 회복되어야 한다.

### 계약 변경과 영향 분석
- 전제조건을 강화하면 기존 클라이언트가 깨질 수 있고, 약화하면 호환성을 유지.
- 사후조건은 반대로 강화하면 안전, 약화하면 예상치 못한 동작 발생 가능.
- 계약 변경 시 의존 클래스, 데이터 흐름 전체를 검토해 회귀 테스트와 문서 갱신 필요.

### 상속과 LSP
- 하위 클래스는 전제조건을 더 엄격하게 만들면 안 되며, 사후조건은 최소한 기존 보장을 유지해야 함.
- LSP 위반은 예외/계약 실패로 이어지므로 상속 설계 시 계약 일관성 검토가 필수.

### 계약과 테스트의 시너지
- 계약 위반은 즉각적인 실패로 이어져 버그 발견 시점을 앞당긴다.
- 계약은 테스트 아이디어(전제 위반 케이스, 사후 보장 검증, 불변식 유지 등)를 제공한다.
- 단, 계약만으로 기능 요구사항 전체를 표현할 수 없으므로 테스트는 필수.

### 현실 적용 지침
- 강/약 계약 선택은 라이브러리 vs 애플리케이션, 호출자 다양성, 오류 회복 전략을 고려.
- 입력 검증(사용자 지향)과 계약(클래스 간 프로토콜)은 목적이 다르므로 중복이라 느껴도 둘 다 필요.
- 예외 대신 “soft return”을 사용해야 하는 상황(예: `trim` 유틸리티)은 클라이언트 경험을 기준으로 판단.
- assertions는 단위 테스트 작성 없이도 내부 보호막이지만, 실행 환경에서 비활성화될 수 있음을 염두.

## 상세 내용

### 도구와 언어 기능
- Java `assert`, JSR-305/IntelliJ 어노테이션, Bean Validation 등 계약 구현을 보조하는 도구를 소개.
- 일부 커버리지 도구가 assert 분기를 제대로 인식하지 못하므로 지표 해석 시 주의.

### 계약 vs 검증 비교
- 웹 폼 입력 검증 예시를 통해 사용자 피드백 제공 흐름과 계약 위반 시 시스템 동작(즉시 실패)을 대비.
- Specification 패턴 등 복잡한 검증 로직 추상화 기법을 추천.

### 테스트 전략
- 전제조건 위반에 대한 단위 테스트는 제한적으로 작성하며, 대부분의 계약은 일반 기능 테스트로 자동 검증됨.
- 계약을 기반으로 하는 퍼징/프로퍼티 테스트(5장)와의 연계성을 강조.

### 예외 설계
- 도메인 의미가 담긴 커스텀 예외(`NegativeValueException`)로 오류 원인을 명확화하는 방안을 제안.
- 예외 vs 에러 코드 선택 시 모니터링, 회복 가능성, 호출자 행동을 고려해야 한다.

## 주요 화제

### 1. 계약 구성요소
- 전제조건, 사후조건, 불변식의 정의와 구현 패턴.

### 2. 계약 변경 영향
- 계약 강도 조정, 리팩터링, 상속 시 LSP 준수 등 변경 관리 전략.

### 3. 계약과 품질 보증
- 테스트, 모니터링, 디버깅과의 관계 및 협력 구조.

### 4. 실무 적용 팁
- 입력 검증 분리, soft return, assert 비활성화 대응, 도구 활용 등 실용적 권장 사항.

## 부차 화제

### 1. 방어적 프로그래밍과의 관계
- 단순 if-throw도 계약 사고방식의 일부로 간주하며, 용어적 순수성보다 실용성을 중시.

### 2. 퍼징·동적 분석 연계
- 명시적 계약이 퍼징 도구의 오라클 역할을 수행함을 언급.

### 3. 문서화 관행
- Javadoc에 계약을 명시해 호출자 기대치를 공유하는 방법.

### 4. 검증 로직 구조화
- 다단계 오류 수집, 재사용 가능한 검증 컴포넌트 설계 권장.

### 5. 교육·참고 자료
- Meyer의 디자인 바이 계약, Liskov & Wing 논문, Regehr 글, Evans의 Specification 패턴 등 참고 리소스.
