# 6장: 테스트 대역과 목 - 추출된 정보

## 핵심 내용
- 외부 의존관계를 제어하기 위해 더블(더미, 페이크, 스텁, 스파이, 목)을 활용해 단위 테스트를 고립시킨다.
- Mockito 등 목킹 프레임워크는 의존성 행위 정의(stub)와 상호작용 검증(verify)을 간결하게 지원한다.
- 목 사용 시 의존성 주입, 계약 안정성, 테스트 가독성 등을 고려해 설계를 조정해야 한다.
- 실제 환경과 괴리, 계약 변경 미감지 등 목의 단점도 이해하고, 무엇을 목킹할지 명확한 원칙을 세운다.
- 목킹이 어려운 요소(시간, 정적/파이널, 생성자 내부 new 등)는 래핑·팩토리·인터페이스 추상화 등으로 해결한다.

## 상세 핵심 내용

### 테스트 더블 유형
- `더미`: 객체 구조만 맞추고 사용하지 않는 자리 채움.
- `페이크`: 단순한 실제 구현을 제공(예: 인메모리 DB)하여 전체 시스템을 대체.
- `스텁`: 하드코딩된 반환값으로 흐름을 진행시키는 가장 흔한 더블.
- `목`: 스텁 기능에 더해 호출 횟수·인자 등 상호작용을 검증.
- `스파이`: 실제 객체를 감싸 호출 기록만 수집, 현실 구현이 편할 때 사용.

### Mockito 기반 실습 흐름
- `mock()`, `when(...).thenReturn(...)`, `verify()` 조합으로 기본 stubbing 및 검증.
- `doThrow`, `doAnswer`, `ArgumentCaptor`, `thenReturn` 체이닝 등 고급 기능으로 예외, 콜백, 전달값 검사 구현.
- 의존성 주입(DI)을 위해 생산 코드에서 new 제거, 생성자/세터로 더블 주입하도록 리팩터링.
- 복잡한 시나리오(예: 청구서 필터, SAP 전송)에서 DB/외부 시스템 의존성을 목으로 대체해 빠른 테스트 구성.

### 목 사용 시 주의점과 베스트 프랙티스
- 단점: 계약 변경 미반영, 테스트-구현 결합도 증가, 지나친 상호작용 검증으로 의도치 않은 실패 가능.
- 장점: 예외·시간·외부 시스템·느린 I/O를 손쉽게 재현, 상호작용 자체가 요구사항인 경우 검증 가능.
- 원칙: 
  1) 느리고 복잡한 외부 자원(DB, 메시지 큐, 웹서비스) 
  2) 협력 객체(서비스, 도메인 프로세스) 
  3) 시간·랜덤·ID 등 제어하기 힘든 값에 우선 적용.
- 반대로 단순 값 객체, 언어 기본 라이브러리, 가벼운 도메인 엔티티는 모의하지 않는 것이 일반적.

### 현실 문제 해결
- 생성자 내부 `new`: 팩토리·DI 컨테이너·빌더로 추상화해 교체 가능하게 한다.
- 정적/파이널/싱글톤: 래핑, 어댑터, 인터페이스 추출로 간접화하거나 PowerMock 같은 도구 고려(필요 최소화 권장).
- 시계/UUID/난수: `Clock`, `IdGenerator` 등 인터페이스 도입 후 스텁/목으로 제어.
- 데이터 파이프라인: 인메모리 페이크(예: HSQLDB)와 목을 조합해 속도를 확보.

### 목 설계와 계약 관리
- 계약(전제조건·사후조건)이 안정적일수록 목 테스트가 안전하다; 변경 시 의존 모듈 점검 필요.
- 상호작용 검증은 “행동 자체가 요구사항일 때” 제한적으로 사용하고, 대부분은 결과 검증을 선호.
- 테스트 헬퍼/빌더를 도입해 목 설정 반복을 줄이고 가독성을 높인다.

## 상세 내용

### 리팩터링과 테스트 용이성
- 의존성 주입을 통해 테스트 가능성을 확보하고, 테스트 전용 생성자/팩토리를 추가하는 것이 허용됨을 강조.
- 목 도입으로 발견되는 설계 향상 기회(DI, 인터페이스 분리, 명확한 책임 분배)를 소개.

### 상호작용 기반 테스트 예제
- SAP 전송 서비스: 성공/실패 케이스, 예외 발생 시에도 다음 작업을 이어가는지 검증.
- BookStore: 재고 확인·구매 프로세스를 목킹, 가용 수량 부족 시 로직과 알림을 검증.

### 조직적 고려사항
- 팀 내 목 사용 지침 합의, 지나친 목 의존으로 인한 유지보수 비용 관리.
- 대규모 코드베이스에서는 계약 문서화와 변경 알림 체계를 갖춰 목과 실제 구현의 괴리를 최소화.

## 주요 화제

### 1. 테스트 더블 분류와 사용 사례
- 더미/페이크/스텁/목/스파이 정의, 장단점, 적용 상황.

### 2. Mockito 기능 활용
- 기본 API, 예외/콜백 핸들링, ArgumentCaptor 등 실전 패턴.

### 3. 목 사용 원칙과 판단 기준
- 무엇을 목킹할지/말지, 계약 안정성과 현실성 사이 균형.

### 4. 설계 개선과 목킹 난제 해결
- DI, 추상화, 시간/정적 의존성 래핑 등 테스트 친화적 구조 설계.

## 부차 화제

### 1. 인메모리 대체(페이크 DB)
- HSQLDB 등 사용 시점과 통합 테스트(9장)와의 연계.

### 2. 테스트 코드 품질
- 헬퍼 추출, 중복 제거, AssertJ 활용 등 테스트 유지보수 팁.

### 3. 연구 결과 인용
- 실제 프로젝트에서의 목 사용 패턴(Spadini et al.)과 커뮤니티 논쟁을 소개.

### 4. Mock이 힘든 API 대응
- PowerMock 등 특수 도구 언급, 다만 과도한 사용 경고.

### 5. 상호작용 vs 상태 검증 철학
- 결과 중심 테스트와 행동 검증 테스트의 역할 분담을 비교.
