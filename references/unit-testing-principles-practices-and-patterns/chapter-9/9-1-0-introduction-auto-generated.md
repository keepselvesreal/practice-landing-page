# 9.1.0 Introduction [auto-generated] (pp.217-219)

---
**Page 217**

217
Maximizing mocks’ value
9.1
Maximizing mocks’ value
It’s important to limit the use of mocks to unmanaged dependencies, but that’s only
the first step on the way to maximizing the value of mocks. This topic is best explained
with an example, so I’ll continue using the CRM system from earlier chapters as a sam-
ple project. I’ll remind you of its functionality and show the integration test we ended
up with. After that, you’ll see how that test can be improved with regard to mocking.
 As you might recall, the CRM system currently supports only one use case: chang-
ing a user’s email. The following listing shows where we left off with the controller.
public class UserController
{
private readonly Database _database;
private readonly EventDispatcher _eventDispatcher;
public UserController(
Database database,
IMessageBus messageBus,
IDomainLogger domainLogger)
{
_database = database;
_eventDispatcher = new EventDispatcher(
messageBus, domainLogger);
}
public string ChangeEmail(int userId, string newEmail)
{
object[] userData = _database.GetUserById(userId);
User user = UserFactory.Create(userData);
string error = user.CanChangeEmail();
if (error != null)
return error;
object[] companyData = _database.GetCompany();
Company company = CompanyFactory.Create(companyData);
user.ChangeEmail(newEmail, company);
_database.SaveCompany(company);
_database.SaveUser(user);
_eventDispatcher.Dispatch(user.DomainEvents);
return "OK";
}
}
Note that there’s no longer any diagnostic logging, but support logging (the IDomain-
Logger interface) is still in place (see chapter 8 for more details). Also, listing 9.1
introduces a new class: the EventDispatcher. It converts domain events generated by
Listing 9.1
User controller


---
**Page 218**

218
CHAPTER 9
Mocking best practices
the domain model into calls to unmanaged dependencies (something that the control-
ler previously did by itself), as shown next.
public class EventDispatcher
{
private readonly IMessageBus _messageBus;
private readonly IDomainLogger _domainLogger;
public EventDispatcher(
IMessageBus messageBus,
IDomainLogger domainLogger)
{
_domainLogger = domainLogger;
_messageBus = messageBus;
}
public void Dispatch(List<IDomainEvent> events)
{
foreach (IDomainEvent ev in events)
{
Dispatch(ev);
}
}
private void Dispatch(IDomainEvent ev)
{
switch (ev)
{
case EmailChangedEvent emailChangedEvent:
_messageBus.SendEmailChangedMessage(
emailChangedEvent.UserId,
emailChangedEvent.NewEmail);
break;
case UserTypeChangedEvent userTypeChangedEvent:
_domainLogger.UserTypeHasChanged(
userTypeChangedEvent.UserId,
userTypeChangedEvent.OldType,
userTypeChangedEvent.NewType);
break;
}
}
}
Finally, the following listing shows the integration test. This test goes through all out-
of-process dependencies (both managed and unmanaged).
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
Listing 9.2
Event dispatcher
Listing 9.3
Integration test


---
**Page 219**

219
Maximizing mocks’ value
// Arrange
var db = new Database(ConnectionString);
User user = CreateUser("user@mycorp.com", UserType.Employee, db);
CreateCompany("mycorp.com", 1, db);
var messageBusMock = new Mock<IMessageBus>();   
var loggerMock = new Mock<IDomainLogger>();     
var sut = new UserController(
db, messageBusMock.Object, loggerMock.Object);
// Act
string result = sut.ChangeEmail(user.UserId, "new@gmail.com");
// Assert
Assert.Equal("OK", result);
object[] userData = db.GetUserById(user.UserId);
User userFromDb = UserFactory.Create(userData);
Assert.Equal("new@gmail.com", userFromDb.Email);
Assert.Equal(UserType.Customer, userFromDb.Type);
object[] companyData = db.GetCompany();
Company companyFromDb = CompanyFactory.Create(companyData);
Assert.Equal(0, companyFromDb.NumberOfEmployees);
messageBusMock.Verify(
  
x => x.SendEmailChangedMessage(
  
user.UserId, "new@gmail.com"),  
Times.Once);
  
loggerMock.Verify(
  
x => x.UserTypeHasChanged(
  
user.UserId,
  
UserType.Employee,
  
UserType.Customer),
  
Times.Once);
  
}
This test mocks out two unmanaged dependencies: IMessageBus and IDomainLogger.
I’ll focus on IMessageBus first. We’ll discuss IDomainLogger later in this chapter.
9.1.1
Verifying interactions at the system edges
Let’s discuss why the mocks used by the integration test in listing 9.3 aren’t ideal in
terms of their protection against regressions and resistance to refactoring and how we
can fix that.
TIP
When mocking, always adhere to the following guideline: verify interac-
tions with unmanaged dependencies at the very edges of your system.
The problem with messageBusMock in listing 9.3 is that the IMessageBus interface
doesn’t reside at the system’s edge. Look at that interface’s implementation.
 
Sets up the 
mocks
Verifies the 
interactions 
with the mocks


