# 9.0 Introduction [auto-generated] (pp.216-217)

---
**Page 216**

216
Mocking best practices
As you might remember from chapter 5, a mock is a test double that helps to emu-
late and examine interactions between the system under test and its dependencies.
As you might also remember from chapter 8, mocks should only be applied to
unmanaged dependencies (interactions with such dependencies are observable by
external applications). Using mocks for anything else results in brittle tests (tests that
lack the metric of resistance to refactoring). When it comes to mocks, adhering to
this one guideline will get you about two-thirds of the way to success.
 This chapter shows the remaining guidelines that will help you develop inte-
gration tests that have the greatest possible value by maxing out mocks’ resistance
to refactoring and protection against regressions. I’ll first show a typical use of
mocks, describe its drawbacks, and then demonstrate how you can overcome
those drawbacks.
This chapter covers
Maximizing the value of mocks
Replacing mocks with spies
Mocking best practices


---
**Page 217**

217
Maximizing mocks’ value
9.1
Maximizing mocks’ value
It’s important to limit the use of mocks to unmanaged dependencies, but that’s only
the first step on the way to maximizing the value of mocks. This topic is best explained
with an example, so I’ll continue using the CRM system from earlier chapters as a sam-
ple project. I’ll remind you of its functionality and show the integration test we ended
up with. After that, you’ll see how that test can be improved with regard to mocking.
 As you might recall, the CRM system currently supports only one use case: chang-
ing a user’s email. The following listing shows where we left off with the controller.
public class UserController
{
private readonly Database _database;
private readonly EventDispatcher _eventDispatcher;
public UserController(
Database database,
IMessageBus messageBus,
IDomainLogger domainLogger)
{
_database = database;
_eventDispatcher = new EventDispatcher(
messageBus, domainLogger);
}
public string ChangeEmail(int userId, string newEmail)
{
object[] userData = _database.GetUserById(userId);
User user = UserFactory.Create(userData);
string error = user.CanChangeEmail();
if (error != null)
return error;
object[] companyData = _database.GetCompany();
Company company = CompanyFactory.Create(companyData);
user.ChangeEmail(newEmail, company);
_database.SaveCompany(company);
_database.SaveUser(user);
_eventDispatcher.Dispatch(user.DomainEvents);
return "OK";
}
}
Note that there’s no longer any diagnostic logging, but support logging (the IDomain-
Logger interface) is still in place (see chapter 8 for more details). Also, listing 9.1
introduces a new class: the EventDispatcher. It converts domain events generated by
Listing 9.1
User controller


