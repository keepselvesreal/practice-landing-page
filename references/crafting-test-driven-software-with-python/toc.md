# Cover (p.Cover)

# Title Page (p.FM1)

# Copyright and Credits (p.FM2)

# Dedication (p.FM3)

# Contributors (p.FM4)

# Table of Contents (p.i)

# Preface (p.1)

# Section 1: Software Testing and Test-Driven Development (p.5)

## 1. Chapter 1: Getting Started with Software Testing (p.6)

### 1.0 Introduction [auto-generated] (p.6)

### 1.1 Technical requirements (p.7)

### 1.2 Introducing software testing and quality control (p.7)

#### 1.2.0 Introduction [auto-generated] (p.7)

#### 1.2.1 Test plans (p.8)

### 1.3 Introducing automatic tests and test suites (p.9)

#### 1.3.0 Introduction [auto-generated] (p.9)

#### 1.3.1 Multiple test cases (p.11)

#### 1.3.2 Organizing tests (p.13)

### 1.4 Introducing test-driven development and unit tests (p.15)

#### 1.4.0 Introduction [auto-generated] (p.15)

#### 1.4.1 Test-driven development (p.16)

#### 1.4.2 Test units (p.19)

### 1.5 Understanding integration and functional tests (p.21)

#### 1.5.0 Introduction [auto-generated] (p.21)

#### 1.5.1 Integration tests (p.22)

#### 1.5.2 Functional tests (p.25)

### 1.6 Understanding the testing pyramid and trophy (p.26)

#### 1.6.0 Introduction [auto-generated] (p.26)

#### 1.6.1 The testing pyramid (p.27)

#### 1.6.2 The testing trophy (p.28)

#### 1.6.3 Testing distribution and coverage (p.29)

### 1.7 Summary (p.30)

## 2. Chapter 2: Test Doubles with a Chat Application (p.31)

### 2.0 Introduction [auto-generated] (p.31)

### 2.1 Technical requirements (p.32)

### 2.2 Introducing test doubles (p.32)

### 2.3 Starting our chat application with TDD (p.33)

### 2.4 Using dummy objects (p.38)

### 2.5 Replacing components with stubs (p.40)

### 2.6 Checking behaviors with spies (p.44)

### 2.7 Using mocks (p.49)

### 2.8 Replacing dependencies with fakes (p.51)

### 2.9 Understanding acceptance tests and doubles (p.56)

### 2.10 Managing dependencies with dependency injection (p.60)

#### 2.10.0 Introduction [auto-generated] (p.60)

#### 2.10.1 Using dependency injection frameworks (p.63)

### 2.11 Summary (p.66)

## 3. Chapter 3: Test-Driven Development while Creating a TODO List (p.67)

### 3.0 Introduction [auto-generated] (p.67)

### 3.1 Technical requirements (p.68)

### 3.2 Starting projects with TDD (p.68)

### 3.3 Building applications the TDD way (p.83)

### 3.4 Preventing regressions (p.105)

### 3.5 Summary (p.113)

## 4. Chapter 4: Scaling the Test Suite (p.114)

### 4.1 Technical requirements (p.114)

### 4.2 Scaling tests (p.115)

#### 4.2.0 Introduction [auto-generated] (p.115)

#### 4.2.1 Moving from e2e to functional (p.122)

### 4.3 Working with multiple suites (p.125)

#### 4.3.1 Compile suite (p.125)

#### 4.3.2 Commit tests (p.126)

#### 4.3.3 Smoke tests (p.127)

### 4.4 Carrying out performance testing (p.128)

### 4.5 Enabling continuous integration (p.131)

#### 4.5.0 Introduction [auto-generated] (p.131)

#### 4.5.1 Performance testing in the cloud (p.136)

### 4.6 Summary (p.136)

# Section 2: PyTest for Python Testing (p.137)

## 5. Chapter 5: Introduction to PyTest (p.138)

### 5.1 Technical requirements (p.138)

### 5.2 Running tests with PyTest (p.139)

### 5.3 Writing PyTest fixtures (p.142)

#### 5.3.0 Introduction [auto-generated] (p.142)

#### 5.3.1 Using fixtures for dependency injection (p.146)

### 5.4 Managing temporary data with tmp_path (p.148)

### 5.5 Testing I/O with capsys (p.149)

### 5.6 Running subsets of the testsuite (p.150)

### 5.7 Summary (p.151)

## 6. Chapter 6: Dynamic and Parametric Tests and Fixtures (p.152)

### 6.1 Technical requirements (p.152)

### 6.2 Configuring the test suite (p.153)

### 6.3 Generating fixtures (p.156)

### 6.4 Generating tests with parametric tests (p.160)

### 6.5 Summary (p.162)

## 7. Chapter 7: Fitness Function with a Contact Book Application (p.164)

### 7.0 Introduction [auto-generated] (p.164)

### 7.1 Technical requirements (p.165)

### 7.2 Writing acceptance tests (p.165)

#### 7.2.0 Introduction [auto-generated] (p.165)

#### 7.2.1 Writing the first test (p.166)

#### 7.2.2 Getting feedback from the product team (p.167)

#### 7.2.3 Making the test pass (p.169)

### 7.3 Using behavior-driven development (p.172)

#### 7.3.0 Introduction [auto-generated] (p.172)

#### 7.3.1 Defining a feature file (p.173)

#### 7.3.2 Declaring the scenario (p.174)

#### 7.3.3 Running the scenario test (p.175)

#### 7.3.4 Further setup with the And step (p.175)

#### 7.3.5 Performing actions with the When step (p.176)

#### 7.3.6 Assessing conditions with the Then step (p.177)

#### 7.3.7 Making the scenario pass (p.178)

### 7.4 Embracing specifications by example (p.180)

### 7.5 Summary (p.187)

## 8. Chapter 8: PyTest Essential Plugins (p.188)

### 8.0 Introduction [auto-generated] (p.188)

### 8.1 Technical requirements (p.189)

### 8.2 Using pytest-cov for coverage reporting (p.189)

#### 8.2.0 Introduction [auto-generated] (p.189)

#### 8.2.1 Coverage as a service (p.194)

### 8.3 Using pytest-benchmark for benchmarking (p.196)

#### 8.3.0 Introduction [auto-generated] (p.196)

#### 8.3.1 Comparing benchmark runs (p.198)

### 8.4 Using flaky to rerun unstable tests (p.199)

### 8.5 Using pytest-testmon to rerun tests on code changes (p.202)

### 8.6 Running tests in parallel with pytest-xdist (p.204)

### 8.7 Summary (p.206)

## 9. Chapter 9: Managing Test Environments with Tox (p.207)

### 9.1 Technical requirements (p.207)

### 9.2 Introducing Tox (p.208)

### 9.3 Testing multiple Python versions with Tox (p.211)

#### 9.3.0 Introduction [auto-generated] (p.211)

#### 9.3.1 Using environments for more than Python versions (p.213)

### 9.4 Using Tox with Travis (p.215)

### 9.5 Summary (p.219)

## 10. Chapter 10: Testing Documentation and Property-Based Testing (p.220)

### 10.1 Technical requirements (p.220)

### 10.2 Testing documentation (p.221)

#### 10.2.0 Introduction [auto-generated] (p.221)

#### 10.2.1 Adding a code-based reference (p.223)

#### 10.2.2 Writing a verified user guide (p.226)

### 10.3 Property-based testing (p.231)

#### 10.3.0 Introduction [auto-generated] (p.231)

#### 10.3.1 Generating tests for common properties (p.237)

### 10.4 Summary (p.240)

# Section 3: Testing for the Web (p.241)

## 11. Chapter 11: Testing for the Web: WSGI versus HTTP (p.242)

### 11.0 Introduction [auto-generated] (p.242)

### 11.1 Technical requirements (p.243)

### 11.2 Testing HTTP (p.243)

#### 11.2.0 Introduction [auto-generated] (p.243)

#### 11.2.1 Testing HTTP clients (p.247)

### 11.3 Testing WSGI with WebTest (p.252)

### 11.4 Using WebTest with web frameworks (p.261)

### 11.5 Writing Django tests with Django's test client (p.271)

#### 11.5.0 Introduction [auto-generated] (p.271)

#### 11.5.1 Testing Django projects with pytest (p.274)

#### 11.5.2 Testing Django projects with Django's test client (p.277)

### 11.6 Summary (p.280)

## 12. Chapter 12: End-to-End Testing with the Robot Framework (p.281)

### 12.0 Introduction [auto-generated] (p.281)

### 12.1 Technical requirements (p.282)

### 12.2 Introducing the Robot Framework (p.282)

### 12.3 Testing with web browsers (p.286)

#### 12.3.0 Introduction [auto-generated] (p.286)

#### 12.3.1 Recording the execution of tests (p.291)

#### 12.3.2 Testing with headless browsers (p.295)

#### 12.3.3 Testing multiple browsers (p.297)

### 12.4 Extending the Robot Framework (p.300)

#### 12.4.0 Introduction [auto-generated] (p.300)

#### 12.4.1 Adding custom keywords (p.301)

#### 12.4.2 Extending Robot from Python (p.302)

### 12.5 Summary (p.305)

# About Packt (p.306)

# Other Books You May Enjoy (p.307)

# Index (p.310)