# Chapter 1: 테스트와 도구 - 추출된 정보

## 핵심 내용
- 개발자 테스트의 세 가지 주요 유형: Unit Tests, Integration Tests, End-to-End Tests
- 객체지향 시스템에서 테스트의 역할과 범위
- SUT(System Under Test)와 DOC(Depended On Component) 개념
- 검증자(Verifier)와 설계자(Designer) 두 가지 테스트 접근법

## 상세 핵심 내용

### 테스트 유형 분류
- **Unit Tests**: 단일 클래스에 집중, 모든 협력자를 테스트 더블로 대체, 빠른 실행
- **Integration Tests**: 서로 다른 모듈의 통합 테스트, 제3자 라이브러리와의 연동 검증
- **End-to-End Tests**: 사용자 관점에서 전체 시스템 검증, 모든 계층을 거쳐 테스트

### 객체지향 시스템 구조
- **Workers**: 실제 업무를 수행하는 클래스들 (예: ORM, DI 컨테이너, 로깅 프레임워크)
- **Managers**: 메시지를 전달하고 다른 객체들의 작업을 조정하는 클래스들
- 대부분의 커스텀 클래스는 매니저 역할을 수행

### SUT와 DOC 개념
- **SUT (System Under Test)**: 테스트 대상이 되는 시스템 부분
- **DOC (Depended On Component)**: SUT가 업무 수행을 위해 필요로 하는 엔티티
- 테스트 유형에 따라 SUT와 DOC의 세분성(granularity)이 달라짐

## 상세 내용

### 테스트 범위 비교
| 테스트 유형 | SUT 예시 | DOC 예시 | 실행 속도 | 격리 수준 |
|-------------|----------|----------|-----------|-----------|
| Unit Test | UserService, Invoice, Client | UserDAO, Product, Account | 매우 빠름 | 완전 격리 |
| Integration Test | DAO layer, FullTextIndexer module | Hibernate, MySQL, FileStorage module | 보통 | 부분 격리 |
| End-to-End Test | 전체 애플리케이션 | External web services, LDAP repository | 느림 | 격리 없음 |

### 테스트 접근법: 검증자 vs 설계자

#### 검증자(Verifier) 접근법
- **목표**: 코드가 동작하는지 확인하는 것이 최우선
- **방법론**: 테스트하기 어려운 코드에 대해 모든 가능한 기술 활용
- **도구**: 리플렉션, 클래스로딩 해킹 등을 통해 private 메서드나 final 클래스도 테스트
- **철학**: "이미 진흙 속에서 헤엄치고 있다면 더러워지는 것을 두려워하지 않는다"

#### 설계자(Designer) 접근법
- **목표**: 객체지향 원칙 준수가 최우선, 테스트를 코드 건강성의 지표로 활용
- **방법론**: 테스트 작성의 어려움을 코드 개선이 필요한 신호로 해석
- **도구**: 프로덕션 코드와 동일한 기법 사용, 해킹 기법 거부
- **철학**: TDD를 선호하며, 레거시 코드는 리팩터링을 통해 테스트 가능하게 변경

### 개발자 자체 테스트의 필요성
- **비용 효율성**: 버그를 조기에 발견할수록 수정 비용이 현저히 감소
- **품질 향상**: 개발팀이 고객에게 전달하는 소프트웨어 품질 개선
- **신뢰도 증진**: 팀의 코드에 대한 신뢰와 자부심 향상
- **연속 배포**: Facebook, WordPress 등은 자동화된 테스트만으로 배포 결정

## 주요 화제

### 1. 테스트 유형별 특성과 용도
- 각 테스트 유형의 고유한 역할과 가치
- 계층별 테스트 범위와 실행 방식의 차이
- 테스트 더블 사용 빈도와 패턴

### 2. 객체지향 시스템의 테스트 전략
- Workers와 Managers의 구분과 테스트 접근법 차이
- 메시지 전달 중심의 협력 구조
- 비즈니스 로직의 실제 비중과 재사용 컴포넌트 활용

### 3. 테스트 도구와 프레임워크
- **JUnit 5.3.1**: Java 표준 테스트 프레임워크
- **Mockito 2.23.0**: Java 모킹 프레임워크의 사실상 표준
- **AssertJ 3.11.1**: 가독성 높은 유창한 assertion 라이브러리

### 4. 테스트 철학과 접근법
- 검증 중심 vs 설계 중심 접근법의 장단점
- 도구 선택이 테스트 철학에 미치는 영향
- TDD와 코드 품질의 상관관계

## 부차 화제

### 1. 테스트 명명법의 혼재
- 동일한 용어에 대한 다양한 정의들의 존재
- 테스트 분류 체계의 복잡성과 혼란
- 책에서 채택한 용어 정의의 근거

### 2. 도구별 특성과 선택 기준
- **코드 커버리지**: Cobertura 1.9.4.1
- **강력한 모킹**: PowerMock (static, final 클래스 모킹)
- **변이 테스트**: PIT 1.4.3
- **비동기 테스트**: Awaitility 1.7.0
- **빌드 도구**: Maven, Gradle
- **IDE**: IntelliJ IDEA, Eclipse

### 3. 레거시 코드 정의
- "테스트가 없는 코드"로 정의
- 테스트 작성의 어려움과 코드 품질의 상관관계
- 리팩터링을 통한 테스트 가능성 개선

### 4. 기업 사례와 실무 적용
- 연속 배포 방식을 채택한 대기업들의 사례
- 자동화된 테스트만으로 프로덕션 배포 결정
- 개발자 테스트가 첫 번째 방어선 역할

### 5. 테스트 전략 수립 가이드
- 애플리케이션 유형에 따른 테스트 조합 결정
- "올바른 시스템 구현" vs "시스템의 올바른 구현"
- 백엔드 시스템의 특수한 테스트 요구사항