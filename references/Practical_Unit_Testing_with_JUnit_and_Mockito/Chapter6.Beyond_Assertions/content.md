Line 1: 
Line 2: --- 페이지 111 ---
Line 3: Chapter 6. Beyond Assertions
Line 4: You are already familiar with standard AssertJ assertions. They are very useful, but sometimes you
Line 5: will find yourself needing more. This section discusses how you can go beyond default assertions and
Line 6: create your custom ones, better suited for your business domain.
Line 7: 6.1. Custom Matchers
Line 8: While AssertJ assertions are quite powerful and flexible, they don’t speak the language of your
Line 9: domain. It is time to change this! What we want is to go from:
Line 10: assertThat(book.getTitle()).isEqualTo("some title");
Line 11: to
Line 12: assertThat(book).hasTitle("some title");
Line 13: I understand that it is hard to get very excited looking at hello-world examples like the one above. But
Line 14: think about your domain objects and imagine all the possibilities that such constructs would open. For
Line 15: example, you could write assertions like:
Line 16: Listing 6.1. Custom assertions for your domain objects
Line 17: assertThat(tmpFile)
Line 18:   .wasSavedTo("/tmp")
Line 19:     .hasExtension(".tmp");
Line 20: assertThat(forumUser)
Line 21:   .isActive()
Line 22:     .belongsTo(Group.MODERATORS)
Line 23:     .receivedBadges(Badges.MERCILESS, Badges.HELPFUL);
Line 24: Let us see now how to get there (but we will use the basic book example to keep things simple).
Line 25: Such simple examples hardly reveal the true power and usefulness of matchers. Custom
Line 26: matchers excel particularly when working with rich domain objects or complex data
Line 27: structures.
Line 28: Listing 6.2 shows the code of a custom matcher that will furnish us with the aforementioned
Line 29: hasTitle() method:
Line 30: Listing 6.2. Implementation of a AssertJ custom matcher
Line 31: import org.assertj.core.api.AbstractAssert; 
Line 32: import org.assertj.core.api.Assertions; 
Line 33: public class BookAssert extends AbstractAssert<BookAssert, Book> { 
Line 34:     public BookAssert(Book actual) {
Line 35:         super(actual, BookAssert.class);
Line 36:     }
Line 37: 96
Line 38: 
Line 39: --- 페이지 112 ---
Line 40: Chapter 6. Beyond Assertions
Line 41:     public static BookAssert assertThat(Book actual) { 
Line 42:         return new BookAssert(actual);
Line 43:     }
Line 44:     public BookAssert hasTitle(String title) { 
Line 45:         isNotNull(); 
Line 46:         Assertions.assertThat(actual.getTitle()) 
Line 47:           .as("title") 
Line 48:           .isEqualTo(title);
Line 49:         return this; 
Line 50:     }
Line 51: }
Line 52: Start by extending the AbstractAssert class.
Line 53: Our implementation of assertThat() is required so that we can start assertion lines in the
Line 54: same way as we would start any matchers’ assertions. This method returns an object of the
Line 55: BookAssert class so we can chain whatever other assertions this class provides.
Line 56: hasTitle() method returns object of the BookAssert class so it can be chained with other
Line 57: assertions.
Line 58: A null check so that we never fail with the dreaded NullPointerException.
Line 59: This is where the real verification happens. We use the "original" assertThat() method
Line 60: provided by the AssertJ Assertions class.
Line 61: A minor improvement of the failure message.
Line 62: As you can see, there is some boilerplate code required to create a custom matcher. This code
Line 63: is very generic and as you add new methods (in our case wasWrittenBy(Author author),
Line 64: publishedBy(Publisher publisher), etc.), you won’t need to modify it.
Line 65: AssertJ provides a "Assertion Generator1 to create assertions specific to your own
Line 66: classes". It works, but I have never used it myself. First, I write custom asserts only for the
Line 67: core objects of my domain. Second, I somehow distrust autogenerated code. But you might
Line 68: decide differently.
Line 69: Now that we have this custom matcher implemented, we can use it in our test code as shown below:
Line 70: Listing 6.3. The use of a custom matcher
Line 71: import org.junit.jupiter.api.Test;
Line 72: import static com.practicalunittesting.BookAssert.assertThat; 
Line 73: public class BookCustomMatcherTest {
Line 74:     private static final String TITLE = "My book";
Line 75:     @Test
Line 76:     void constructorShouldSetTitle() {
Line 77:         Book book = new Book(TITLE);
Line 78:         assertThat(book).hasTitle(TITLE); 
Line 79:     }
Line 80: }
Line 81: In this case we use the assertThat() method provided by the BookAssert class.
Line 82: 1See http://joel-costigliola.github.io/assertj/assertj-assertions-generator.html
Line 83: 97
Line 84: 
Line 85: --- 페이지 113 ---
Line 86: Chapter 6. Beyond Assertions
Line 87: Thanks to our custom matcher we are now able to write the tests at a reasonable level of
Line 88: abstraction. Thanks to intention-revealing names our test code will read almost as prose. How nice!
Line 89: 6.1.1. But wait… why not simply create a few
Line 90: helper methods?
Line 91:  Hmm… let us look at Listing 6.3 again. What would happen if we created a utility verification
Line 92: method and used it instead of the custom matcher?
Line 93: Listing 6.4. Verification method instead of custom matcher
Line 94: public class BookVerificationMethodTest {
Line 95:     private static final String TITLE = "My book";
Line 96:     @Test
Line 97:     void constructorShouldSetTitle() {
Line 98:         Book book = new Book(TITLE);
Line 99:         assertTitle(book, TITLE);
Line 100:     }
Line 101:     private void assertTitle(Book book, String expectedTitle) {
Line 102:         assertThat(book.getTitle()).isEqualTo(expectedTitle);
Line 103:     }
Line 104: }
Line 105: Hmm… this doesn’t look so bad. No need to create your own custom matcher class. No need for
Line 106: fancy imports. And the code reads quite nicely. Why should we invest in custom matchers then?
Line 107: There are a few reasons why I wouldn’t recommend this approach. And - once again - you might not
Line 108: believe me if all your experience with custom matchers comes from this simplistic example. Anyway,
Line 109: let me try to convince you:
Line 110: • you can’t chain utility methods,
Line 111: • it is harder to reuse them,
Line 112: • finding the right, intention-revealing name can be a challenge (is assertTitle() as intention-
Line 113: revealing as hasTitle()?),
Line 114: • because of the issues with finding the right name, such methods tend to grow and verify too much,
Line 115: resulting in overspecified tests.
Line 116: To sum it all up, we are once again facing the well-known trade-off. We can use a shortcut and
Line 117: produce some private methods, or invest some more time and do it right by writing custom matchers.
Line 118: I would suggest that if you face such a dilemma, then don’t hesitate and go for the custom matchers
Line 119: from the very beginning. The cost of writing them is surprisingly small (once you write one or two),
Line 120: and the gains are substantial.
Line 121: What I would like to point out is that the custom matchers one has written for unit tests often get
Line 122: reused later for integration and/or end-to-end tests. This increases the "return on investment" one had
Line 123: 98
Line 124: 
Line 125: --- 페이지 114 ---
Line 126: Chapter 6. Beyond Assertions
Line 127: to make to implement them. I would encourage you to write a few for the core objects of your domain,
Line 128: and see how it feels to use them in your test code.
Line 129: In my collection of poorly written tests2, I have a nice example of chaos that emerged
Line 130: exactly because a developer decided to take a shortcut and not invest in writing of custom
Line 131: matchers. Look also in Section 12.6.6 for some more insights. 
Line 132: 6.1.2. One entry point
Line 133: Hm… so now, if I’m to use the original assertThat() method of AssertJ, do I need to prefix it with
Line 134: class name, i.e. Assertions.assertThat()? Fortunately not.
Line 135: Let us assume that you have more than one custom matcher class for your project: BookAssert and
Line 136: MovieAssert. To use them both and the original AssertJ assertions in one test you need to create a
Line 137: single entry point for all of them. This happens to be surprisingly simple, as the next listing shows.
Line 138: Listing 6.5. One entry point for all assertions
Line 139: import org.assertj.core.api.Assertions; 
Line 140: import com.practicalunittesting.BookAssert; 
Line 141: import com.practicalunittesting.MovieAssert; 
Line 142: public class MyProjectAssertions extends Assertions { 
Line 143:   public static BookAssert assertThat(Book actual) { 
Line 144:     return new BookAssert(actual);
Line 145:   }
Line 146:   public static MovieAssert assertThat(Movie actual) { 
Line 147:     return new MovieAssert(actual);
Line 148:   }
Line 149: }
Line 150: We get access to original Assertions.assertThat() method.
Line 151: Entry points for our custom assertions.
Line 152: And then, in the test code, we need to use this new entry point for all assertions:
Line 153: Listing 6.6. Using various matchers in one test
Line 154: import static com.practicalunittesting.MyProjectAssertions.assertThat; 
Line 155: public class OneEntryPointTest {
Line 156:   @Test
Line 157:   void shouldUseAssert() {
Line 158:     assertThat(true) 
Line 159:           .isTrue();
Line 160:     assertThat(new Book("title")) 
Line 161:           .hasTitle("title");
Line 162:     assertThat(new Movie()) 
Line 163:           .hasWonOscar();
Line 164:   }
Line 165: 2Check my free book "Bad Tests, Good Tests" at http://kaczanowscy.pl/books/bad_tests_good_tests.html
Line 166: 99
Line 167: 
Line 168: --- 페이지 115 ---
Line 169: Chapter 6. Beyond Assertions
Line 170: }
Line 171: Using the assertThat() method of the MyProjectAssertions class
Line 172: assertThat() method of the original AssertJ Assertions class
Line 173: assertThat() methods of BookAssert and MovieAssert classes
Line 174: 6.2. But wait… what about Conditions?
Line 175: I see you checked the AssertJ documentation and found a section on the Condition class. Good, let us
Line 176: see now if it could help us.  
Line 177: Imagine we would like to enhance our previous example and add an assertion which would check
Line 178: the language the book was written with. Using custom matchers we would have to add the following
Line 179: method to BookAssert class (provided we have it already):
Line 180: public BookAssert isWrittenIn(String language) {
Line 181:   isNotNull();
Line 182:   Assertions.assertThat(actual.getLanguage()).isEqualTo(language);
Line 183:   return this;
Line 184: }
Line 185: That is nice and flexible, and will surely work. But there is also another way. We could write a custom
Line 186: Condition (which is another useful class provided by the AssertJ project). As you will see, conditions
Line 187: are like younger brothers of custom matchers - not so powerful but concise and faster to implement.
Line 188: The whole test class could look like this:
Line 189: Listing 6.7. Verifying book language using Condition
Line 190: import org.assertj.core.api.Condition; 
Line 191: public class BookConditionTest {
Line 192:     private static final String ENGLISH = "English";
Line 193:     private Book book;
Line 194:     Condition<Book> writtenInEnglish = new Condition<>(
Line 195:         book -> book.getLanguage().equals(ENGLISH), 
Line 196:         "book in English");
Line 197:     @Test
Line 198:     void languageCheck() {
Line 199:         book = new Book("title");
Line 200:         assertThat(book).is(writtenInEnglish); 
Line 201:     }
Line 202: }
Line 203: Required import.
Line 204: The verification part of our Condition.
Line 205: An additional error message.
Line 206: is() method is used to execute the condition and check if our SUT satisfies it (in this particular
Line 207: example: if the book returns "English" as its language).
Line 208: If our book was written in another language, then the test would fail with the following message:
Line 209: 100
Line 210: 
Line 211: --- 페이지 116 ---
Line 212: Chapter 6. Beyond Assertions
Line 213: java.lang.AssertionError:
Line 214: Expecting:
Line 215:  <com.practicalunittesting.chp06.matchers.Book@b9ab60bd>
Line 216: to be <book in English>
Line 217: As you can see, our Condition offers only a subset of what we achieved with a custom matcher. In
Line 218: particular, it is less flexible, and can verify only one language. But if that is all we need, then why
Line 219: bother with external assertion class (like BookAssert) if all we have to do is add this short snippet of
Line 220: code to the test class?
Line 221: Let us learn some more about what conditions can do.
Line 222: The documentation on AssertJ conditions [http://joel-costigliola.github.io/assertj/assertj-
Line 223: core-conditions.html] is, simply speaking, great. Check it out, please!
Line 224: • You can put them into separate class and reuse in many test classes.
Line 225: • You can enclose them within differently named methods: is() or has(). The idea here is to make
Line 226: them "sound" nice. An example explains this better than words:
Line 227: Condition<Book> writtenInEnglish =  ...;
Line 228: Condition<Book> moreThan100Pages = ...;
Line 229: @Test
Line 230: public void languageCheck() {
Line 231:   book = new Book(TITLE);
Line 232:   assertThat(book).is(writtenInEnglish)
Line 233:     .has(moreThan100Pages);
Line 234: }
Line 235: • Counter-methods are also available: isNot() and doesNotHave(), e.g.:
Line 236: assertThat(book).isNot(writtenInEnglish);
Line 237: assertThat(book).doesNotHave(moreThan100Pages);
Line 238: • Conditions also cooperate nicely with assertions aimed at verifying collections (see also Section
Line 239: 7.10 for other collections-related assertions).
Line 240: assertThat(books).haveAtLeastOne(writtenInEnglish);
Line 241: assertThat(books).haveExactly(2, firstEdition);
Line 242: • Conditions can also be combined using not(Condition), allOf(Condition…), and
Line 243: anyOf(Condition…), e.g.:
Line 244: assertThat(book).is(anyOf(writtenInEnglish, writtenInFrench));
Line 245: Now, after we learned about various uses of conditions, let us discuss shortly how they relate to
Line 246: custom matchers.
Line 247: 6.3. On Custom Matchers and Conditions
Line 248: To sum it all up, we have now two new tools at our disposal (apart from default assertions provided by
Line 249: AssertJ): custom matchers and conditions.
Line 250: 101
Line 251: 
Line 252: --- 페이지 117 ---
Line 253: Chapter 6. Beyond Assertions
Line 254: Custom matchers are more powerful, but they require more effort. If you need flexibility and super-
Line 255: clear error messages, then go for them. On the other hand, conditions are so much fun to write! One
Line 256: line of code with a short lambda expression, and voilà! - a new custom assertion is born. Not very
Line 257: flexible but ideal for quick checks of a single SUT property.
Line 258: Which one do you need? Depends on the context and your personal preferences.
Line 259: 102