# 2.5 Verifying Side Effects (pp.34-41)

---
**Page 34**

utj3-units/02/src/test/java/units/SomeStringUtils.java
@Test
void lowercasesRemainderOfLetters() {
assertEquals("Omega", capitalize("OMEGA"));
}
Testing pure functions is conceptually easy: call a method with
some values, then assert against the result it returns.
Verifying Side Effects
An impure function creates side effects. The prototypical side effect: you call
a void method that changes the value of one or more fields in the containing
object. The Location class does just that in its move method (highlighted):
utj3-units/02/src/main/java/units/Location.java
import java.util.Objects;
public class Location {
enum Heading {North, East, South, West}
private int x, y;
private Heading heading;
public Location(int x, int y, Heading heading) {
this.x = x;
this.y = y;
this.heading = heading;
}
public void move(int distance) {
➤
switch (heading) {
➤
case North -> y = y + distance;
➤
case East -> x = x + distance;
➤
case South -> y = y - distance;
➤
case West -> x = x - distance;
➤
}
➤
}
➤
public int getX() { return x; }
public int getY() { return y; }
public Heading getHeading() { return heading; }
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Location location = (Location) o;
return x == location.x && y == location.y && heading == location.heading;
}
Chapter 2. Testing the Building Blocks • 34
report erratum  •  discuss


---
**Page 35**

@Override
public int hashCode() { return Objects.hash(x, y, heading); }
@Override
public String toString() {
return "(" + x + ", " + y + ", => " + heading + ')';
}
}
Oh dear, that’s a pile of code. While Location appears to have a lot going on,
most of its code is boilerplate.
The Location class would be the sort of thing Java records are made for, but
for one unfortunate circumstance: it creates mutable objects. A Location object’s
x and y fields are mutated (changed) when client code executes the move
method.
Location looks like it demands a significant amount of testing. It’s a lot longer
than the CreditHistory class, for one (though probably nowhere near the size of
a typical class in so many production systems). But let’s see just what the
testing effort will involve.
Testing gives you the guts to ship. You increase this confidence by ensuring
that your code’s unit behaviors work as expected.
You gain the confidence to ship through testing.
You don’t need to test code you didn’t write as long as you think you can trust
it. The equals and hashCode methods here were generated by an IDE, which
should provide very high confidence that they work. If you later must manu-
ally change or directly invoke these methods, cover them with tests.
Developers wrote Location’s toString method to help developers decipher problems
and clarify failing tests. Don’t feel compelled to test it, either. Do test toString
if other production code depends on it, either explicitly or implicitly.
The only real behaviors in Location that remain for consideration are its ability
to capture a location and to move to another location.
A first test for Location might create a location with an (x, y) coordinate and a
heading, then ensure that it returns those initial values correctly. But that’s
terribly uninteresting and barely “behavior.” The getters will get exercised
(executed) as part of tests for other Location behavior. These tests will expose
problems with the getters, however inconceivable.
report erratum  •  discuss
Verifying Side Effects • 35


---
**Page 36**

Focus, then, on testing the one thing that could really break: move.
utj3-units/02/src/test/java/units/ALocation.java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static units.Location.Heading.North;
public class ALocation {
@Test
void increasesYCoordinateWhenMovingNorth() {
var location = new Location(0, 0, North);
location.move(42);
assertEquals(0, location.getX());
assertEquals(42, location.getY());
assertEquals(North, location.getHeading());
}
}
The test first creates a location and then tells the location to move. It finally
asserts that the y coordinate has changed appropriately (since you’re moving
north), but neither x nor the heading have changed.
Earlier, you learned to verify only one behavior per test method. This test
does just that—it verifies that a move operation updates the x coordinate of
a location and nothing else.
It would be nice and concise if you could consolidate the three assertions into
a single line. You can, by comparing the altered location object to a newly-
created instance:
utj3-units/03/src/test/java/units/ALocation.java
@Test
void increasesYCoordinateWhenMovingNorth() {
var location = new Location(0, 0, North);
location.move(42);
assertEquals(new Location(0, 42, North), location);
➤
}
One fewer test statement means less extraneous cognitive load.
The move method is a void method; in other words, it returns no value. It’s also
a command (or action method)—its purpose is to allow you to tell an object to
do something.
A command method can’t return anything, so it must otherwise create some
side effect to have a raison d’etre. It can alter any objects passed to it as
Chapter 2. Testing the Building Blocks • 36
report erratum  •  discuss


---
**Page 37**

arguments, it can alter the object’s fields, or it can interact with something
external that affects behavior. Or it can interact with another method that
does one of those three things.
The code in move assigns new values to x and y depending on which case in the
switch statement gets executed. These switch cases represent the potential
side effects. It’s the job of your tests to verify each one of these possible cases
by tracking the state of both x and y.
Four cases, four tests. Here are the remaining three:
utj3-units/03/src/test/java/units/ALocation.java
@Test
void increasesXCoordinateWhenMovingEast() {
➤
var location = new Location(-2, 0, East);
location.move(5);
assertEquals(new Location(3, 0, East), location);
}
@Test
void decreasesYCoordinateWhenMovingSouth() {
➤
var location = new Location(-2, 5, South);
location.move(9);
assertEquals(new Location(-2, -4, South), location);
}
@Test
void decreasesXCoordinateWhenMovingWest() {
➤
var location = new Location(-2, 5, West);
location.move(12);
assertEquals(new Location(-14, 5, West), location);
}
You can create each test from scratch. Or you can copy a working test, paste
it, and change the test data—as long as you go back and seek to eliminate
redundancies across the tests.
All four tests contain the same three statements: create a location,
call move on it, and then compare it to a new, expected location.
When only the data varies from test to test, you can use a parame-
terized test (see Executing Multiple Data Cases with Parameterized
Tests, on page 131) to instead run one test many times, each with
a different set of inputs and expected outcomes.
report erratum  •  discuss
Verifying Side Effects • 37


---
**Page 38**

Let’s consider, then discard, a couple more possibilities for testing the Location
class:
1.
The switch statement suggests a possibility that heading contains a value
not represented in the case statements. But in this case, heading is an enum
with four values, and you already have tests for all four values. (The
compiler would also give you a warning otherwise.)
2.
The heading parameter could be null. You could write a test that shows
nothing happens if move gets called with a null heading. However, the notion
of having no heading is probably nonsensical in the bigger application.
Better solutions:
• Default the heading to, say, North.
• Throw an exception in the constructor if it’s null.
• Assume a responsible client calls move and never passes a null heading.
For now, make that last assumption, and don’t worry about a null test.
Reflecting on Design
The more side effects your code creates, the more challenging it becomes to
verify. If one method changes a field, its new value can unexpectedly break
the behavior in other methods that interact with the field. These intertwinings
of object state are one of the reasons you write tests.
How you design your code has a direct impact on how easy it is to change. A
simpler design—more direct, more concise, and less intertwined—is better
because it makes change cheaper.
A simpler design usually makes tests far easier to write, too. Fewer intertwin-
ings of object state mean fewer pathways through the code that you must
concern yourself with.
A simpler design makes for simpler testing.
The corollary to that important tip:
Tests that are hard to write usually imply less-than-ideal design.
Fix the design.
Chapter 2. Testing the Building Blocks • 38
report erratum  •  discuss


---
**Page 39**

Your tests for Location weren’t so hard to write, and that’s because there’s not
much entanglement within its code. Still, you’ll want to look at a functional
version. In Java, records provide the best place to get started—they create
immutable objects by definition—objects whose state does not change after
instantiation. It’s a lot easier to reason about, and therefore test, when you
don’t have reason about complex ways in which the state can change.
utj3-units/03/src/main/java/units/FixedLocation.java
public record FixedLocation(int x, int y, Heading heading) {
public FixedLocation move(int distance) {
return switch (heading) {
case North -> new FixedLocation(x, y + distance, heading);
case East -> new FixedLocation(x + distance, y, heading);
case South -> new FixedLocation(x, y - distance, heading);
case West -> new FixedLocation(x - distance, y, heading);
};
}
}
Holy hand grenade! Using Java records, all that other near-boilerplate gets
blown away. You automagically get equals, hashCode, a useful toString, a construc-
tor, and accessors. The code shrinks to a fraction of its stateful version. Take
a look at what comparable tests look like.
utj3-units/03/src/test/java/units/AFixedLocation.java
public class AFixedLocation {
@Test
void increasesYCoordinateWhenMovingNorth() {
var location = new FixedLocation(0, 0, North);
var newLocation = location.move(42);
assertEquals(new FixedLocation(0, 42, North), newLocation);
}
@Test
void increasesXCoordinateWhenMovingEast() {
var location = new FixedLocation(-2, 0, East);
var newLocation = location.move(5);
assertEquals(new FixedLocation(3, 0, East), newLocation);
}
@Test
void decreasesYCoordinateWhenMovingSouth() {
var location = new FixedLocation(-2, 5, South);
var newLocation = location.move(9);
assertEquals(new FixedLocation(-2, -4, South), newLocation);
}
report erratum  •  discuss
Verifying Side Effects • 39


---
**Page 40**

@Test
void decreasesXCoordinateWhenMovingWest() {
var location = new FixedLocation(-2, 5, West);
var newLocation = location.move(12);
assertEquals(new FixedLocation(-14, 5, West),newLocation);
}
}
Hmm. Not any better, really. But due to the functional nature of FixedLocation,
you can inline all local variables to create single-statement assertions:
utj3-units/04/src/test/java/units/AFixedLocation.java
public class AFixedLocation {
@Test
void increasesYCoordinateWhenMovingNorth() {
assertEquals(new FixedLocation(0, 42, North),
new FixedLocation(0, 0, North).move(42));
}
@Test
void increasesXCoordinateWhenMovingEast() {
assertEquals(new FixedLocation(3, 0, East),
new FixedLocation(-2, 0, East).move(5));
}
@Test
void decreasesYCoordinateWhenMovingSouth() {
assertEquals(new FixedLocation(-2, -4, South),
new FixedLocation(-2, 5, South).move(9));
}
@Test
void decreasesXCoordinateWhenMovingWest() {
assertEquals(new FixedLocation(-14, 5, West),
new FixedLocation(-2, 5, West).move(12));
}
}
Each assertion now contains all the information needed to understand how
the test example demonstrates what the test’s name states. The tests are
direct, and digestible almost at a glance.
You don’t want to make Java into something it’s not—a functional language.
But moving in the direction of less state makes many things easier.
While each of the four tests involves a different set of data, their code is
exactly the same. Each test creates a location, calls move, and asserts against
a new location. You can cover the four data cases with a single test method
that you inject data variants into—see Executing Multiple Data Cases with
Parameterized Tests, on page 131).
Chapter 2. Testing the Building Blocks • 40
report erratum  •  discuss


---
**Page 41**

Testing Common Code Circumstances
As you write more tests, you’ll realize that you’re often facing a number of
common circumstances. Here’s a handful of them:
• Add an item to a list
• Do something if a conditional is met
• Update all items in a list that match a predicate
• Remove all items matching a predicate from a list
• Throw an exception when a conditional is met
Lists and other collection types are a heavy part of most software development.
You should be able to bang out tests involving lists without much thought.
In this section, you’ll work through how you might write tests for each of
those common needs. Hopefully, these examples will help you extrapolate
and learn to write tests for other data structures (Maps, Sets, arrays, etc.) and
operations (loops, streams, math, etc.).
Add an Item to a List
Here’s some trivial code for a container class—DestinationList—that allows clients
to add FixedLocation objects to it, one by one.
utj3-units/06/src/main/java/units/DestinationList.java
import java.util.ArrayList;
import java.util.List;
public class DestinationList {
private List<FixedLocation> locations = new ArrayList<>();
public void add(FixedLocation location) {
locations.add(location);
}
public List<FixedLocation> getLocations() {
return locations;
}
}
At a glance, you pretty much know the code in DestinationList works. Doesn’t matter,
though—it’s always possible for such a small amount of code to hide a mistake.
The singular concept implemented in DestinationList—adding a location—involves
three separate code points: a method to add the location to a list, a field that
creates and initializes the list, and a method that returns the list. That lack
of concision only increases the possibility of a defect.
DestinationList will change and grow as requirements for “add location” change
or as other behaviors are added. Defects will be increasingly harder to spot.
report erratum  •  discuss
Testing Common Code Circumstances • 41


