# Cover (p.C)

# Table of Contents (p.<1C89D1>)

# Foreword (p.<1289D180>)

## The More Things Change… (p.<1289CE>)

# Acknowledgments (p.<1296>)

# Preface (p.<1296D180>)

## Why Unit Testing (p.<1296D1802D>)

## Who This Book Is For (p.<1289C0>)

## What You Need (p.<1289C0>)

## How This Book Is Organized (p.<1298>)

## Code and Online Resources (p.<1298>)

## Test-Driven Development (TDD) (p.<1298D1>)

## Coding Style (p.<1298D180>)

# Part I—Unit Testing Foundations (p.1)

## 1. Building Your First JUnit Test (p.3)

### 1.1 Reasons to Write a Unit Test (p.3)

### 1.2 Learning JUnit Basics: Your First Testing Challenge (p.4)

### 1.3 Writing a First Real Test (p.8)

### 1.4 Dealing with Failure (p.11)

### 1.5 Moving On to a One-Based Test: Something’s Happening! (p.14)

### 1.6 Increasing Your ROI: Cleaning Up Tests (p.17)

### 1.7 ZOM: Zero and One Done, Now Testing Many (p.22)

### 1.8 Covering Other Cases: Creating a Test List (p.24)

### 1.9 Congratulations!…But Don’t Stop Yet (p.24)

## 2. Testing the Building Blocks (p.25)

### 2.1 Units (p.25)

### 2.2 A Wee Bit Bigger Than a Unit? (p.27)

### 2.3 Concepts as Building Blocks (p.31)

### 2.4 Testing the Simpler Things (p.31)

### 2.5 Verifying Side Effects (p.34)

### 2.6 Testing Common Code Circumstances (p.41)

### 2.7 Exploring Boundaries with CORRECT (p.51)

### 2.8 Summary (p.52)

## 3. Using Test Doubles (p.53)

### 3.1 A Testing Challenge (p.53)

### 3.2 Replacing Troublesome Behavior with Stubs (p.55)

### 3.3 Changing Your Design to Support Testing (p.58)

### 3.4 Adding Smarts to Your Stub: Verifying Parameters (p.58)

### 3.5 Simplifying Testing Using a Mock Tool (p.59)

### 3.6 Injecting Mocks with Mockito (p.62)

### 3.7 Verifying a Method Was Called…or Not (p.63)

### 3.8 Testing Exception Handling (p.65)

### 3.9 Fast Tests (p.66)

### 3.10 A Mélange of Important Test Double Tips (p.67)

### 3.11 Summary (p.68)

## 4. Expanding Your Testing Horizons (p.71)

### 4.1 Improving Unit Testing Skills Using Code Coverage (p.71)

### 4.2 Testing Multithreaded Code (p.79)

### 4.3 Writing Integration Tests (p.84)

### 4.4 Exploratory Unit Testing (p.90)

### 4.5 Summary (p.95)

# Part II—Mastering JUnit with “E”s (p.97)

## 5. Examining Outcomes with Assertions (p.99)

### 5.0 Introduction [auto-generated] (p.99)

### 5.1 Using the Core Assertion Forms (p.100)

### 5.2 Assertion Messages: Redundant Messages for Assertions (p.103)

### 5.3 Other Common JUnit Assertion Forms (p.104)

### 5.4 Expecting Exceptions (p.112)

### 5.5 Assert That Nothing Happened: assertDoesNotThrow (p.115)

### 5.6 Alternate Assertion Approaches (p.116)

### 5.7 Third-Party Assertion Libraries (p.118)

### 5.8 Eliminating Non-Tests (p.121)

### 5.9 Summary (p.122)

## 6. Establishing Organization in JUnit Tests (p.123)

### 6.1 The Parts of an Individual Test (p.123)

### 6.2 Setting Up and Tearing Down Using Lifecycle Methods (p.124)

### 6.3 Organizing Related Tests into Nested Classes (p.126)

### 6.4 Avoiding Dependency Despair: Don’t Order Your Tests! (p.130)

### 6.5 Executing Multiple Data Cases with Parameterized Tests (p.131)

### 6.6 Summary (p.134)

## 7. Executing JUnit Tests (p.135)

### 7.1 Testing Habits: What Tests to Run (p.135)

### 7.2 Creating Arbitrary Test Groups Using Tags (p.137)

### 7.3 Temporarily Disabling Tests with @Disabled (p.140)

### 7.4 Exploring More Features (p.142)

### 7.5 Summary (p.143)

# Part III—Increasing ROI: Unit Testing and Design (p.145)

## 8. Refactoring to Cleaner Code (p.147)

### 8.0 Introduction [auto-generated] (p.147)

### 8.1 A Little Bit o’ Refactor (p.148)

### 8.2 Finding Better Homes for Your Methods (p.154)

### 8.3 Removing Temporaries of Little Value (p.157)

### 8.4 Amplifying the Core Intent of Code (p.158)

### 8.5 Are You Kidding Me? Addressing Concerns over Performance (p.162)

### 8.6 Final Cleanup (p.166)

### 8.7 Summary (p.167)

## 9. Refactoring Your Code’s Structure (p.169)

### 9.0 Introduction [auto-generated] (p.169)

### 9.1 The Profile Class and the SRP (p.170)

### 9.2 Extracting a New Class (p.173)

### 9.3 Command-Query Separation (p.180)

### 9.4 The Costs of Maintaining Unit Tests (p.182)

### 9.5 Summary (p.187)

## 10. Streamlining Your Tests (p.189)

### 10.1 Tests as Documentation (p.189)

### 10.2 Searching for an Understanding (p.192)

### 10.3 Test Smell: Legacy Code Constructs (p.193)

### 10.4 Test Smell: Unnecessary Test Code (p.194)

### 10.5 Test Smells: Generalized and Stepwise Assertions (p.195)

### 10.6 Test Smell: Missing Abstractions (p.197)

### 10.7 Test Smell: Bloated Construction (p.199)

### 10.8 Test Smell: Multiple Assertions (p.200)

### 10.9 Test Smell: Irrelevant Details in a Test (p.202)

### 10.10 Test Smell: Misleading Organization (p.203)

### 10.11 Test Smell: Implicit Meaning (p.204)

### 10.12 Adding Tests from Your Test List (p.206)

### 10.13 Summary (p.207)

# Part IV—Bigger Topics Around Unit Testing (p.209)

## 11. Advancing with Test-Driven Development (TDD) (p.211)

### 11.0 Introduction [auto-generated] (p.211)

### 11.1 The Primary Benefit of TDD (p.212)

### 11.2 Starting Simple (p.212)

### 11.3 Increment 1: Deferring Complexity (p.213)

### 11.4 Increment 2: Generalizing the Implementation (p.221)

### 11.5 Increment 3: Factoring Out Redundancies (p.224)

### 11.6 Increment 4: Introducing a Test Double (p.226)

### 11.7 Test-Driven Development vs. Test-After Development (p.231)

### 11.8 The Rhythm of TDD (p.232)

### 11.9 Summary (p.233)

## 12. Adopting Team Practices (p.235)

### 12.1 Coming up to Speed (p.235)

### 12.2 Getting on the Same Page with Your Team (p.236)

### 12.3 Practicing Continuous Integration (p.241)

### 12.4 Summary (p.243)

## 13. Keeping AI Honest with Unit Tests (p.245)

### 13.1 AI Isn’t Going Away (p.245)

### 13.2 Exploring a Simple Example with ChatGPT (p.246)

### 13.3 Establishing a Java Standard (p.247)

### 13.4 Providing Examples to ChatGPT (p.248)

### 13.5 Telling Your LLM to Clean Up Its Act (p.251)

### 13.6 Adding a New Feature: Suffixes (p.255)

### 13.7 Getting the LLM to Do Final Design Cleanup (p.260)

### 13.8 For Extra Credit (p.262)

### 13.9 Increasing Odds of Success with AI-Generated Code (p.263)

### 13.10 Will I Go Faster? (p.263)

### 13.11 Summary (p.264)

# Bibliography (p.265)

# Index (p.267)

## – SYMBOLS – (p.267)

## – A – (p.267)

## – B – (p.268)

## – C – (p.268)

## – D – (p.269)

## – E – (p.269)

## – F – (p.270)

## – G – (p.270)

## – H – (p.270)

## – I – (p.270)

## – J – (p.271)

## – L – (p.271)

## – M – (p.271)

## – N – (p.272)

## – O – (p.272)

## – P – (p.272)

## – Q – (p.272)

## – R – (p.272)

## – S – (p.273)

## – T – (p.273)

## – U – (p.274)

## – V – (p.274)

## – W – (p.274)

## – Y – (p.274)

## – Z – (p.274)