# 12.4 Summary (pp.243-245)

---
**Page 243**

An Integration Process Checklist
Here’s a summary of your steps as a developer for practicing continuous
integration:
1.
Pull from your central repo to get your local codebase up to date.
2.
Change the code, running unit tests as you go.
3.
Pull from the repo to integrate any new changes from teammates.
4.
Manually review the incoming changes as appropriate.
5.
Run your tests to ensure that the integrated code works.
6.
Push your changes to the central repository.
Don’t advance to the next step if any of your tests are failing.
A CI process fosters healthy peer pressure against costly code. Developers
quickly habituate themselves to running their unit tests before check-in so
as not to waste their teammates’ time by causing the CI build process to fail.
A CI server is a minimum for building a modern development team.
Summary
You and your team must be on the same page when it comes to unit testing.
If it’s new to your team, it’ll take time to adopt and ingrain as a beneficial
habit. If it’s an existing practice, your team practices might need improvement.
In this chapter, you learned about establishing team-level standards for unit
testing from both implementation and process perspectives. You also learned
about the active review mechanisms that help ensure test quality—specifically,
mob and pair programming. Finally, you discovered the key role that CI plays
in unit testing.
Last up: times are changing rapidly. AI has dramatically made its way into
the software development arena. Unlike previous attempts (anyone remember
Prolog and 4GLs?), AI has made a ubiquitous impact not just in software
development but in day-to-day life for many of us. AI’s improvements are
accelerating and there’s little chance of its disappearance.
Yes, unit testing is quite relevant in the age of AI. Read on to discover how.
report erratum  •  discuss
Summary • 243


---
**Page 245**

CHAPTER 13
Keeping AI Honest with Unit Tests
You’ve learned a number of benefits you can gain from writing unit tests:
fewer defects, of course, but also trustworthy documentation, the ability to
keep your code clean through refactoring, and a dramatic increase in confi-
dence for shipping the system.
AI can generate code, creating increasingly dramatic implications for the
software development industry and you. Yet, unit testing can and will provide
tremendous value in your software development efforts. In this chapter, you’ll
take an approach involving AI generation of both production code and unit
tests. You’ll discover why unit tests remain essential, and you’ll learn how to
incorporate them into a workflow that will give you the confidence to ship.
AI Isn’t Going Away
By the time you read this chapter, the capabilities of artificial intelligence (AI)
will have advanced, perhaps significantly, from when I wrote it (January
2024). At some future point, very possibly within the span of your career,
most (not all) software will be generated by AI.
You will still need to tell your AI assistant what to do.
Today, AI-generated code has limitations. It’s of dubious quality, for one—very
stepwise and highly concrete. Maybe when AI evolves to a point where the
code always works as expected, its quality won’t matter because, at that point,
you might never have to read or write another word of code again. But today,
AI-generated code may contain defects. ChatGPT, for example, perpetually
admits that fact:
ChatGPT can make mistakes. Consider checking important information.
I’ve seen failures often occur when an LLM (Large Language Model) adds a
new feature to an existing body of code, for example. You’ll explore how to
report erratum  •  discuss


