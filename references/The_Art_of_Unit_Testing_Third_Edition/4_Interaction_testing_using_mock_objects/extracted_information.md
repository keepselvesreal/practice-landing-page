# 4장: Interaction testing using mock objects - 추출된 정보

## 핵심 내용
목(mock) 객체를 사용하여 제3자 함수, 모듈, 객체에 대한 호출을 테스트하는 상호작용 테스트(interaction testing) 방법을 다룹니다.

## 상세 핵심 내용
- **상호작용 테스트**: 제어할 수 없는 의존성과 단위 작업이 올바르게 상호작용하는지 확인하는 테스트
- **목과 스텁의 차이**: 목은 발신 의존성을 끊고 어서션 대상이 되며, 스텁은 수신 의존성을 끊고 어서션하지 않음
- **목 객체 사용 이유**: 제3자 함수나 API가 올바르게 호출되었는지 검증하기 위해
- **매개변수 주입**: 로거와 같은 의존성을 매개변수로 주입하여 목으로 교체
- **명명 규칙**: mockXXX와 stubXXX 명명으로 테스트 의도 명확화

## 상세 내용

### 상호작용 테스트 정의
- **목적**: 단위 작업이 제어 범위 밖의 의존성에 메시지(함수 호출)를 올바르게 보내는지 확인
- **대상**: 로거, 이메일 전송, 데이터베이스 저장, 외부 API 호출 등
- **특징**: 전통적인 주입 기술로는 검증할 수 없는 제3자 함수의 호출 검증

### 목과 스텁의 명확한 구분

#### 목(Mock)의 특징
- **발신 의존성 해결**: 단위 작업의 출구점 역할
- **어서션 대상**: 테스트에서 올바르게 호출되었는지 검증
- **단일 원칙**: 테스트당 하나의 목만 사용 (가독성과 유지보수성)
- **명명 규칙**: mockLogger, mockEmailSender 등

#### 스텁(Stub)의 특징
- **수신 의존성 해결**: 단위 작업에 데이터나 동작 제공
- **어서션 비대상**: 스텁에 대해서는 검증하지 않음
- **다중 사용**: 하나의 테스트에서 여러 스텁 사용 가능
- **중간 지점**: 최종 결과가 아닌 경유점 역할

### 표준 스타일: 매개변수 주입

#### 기존 코드 (의존성이 고정됨)
```javascript
const log = require('./complicated-logger');
const verifyPassword = (input, rules) => {
    // ... 검증 로직
    if (failed.count === 0) {
        log.info('PASSED');  // 테스트하기 어려운 부분
        return true;
    }
    log.info('FAIL');        // 테스트하기 어려운 부분
    return false;
};
```

#### 리팩토링된 코드 (의존성 주입)
```javascript
const verifyPassword2 = (input, rules, logger) => {
    // ... 검증 로직
    if (failed.length === 0) {
        logger.info('PASSED');
        return true;
    }
    logger.info('FAIL');
    return false;
};
```

#### 목 객체를 사용한 테스트
```javascript
describe('password verifier with logger', () => {
    describe('when all rules pass', () => {
        it('calls the logger with PASSED', () => {
            let written = '';
            const mockLog = {
                info: (text) => {
                    written = text;
                }
            };
            verifyPassword2('anything', [], mockLog);
            expect(written).toMatch(/PASSED/);
        });
    });
});
```

### 목과 스텁 구분의 중요성

#### 올바른 명명의 이점
1. **가독성**: 테스트 이름이 명확하고 이해하기 쉬움
2. **유지보수성**: 스텁에 대한 어서션을 방지하여 결합도 감소
3. **신뢰성**: 여러 목이 있을 때 첫 번째 실패가 나머지를 가리는 문제 방지

#### Assertion Roulette 문제
- **정의**: 여러 목이 있는 테스트에서 첫 번째 실패 시 나머지 검증이 실행되지 않는 문제
- **해결책**: 테스트당 하나의 목만 사용하고 명확히 구분

### 모듈형 목 주입
- **inject 함수 활용**: 이전 장에서 배운 모듈 의존성 주입 기법을 목에도 적용
- **API 시뮬레이션**: 복잡한 제3자 라이브러리의 API를 가짜로 구현
- **한계점**: 실제 API 변경 시 테스트가 깨지기 쉬운 구조

### 덕 타이핑 활용
- **부분 인터페이스**: 목 객체가 실제 객체의 일부 메서드만 구현해도 됨
- **JavaScript 특성**: 타입 검사가 느슨하여 같은 메서드만 있으면 교체 가능
- **예시**: 로거의 info 메서드만 구현하고 debug 메서드는 생략 가능

## 주요 화제

### 목 객체의 설계 원칙
- **단일 책임**: 하나의 테스트는 하나의 요구사항(목)만 검증
- **명확한 의도**: 목 객체 명명을 통한 테스트 의도 전달
- **최소 인터페이스**: 필요한 메서드만 구현하는 덕 타이핑 활용

### 테스트 품질과 유지보수성
- **결합도 관리**: 스텁에 대한 어서션을 피하여 내부 구현과의 결합도 감소
- **가독성 향상**: 명확한 명명 규칙으로 테스트 의도 명확화
- **신뢰성 확보**: 단일 목 원칙으로 모든 검증이 실행되도록 보장

### 리팩토링 기법
- **의존성 추상화**: 직접 의존성을 매개변수로 추출
- **인터페이스 최소화**: 필요한 부분만 목으로 구현
- **변경 영향 최소화**: 의존성 변경이 테스트 코드에 미치는 영향 감소

## 부차 화제

### 용어 혼용 문제
- **목 오남용**: "mock database", "mock service" 등의 부정확한 용어 사용
- **정확한 구분**: 대부분의 경우 실제로는 스텁을 의미하는 경우가 많음
- **표준 용어**: 테스트 더블, 스텁, 목의 정확한 의미와 사용

### Jest의 모킹 기능
- **내장 기능**: Jest에서 제공하는 모킹 메커니즘
- **사용 권장사항**: 다른 선택지가 없을 때만 사용 권장
- **가독성과 유지보수성**: 내장 기능보다 수동 목이 더 명확할 수 있음

### 로거 의존성 처리
- **일반적 사례**: 로깅은 가장 흔한 제3자 의존성 사례
- **테스트 전략**: 로그 호출을 검증할지 여부의 판단 기준
- **출구점 인식**: 로깅이 단순 부작용인지 비즈니스 요구사항인지 구분

### 복잡한 인터페이스 처리
- **인터페이스 복잡도**: 많은 메서드를 가진 의존성 처리 방법
- **부분 목**: 필요한 부분만 구현하는 전략
- **테스트 복잡도 관리**: 복잡한 목으로 인한 테스트 복잡도 증가 방지