# 1_The_basics_of_unit_testing

## 핵심 내용
- 단위 테스트의 정의와 기본 개념
- Entry Point와 Exit Point를 통한 단위 작업(Unit of Work) 이해
- 좋은 단위 테스트의 특성과 통합 테스트와의 차이점
- 테스트 주도 개발(TDD)의 기본 원리

## 상세 핵심 내용

### 단위 테스트 정의
- **단위 테스트**: 자동화된 코드 조각으로 진입점을 통해 작업 단위를 호출하고 출구점 중 하나를 확인하는 테스트
- **SUT (Subject Under Test)**: 테스트 대상인 시스템, 수트, 또는 주제
- **단위 작업**: 진입점 호출부터 하나 이상의 출구점을 통한 눈에 띄는 최종 결과까지의 모든 행동

### Entry Point와 Exit Point
- **Entry Point**: 외부에서 트리거할 수 있는 진입점 (예: 함수 호출)
- **Exit Point 유형**:
  1. 반환 값 (Return Value)
  2. 상태 변경 (State Change)
  3. 제3자 종속성 호출 (Third-party Dependency Call)

### 좋은 단위 테스트의 특성
- 빠른 실행 속도
- 테스트 대상 코드에 대한 완전한 제어
- 완전한 격리 (다른 테스트와 독립적 실행)
- 메모리에서 실행 (파일시스템, 네트워크, 데이터베이스 불필요)
- 동기적이고 선형적 실행

## 상세 내용

### 테스트 프레임워크 없이 테스트 작성
```javascript
const assertEquals = (expected, actual) => {
  if (actual !== expected) {
    throw new Error(`Expected ${expected} but was ${actual}`);
  }
};

const check = (name, implementation) => {
  try {
    implementation();
    console.log(`${name} passed`);
  } catch (e) {
    console.error(`${name} FAILED`, e.stack);
  }
};
```

### 통합 테스트 vs 단위 테스트
- **통합 테스트**: 실제 종속성을 사용하는 테스트
- **단위 테스트**: 모든 종속성을 메모리 내에서 제어하는 테스트
- 통합 테스트는 느리고 디버그하기 어려우며 여러 실패 지점을 가짐

### TDD의 3단계 사이클
1. **실패하는 테스트 작성**: 기능이 누락되었음을 증명
2. **테스트를 통과시키는 코드 작성**: 가장 단순한 구현
3. **리팩터링**: 코드 품질 개선 (기능 변경 없이)

## 주요 화제

### 1. 단위 테스트 기본 개념
- 수동 테스트의 문제점과 자동화의 필요성
- JavaScript/TypeScript를 사용한 테스트 예제
- 절차형, 함수형, 객체지향 패러다임에서의 테스트

### 2. Entry Point와 Exit Point 분석
- 함수 수준에서의 진입점과 출구점
- 여러 출구점을 가진 함수의 테스트 전략
- 각 출구점별 개별 테스트 작성의 중요성

### 3. 테스트 품질 기준
- 읽기 쉬움 (Readability)
- 유지보수성 (Maintainability) 
- 신뢰성 (Trust)
- 일관된 결과 제공

### 4. 통합 테스트와의 구분
- 실제 종속성 사용 시 발생하는 문제점
- 격리된 환경에서의 테스트의 장점
- 회귀 테스트의 중요성

## 부차 화제

### 1. JavaScript vs TypeScript 사용법
- 절차형/함수형 예제에는 JavaScript 사용
- 객체지향 예제에는 TypeScript 사용
- 다양한 프로그래밍 패러다임 지원

### 2. 레거시 코드 정의
- "테스트가 없는 코드"로 정의
- 유지보수가 어려운 오래된 코드
- 테스트 도입의 어려움

### 3. 종속성 관리
- 종속성의 정의: 테스트에서 완전히 제어할 수 없는 요소
- 로거, 네트워크, 데이터베이스 등의 외부 종속성
- Stub을 통한 종속성 대체 방법

### 4. TDD 학습 전략
- 세 가지 핵심 기술: 좋은 테스트 작성, 테스트 우선 작성, 설계
- 단계적 학습 접근법
- 각 기술을 개별적으로 학습하는 것의 중요성

### 5. 코드 예제와 실습
- GitHub 저장소: https://github.com/royosherove/aout3-samples
- Node.js 12.8 이상 요구
- CommonJS 모듈 시스템 사용

---

# 2_A_first_unit_test

## 핵심 내용
- Jest 테스트 프레임워크를 사용한 첫 번째 단위 테스트 작성
- AAA 패턴 (Arrange-Act-Assert)을 통한 테스트 구조화
- USE 명명법 (Unit under test, Scenario, Expectation) 적용
- 코드 중복 제거 기법과 매개변수화된 테스트
- Password Verifier 프로젝트를 통한 실전 예제

## 상세 핵심 내용

### Jest 프레임워크의 특징
- **올인원 도구**: 테스트 라이브러리, 어서션, 러너, 리포터 통합 제공
- **기본 어서션 라이브러리**: expect() 함수를 통한 다양한 매처 제공
- **테스트 러너**: 자동 테스트 파일 탐지 및 실행
- **빌트인 리포터**: 상세한 테스트 결과 출력

### AAA 패턴 (Arrange-Act-Assert)
- **Arrange (준비)**: 테스트에 필요한 데이터와 객체 준비
- **Act (실행)**: 테스트하고자 하는 실제 동작 수행
- **Assert (검증)**: 결과가 예상과 일치하는지 확인

### USE 명명법
- **Unit under test**: 테스트 대상 단위
- **Scenario**: 테스트 상황이나 조건
- **Expectation**: 예상되는 결과나 동작

## 상세 내용

### Jest 설치 및 설정
```bash
npm install --save-dev jest
```

```json
{
  "scripts": {
    "test": "jest"
  }
}
```

### 기본 테스트 작성 예제
```javascript
// password-verifier.js
const verifyPassword = (input, rules) => {
  // 구현
};

// password-verifier.test.js
const { verifyPassword } = require('./password-verifier');

describe('password verifier', () => {
  test('given too short password, returns false', () => {
    // Arrange
    const input = '12345';
    const rules = { minLength: 6 };
    
    // Act
    const result = verifyPassword(input, rules);
    
    // Assert
    expect(result.passed).toBe(false);
  });
});
```

### 코드 중복 제거 기법

#### beforeEach() 사용
```javascript
describe('password verifier', () => {
  let input, rules;
  
  beforeEach(() => {
    rules = { minLength: 6 };
  });
  
  test('given too short password, returns false', () => {
    input = '12345';
    const result = verifyPassword(input, rules);
    expect(result.passed).toBe(false);
  });
});
```

#### 팩토리 메소드 패턴
```javascript
const createRules = (overrides = {}) => {
  return {
    minLength: 6,
    maxLength: 20,
    ...overrides
  };
};
```

### 매개변수화된 테스트
```javascript
describe.each([
  ['12345', false, 'too short'],
  ['123456', true, 'minimum length'],
  ['1234567890123456789012345', false, 'too long']
])('password verifier with different inputs', (password, expected, scenario) => {
  test(`given ${scenario} password, returns ${expected}`, () => {
    const rules = createRules();
    const result = verifyPassword(password, rules);
    expect(result.passed).toBe(expected);
  });
});
```

## 주요 화제

### 1. Jest 프레임워크 특징과 장점
- 제로 설정으로 바로 시작 가능
- 스냅샷 테스트 지원
- 내장된 코드 커버리지 도구
- 병렬 테스트 실행 지원

### 2. AAA 패턴의 중요성과 활용
- 테스트 구조의 일관성 확보
- 테스트 의도의 명확한 표현
- 가독성과 유지보수성 향상
- 팀 내 테스트 작성 표준화

### 3. 테스트 명명 규칙과 USE 명명법
- 테스트 이름에서 의도 파악 가능
- 테스트 실패 시 빠른 문제 파악
- 문서화 효과
- 비즈니스 요구사항과의 연결

### 4. 코드 중복과 테스트 유지보수
- DRY 원칙의 테스트 적용
- beforeEach()와 팩토리 메소드 활용
- 테스트 데이터 관리 전략
- 과도한 추상화 주의점

## 부차 화제

### 1. Jest vs 다른 테스트 프레임워크
- Mocha + Chai + Sinon 조합과의 비교
- Jest의 올인원 접근 방식의 장단점
- 프로젝트 특성에 따른 프레임워크 선택

### 2. 테스트 실행과 디버깅
- jest --watch 모드 활용
- 특정 테스트 파일 실행
- 디버깅 모드에서 테스트 실행
- VS Code와의 통합

### 3. Password Verifier 프로젝트 설계
- 요구사항 분석과 테스트 케이스 도출
- 규칙 기반 검증 시스템 설계
- 확장 가능한 구조 고려사항
- 실제 프로덕션 적용 시 고려사항

### 4. 매개변수화된 테스트의 활용
- 테스트 케이스 수 최소화
- 경계값 분석 테스트
- 데이터 기반 테스트 접근법
- 테스트 가독성과 유지보수성 균형

### 5. Jest 고급 기능 소개
- 스냅샷 테스트
- 목 함수 (jest.fn())
- 타이머 조작 (jest.useFakeTimers())
- 코드 커버리지 측정

---

# 3_Breaking_dependencies_with_stubs

## 핵심 내용
외부 의존성을 가진 코드를 테스트하기 위해 스텁(stub)을 사용하여 의존성을 끊는 방법을 다루며, 다양한 의존성 주입 기법을 소개합니다.

## 상세 핵심 내용
- **의존성 유형**: 발신 의존성(outgoing dependencies)과 수신 의존성(incoming dependencies)의 구분
- **테스트 더블**: 스텁(stub), 목(mock), 스파이(spy) 등 가짜 의존성의 분류와 역할
- **스텁의 역할**: 수신 의존성을 대체하여 테스트에 특정 데이터나 동작을 제공
- **의존성 주입 기법**: 함수형, 모듈형, 객체지향 방식의 다양한 주입 방법
- **시간 의존성**: 시간에 의존하는 코드의 테스트 문제와 해결책

## 상세 내용

### 의존성의 분류
- **발신 의존성(Outgoing Dependencies)**:
  - 단위 작업의 출구점을 나타내는 의존성
  - 로거 호출, 데이터베이스 저장, 이메일 전송, API 알림 등
  - 행동을 나타내는 동사형: "호출하기", "전송하기", "알리기"
  - Fire-and-forget 시나리오로 외부로 흘러나가는 형태
  
- **수신 의존성(Incoming Dependencies)**:
  - 출구점이 아닌 의존성으로 단위 작업의 최종 동작 요구사항을 나타내지 않음
  - 데이터베이스 쿼리 결과, 파일 시스템 내용, 네트워크 응답 등
  - 이전 작업의 결과로 단위 작업으로 흘러들어오는 수동적 데이터

### 테스트 더블 분류
- **스텁(Stub)**:
  - 수신 의존성(간접 입력)을 끊는 데 사용
  - 가짜 모듈, 객체, 함수로 테스트 중인 코드에 가짜 동작이나 데이터 제공
  - 스텁에 대해서는 어서션하지 않음
  - 단일 테스트에서 여러 스텁 사용 가능

- **목(Mock)**:
  - 발신 의존성(간접 출력 또는 출구점)을 끊는 데 사용
  - 테스트에서 호출되었는지 어서션하는 가짜 모듈, 객체, 함수
  - 단위 테스트에서 출구점을 나타냄
  - 테스트당 하나의 목만 사용 권장

### 스텁 사용 이유
- **테스트 일관성**: 변수값이 변하지 않는 일관된 테스트 실행
- **반복 가능성**: 시간, 네트워크, 파일시스템 등 외부 요인에 독립적
- **시나리오 시뮬레이션**: 특정 상황이나 예외 상황 쉽게 재현
- **플레이키 테스트 방지**: 외부 요인으로 인한 간헐적 실패 방지

### 함수형 의존성 주입 기법

#### 1. 매개변수 주입
```javascript
const verifyPassword = (input, rules, currentDay) => {
    if ([SATURDAY, SUNDAY].includes(currentDay)) {
        throw Error("It's the weekend!");
    }
    return [];
};
```

#### 2. 함수 주입
```javascript
const verifyPassword = (input, rules, getDayFn) => {
    const dayOfWeek = getDayFn();
    if ([SATURDAY, SUNDAY].includes(dayOfWeek)) {
        throw Error("It's the weekend!");
    }
    return [];
};
```

#### 3. 부분 적용(커링) 및 팩토리 함수
```javascript
const makeVerifier = (rules, dayOfWeekFn) => {
    return function (input) {
        if ([SATURDAY, SUNDAY].includes(dayOfWeekFn())) {
            throw new Error("It's the weekend!");
        }
    };
};
```

### 모듈형 주입 기법
- **의존성 래핑**: 직접 의존성을 중간 객체로 래핑
- **inject 함수**: 실제 의존성을 가짜 의존성으로 교체하는 메커니즘
- **reset 함수**: 원래 의존성으로 복원하는 기능
- **단점**: 타사 라이브러리 API에 강하게 결합되어 취약성 발생

### 객체지향 주입 기법

#### 1. 생성자 주입
```javascript
class PasswordVerifier {
    constructor(rules, dayOfWeekFn) {
        this.rules = rules;
        this.dayOfWeek = dayOfWeekFn;
    }
    verify(input) {
        if ([SATURDAY, SUNDAY].includes(this.dayOfWeek())) {
            throw new Error("It's the weekend!");
        }
        return [];
    }
}
```

#### 2. 객체 주입 (덕 타이핑)
- 함수 대신 객체를 매개변수로 전달
- JavaScript의 허용적 특성 활용
- 실제 객체와 가짜 객체가 같은 함수 구현

#### 3. 공통 인터페이스 활용 (TypeScript)
```typescript
interface TimeProviderInterface {
    getDay(): number;
}

class RealTimeProvider implements TimeProviderInterface {
    getDay(): number {
        return moment().day();
    }
}

class FakeTimeProvider implements TimeProviderInterface {
    fakeDay: number;
    getDay(): number {
        return this.fakeDay;
    }
}
```

## 주요 화제

### 의존성 제어와 역전
- **제어(Control)**: 의존성의 동작을 지시할 수 있는 능력
- **제어의 역전(Inversion of Control)**: 의존성 생성 책임을 내부에서 외부로 이전
- **의존성 주입(Dependency Injection)**: 설계 인터페이스를 통해 의존성을 전달하는 행위
- **심(Seam)**: 두 소프트웨어 조각이 만나는 지점으로 다른 것을 주입할 수 있는 곳

### 설계 철학과 권장사항
- **순수 함수**: 부작용이 없고 모든 의존성이 내장 주입된 함수
- **함수형 vs 객체지향**: 각 스타일의 장단점과 팀 상황에 따른 선택
- **모듈 주입의 위험성**: 타사 의존성 API 변경 시 테스트 취약성
- **중간 추상화**: 직접 제어하지 않는 타사 의존성에 대한 중간 계층 권장

### 아키텍처 패턴
- **포트와 어댑터**: 외부 의존성에 대한 중간 추상화 제공
- **헥사고날 아키텍처**: 동일한 개념의 다른 명칭
- **어니언 아키텍처**: 계층적 의존성 관리 방식

## 부차 화제

### 시간 관련 테스트 문제
- **플레이키 테스트**: 시간에 따라 간헐적으로 실패하는 테스트
- **주말/평일 시나리오**: 특정 시간에만 실행되는 테스트의 문제점
- **Moment.js 의존성**: JavaScript에서 날짜/시간 처리의 복잡성

### 테스트 유지보수성
- **팩토리 함수**: 테스트에서 객체 생성을 추상화하여 유지보수성 향상
- **생성자 시그니처 변경**: 단일 지점에서 변경 사항 관리
- **스크롤 피로 방지**: 테스트 코드의 가독성 향상

### JavaScript 특성 활용
- **덕 타이핑**: 같은 메서드를 구현하면 같은 타입으로 취급
- **런타임 검증**: 컴파일 타임이 아닌 실행 시점에서 타입 검증
- **TypeScript 도입**: 컴파일 타임 타입 안전성 확보

### IoC 컨테이너와 DI 프레임워크
- **Angular**: 생성자 주입을 통한 서비스(의존성) 주입
- **Spring, Autofac, StructureMap**: 다른 언어의 DI 컨테이너
- **수동 주입 선호**: 테스트에서는 프레임워크보다 수동 팩토리 함수 권장

---

# 4_Interaction_testing_using_mock_objects

## 핵심 내용
목(mock) 객체를 사용하여 제3자 함수, 모듈, 객체에 대한 호출을 테스트하는 상호작용 테스트(interaction testing) 방법을 다룹니다.

## 상세 핵심 내용
- **상호작용 테스트**: 제어할 수 없는 의존성과 단위 작업이 올바르게 상호작용하는지 확인하는 테스트
- **목과 스텁의 차이**: 목은 발신 의존성을 끊고 어서션 대상이 되며, 스텁은 수신 의존성을 끊고 어서션하지 않음
- **목 객체 사용 이유**: 제3자 함수나 API가 올바르게 호출되었는지 검증하기 위해
- **매개변수 주입**: 로거와 같은 의존성을 매개변수로 주입하여 목으로 교체
- **명명 규칙**: mockXXX와 stubXXX 명명으로 테스트 의도 명확화

## 상세 내용
- **상호작용 테스트 정의**: 단위 작업이 제어 범위 밖의 의존성에 메시지(함수 호출)를 올바르게 보내는지 확인
- **목(Mock)의 특징**: 발신 의존성 해결, 어서션 대상, 단일 원칙(테스트당 하나의 목만 사용)
- **스텁(Stub)의 특징**: 수신 의존성 해결, 어서션 비대상, 다중 사용 가능
- **매개변수 주입**: 의존성을 매개변수로 받아 목으로 교체하는 표준 방식
- **Assertion Roulette 문제**: 여러 목이 있는 테스트에서 첫 번째 실패가 나머지를 가리는 문제

## 주요 화제
- **목 객체 설계 원칙**: 단일 책임, 명확한 의도, 최소 인터페이스
- **테스트 품질과 유지보수성**: 결합도 관리, 가독성 향상, 신뢰성 확보
- **리팩토링 기법**: 의존성 추상화, 인터페이스 최소화, 변경 영향 최소화

## 부차 화제
- **용어 혼용 문제**: "mock database", "mock service" 등의 부정확한 용어 사용
- **Jest의 모킹 기능**: 내장 기능보다 수동 목이 더 명확할 수 있음
- **로거 의존성 처리**: 로깅이 단순 부작용인지 비즈니스 요구사항인지 구분
- **복잡한 인터페이스 처리**: 필요한 부분만 구현하는 전략

---

# 5_Isolation_frameworks

## 핵심 내용
격리 프레임워크(isolation framework)를 사용하여 동적으로 스텁과 목 객체를 생성하고 설정하는 방법을 다루며, 수동으로 작성하는 것보다 간단하고 효율적인 방법을 제시합니다.

## 상세 핵심 내용
- **격리 프레임워크 정의**: 런타임에 가짜 객체를 동적으로 생성, 설정, 검증할 수 있는 프로그래밍 가능한 API 집합
- **두 가지 주요 유형**: 느슨한 타입(Jest, Sinon)과 강타입(substitute.js) 프레임워크
- **모듈 페이킹**: Jest의 jest.mock()을 사용한 전체 모듈 동적 대체
- **함수 페이킹**: 개별 함수에 대한 스파이와 목 생성
- **객체지향 페이킹**: substitute.js를 사용한 클래스와 인터페이스 처리

## 상세 내용
- **격리 프레임워크의 목적**: 동적 스텁과 동적 목 생성을 통한 의존성 격리
- **느슨한 JavaScript 격리 프레임워크**: Jest, Sinon (바닐라 JavaScript 친화적)
- **타입화된 JavaScript 격리 프레임워크**: substitute.js (TypeScript 친화적)
- **Jest의 자동 모킹**: jest.mock()을 통한 전체 모듈 자동 목 교체
- **Command/Query 분리 패턴**: Query는 스텁으로, Command는 목으로 처리

## 주요 화제
- **프레임워크 선택 기준**: 의존성 유형, 언어 스타일, 팀 선호도, 복잡도
- **동적 vs 수동 생성**: 코드량 감소 vs 명확한 의도의 트레이드오프
- **테스트 품질 고려사항**: 과도한 사용 위험, 가독성 vs 편의성

## 부차 화제
- **Jest의 고급 기능**: mockImplementation(), mockReturnValue(), toHaveBeenCalledWith()
- **프레임워크별 특성**: Jest(통합형), Sinon(독립형), substitute.js(TypeScript 중심)
- **모킹 전략**: 전체 모듈 vs 부분 모킹, 자동 vs 수동 설정
- **성능과 효율성**: 런타임 오버헤드, 메모리 사용, 병렬 테스트

---

# 6_Unit_testing_asynchronous_code

## 핵심 내용
비동기 코드의 단위 테스트 작성 방법을 다루며, 콜백, Promise, async/await 패턴에 대한 테스트 전략과 Extract Entry Point, Extract Adapter 패턴을 소개합니다.

## 상세 핵심 내용
- **비동기 테스트 복잡성**: 동작 완료를 명시적으로 기다려야 하는 비동기 코드의 테스트 어려움
- **다양한 비동기 패턴**: 콜백, Promise, async/await 각각에 대한 테스트 접근법
- **Extract Entry Point 패턴**: 비동기 로직을 분리하여 테스트 가능하게 만드는 리팩토링
- **Extract Adapter 패턴**: 외부 의존성을 추상화하여 비동기 코드를 테스트 가능하게 만드는 패턴
- **타이머 테스트**: setTimeout, setInterval 등 시간 기반 비동기 코드의 테스트

## 상세 내용
- **Jest의 비동기 테스트 지원**: done() 콜백, Promise 반환, async/await 사용
- **Extract Entry Point 패턴**: 데이터 페칭 로직 분리, 비즈니스 로직만 테스트
- **Extract Adapter 패턴**: 의존성 주입을 통한 테스트 개선, 어댑터 인터페이스 정의
- **Jest의 타이머 모킹**: useFakeTimers(), advanceTimersByTime() 활용
- **테스트 레벨 분류**: 단위 테스트 vs 통합 테스트의 비동기 처리 차이

## 주요 화제
- **비동기 테스트 전략**: 테스트 피라미드에서의 비동기 코드 위치
- **패턴 적용 가이드라인**: Extract Entry Point와 Extract Adapter 적용 시점
- **타이머와 시간 처리**: 실제 시간 vs 가짜 시간 사용 전략

## 부차 화제
- **Jest의 비동기 테스트 기능**: 타임아웃 설정, Promise rejection 처리, 병렬 실행
- **실제 프로젝트 적용**: API 클라이언트, 데이터베이스 작업, 이벤트 기반 코드 테스트
- **성능과 안정성**: 테스트 실행 시간 최적화, 플레이키 테스트 방지
- **디버깅과 문제 해결**: 비동기 스택 트레이스, 테스트 행업, 리소스 정리

---

# 7_Trustworthy_tests

## 핵심 내용
신뢰할 수 있는 테스트의 특징과 신뢰성을 저해하는 요인들을 분석하고, 플레이키 테스트를 포함한 다양한 테스트 실패 원인을 진단하고 해결하는 방법을 다룹니다.

## 상세 핵심 내용
- **좋은 테스트의 3가지 기둥**: 신뢰성(Trustworthiness), 유지보수성(Maintainability), 가독성(Readability)
- **신뢰 지표**: 테스트 실패 시 걱정되고, 테스트 통과 시 안심되는 것이 신뢰할 수 있는 테스트
- **테스트 실패의 원인**: 실제 버그, 버그가 있는 테스트, 기능 변경으로 인한 구식 테스트, 테스트 간 충돌, 플레이키 테스트
- **거짓 양성과 거짓 음성**: 잘못된 실패(false positive)와 잘못된 성공(false negative) 탐지 방법
- **플레이키 테스트**: 간헐적으로 실패하는 테스트의 원인과 해결책

## 상세 내용
- **신뢰성**: 개발자들이 테스트 결과를 확신을 가지고 받아들일 수 있는 특성
- **유지보수성**: 변경하기 쉽고 프로덕션 코드 변경에 자주 수정할 필요가 없는 특성
- **가독성**: 테스트를 읽고 문제를 파악할 수 있는 능력
- **테스트 실패 원인 5가지**: 실제 버그, 버그가 있는 테스트, 구식 테스트, 테스트 간 충돌, 플레이키 테스트
- **플레이키 테스트 해결 전략**: 의존성 제거, 적절한 대기, 상태 격리, 결정적 만들기

## 주요 화제
- **테스트 품질 관리**: 지속적인 평가, 팀 문화, 코드 리뷰
- **신뢰성 구축 전략**: 점진적 개선, 우선순위, 메트릭 추적
- **개발 워크플로우 통합**: CI/CD 파이프라인, 실패 대응, 팀 소통

## 부차 화제
- **도구와 기법**: 테스트 러너 설정, 재시도 메커니즘, 리포팅
- **조직적 고려사항**: 시간 투자, 기술 부채, 교육
- **성능과 안정성**: 실행 시간, 리소스 사용, 스케일링
- **문화적 측면**: 실패에 대한 인식, 품질 우선, 지속적 개선

---

# 8_Maintainability

## 핵심 내용
테스트의 유지보수성을 향상시키기 위한 방법들을 다루며, 프로덕션 코드 변경 시 테스트 코드 변경을 최소화하고 테스트 실패의 근본 원인을 분석하는 전략을 제시합니다.

## 상세 핵심 내용
- **유지보수성 정의**: 테스트 변경을 강요당하는 빈도를 최소화하는 것
- **거짓 실패 vs 진짜 실패**: 실제 버그가 아닌 이유로 실패하는 테스트 식별과 대응
- **API 변경 대응**: 생산자 API 변경이 테스트에 미치는 영향 최소화
- **팩토리 패턴**: 테스트 객체 생성을 중앙화하여 변경 영향 범위 제한
- **테스트 간 결합도**: 과도한 어서션과 내부 구현 의존성 제거

## 상세 내용
- **거짓 실패의 주요 원인**: 관련성 없는 테스트 또는 테스트 간 충돌, 프로덕션 코드 API 변경
- **팩토리 패턴 적용**: 팩토리 메서드, 고급 팩토리 패턴(Builder 패턴) 활용
- **과도한 어서션 방지**: 핵심 동작만 검증, 별도 관심사는 별도 테스트
- **내부 구현 의존성 제거**: 결과에 집중, 구현 방식 무시
- **테스트 데이터 관리**: 중앙화된 테스트 데이터, 테스트별 데이터 생성 함수

## 주요 화제
- **설계 원칙과 테스트**: 단일 책임 원칙, 개방/폐쇄 원칙, 의존성 역전
- **변경 영향 최소화 전략**: 계층화, 캡슐화, 표준화
- **리팩토링과 테스트**: 안전한 리팩토링, 테스트 주도 리팩토링, 점진적 개선

## 부차 화제
- **도구와 자동화**: 테스트 생성 도구, 리팩토링 도구, 정적 분석
- **팀 프랙티스**: 코드 리뷰, 페어 프로그래밍, 지식 공유
- **성능 고려사항**: 테스트 실행 시간, 병렬 실행, 리소스 관리
- **문서화와 표준**: 테스트 가이드라인, 패턴 라이브러리, 베스트 프랙티스

---

# 9_Readability

## 핵심 내용
테스트의 가독성을 향상시키는 방법을 다루며, 명명 규칙, 변수명, 어서션과 액션 분리, 설정과 정리에 관한 모범 사례를 제시합니다.

## 상세 핵심 내용
- **가독성의 중요성**: 테스트는 다음 세대 프로그래머들에게 전하는 이야기
- **명명 규칙**: 진입점, 시나리오, 예상 동작의 3가지 요소를 포함한 테스트 명명
- **변수 명명**: 의도를 명확히 드러내는 변수명 사용
- **구조적 분리**: Arrange-Act-Assert 패턴의 명확한 구분
- **설정과 정리**: 테스트 환경 준비와 정리의 명확한 표현

## 상세 내용
- **3가지 필수 정보 요소**: 진입점(Entry Point), 시나리오(Scenario), 예상 동작(Expected Behavior)
- **명명 방식**: 단일 테스트 함수명, 중첩된 describe 구조, 언더스코어 방식
- **의도를 드러내는 명명**: 테스트 더블 명명 규칙(stubXXX, mockXXX, spyXXX)
- **Arrange-Act-Assert 패턴 강화**: 명확한 섹션 분리, 복잡한 테스트의 헬퍼 메서드 활용
- **테스트 설정과 정리**: beforeEach/afterEach 사용 시 주의사항, 로컬 설정 선호

## 주요 화제
- **테스트 문서화 역할**: 살아있는 문서, 의도 전달, 예제 제공
- **팀 협업과 가독성**: 코드 리뷰, 온보딩, 지식 전수
- **유지보수와 가독성**: 디버깅 효율성, 수정 용이성, 회귀 방지

## 부차 화제
- **도구와 자동화**: IDE 지원, 린터 설정, 템플릿
- **언어별 관례**: JavaScript/TypeScript 관례, 크로스 플랫폼 일관성
- **복잡성 관리**: 테스트 길이, 중첩 수준, 추상화 수준
- **문화적 측면**: 명명 문화, 리뷰 문화, 학습 문화

---

# 10_Developing_a_testing_strategy

## 핵심 내용
조직 차원의 테스트 전략 수립 방법을 다루며, 다양한 테스트 레벨의 장단점, 테스트 레시피 전략, 배포 차단/비차단 테스트, 병렬 처리 등을 포함합니다.

## 상세 핵심 내용
- **테스트 레벨별 특성**: 단위 테스트부터 E2E 테스트까지의 속도, 신뢰성, 유지보수성 트레이드오프
- **테스트 피라미드**: 각 레벨별 테스트 수량 분배와 최적 비율
- **테스트 레시피 전략**: 기능별로 어느 레벨에서 테스트할지 결정하는 방법
- **배포 파이프라인**: 배포 차단 테스트와 발견용 테스트의 구분
- **병렬 처리**: 테스트 실행 속도 최적화 전략

## 상세 내용
- **6가지 테스트 레벨**: 단위 테스트, 컴포넌트 테스트, 통합 테스트, API 테스트, E2E/UI 격리 테스트, E2E/UI 시스템 테스트
- **테스트 피라미드 전략**: 70% 단위 테스트, 20% 통합 테스트, 10% E2E 테스트
- **테스트 레시피 결정 요소**: 복잡성, 변경 빈도, 비즈니스 중요도, 외부 의존성
- **배포 차단 vs 발견 테스트**: 빠른 실행(5-15분) vs 포괄적 커버리지(1-2시간)
- **테스트 병렬화 전략**: CPU 코어 기반 워커 조정, 느린 테스트 우선 실행

## 주요 화제
- **테스트 전략 수립 프로세스**: 현상 분석, 목표 설정, 단계적 적용
- **ROI 최적화**: 비용 대비 효과, 위험 기반 테스트, 자동화 우선순위
- **팀 협업과 책임**: 역할 분담, 기술 공유, 지속적 개선

## 부차 화제
- **도구와 인프라**: 테스트 환경, 모니터링, 보고
- **특수 상황 대응**: 레거시 시스템, 마이크로서비스, 모바일 앱
- **품질 메트릭**: 커버리지, 안정성, 효율성
- **조직 문화**: 품질 문화, 학습 문화, 협업 문화

---

# 11_Integrating_unit_testing_into_the_organization

## 핵심 내용
조직에 단위 테스트를 도입하는 과정에서 변화 관리의 심리적, 기술적 측면을 다루며, 탑다운과 바텀업 접근법, 저항 관리, 성공적인 도입 전략을 제시합니다.

## 상세 핵심 내용
- **변화 에이전트 역할**: 조직 변화를 이끄는 리더의 책임과 준비 사항
- **챔피언과 블로커**: 변화를 지지하고 방해하는 사람들 식별과 관리
- **탑다운 vs 바텀업**: 경영진 주도와 개발자 주도 접근법의 장단점
- **어려운 질문 대비**: 단위 테스트 도입에 대한 일반적인 우려사항과 답변
- **지속적인 모멘텀**: 초기 열정 이후에도 변화를 지속시키는 방법

## 상세 내용
- **변화 에이전트 준비**: 책임 인정, 가시성, 지속성, 어려운 질문에 대한 준비
- **챔피언 활용 전략**: 얼리 어답터 식별, 개인적 접근, 파일럿 프로젝트 제안
- **블로커 관리**: 직접적 대립 피하기, 점진적 설득, 성공 사례 증명
- **탑다운 접근법**: 빠른 의사결정, 리소스 확보 vs 실제 도입 어려움, 형식적 접근
- **바텀업 접근법**: 자발적 참여, 실용적 접근 vs 느린 진행, 리소스 부족

## 주요 화제
- **조직 문화 변화**: 심리적 안전성, 지속적 개선, 협업 강화
- **변화 관리 원칙**: 점진적 접근, 데이터 기반, win-win 추구
- **성공 요인**: 경영진 지원, 실무진 참여, 교육과 지원

## 부차 화제
- **도구와 프로세스**: 도구 선택, 자동화, 메트릭
- **교육과 멘토링**: 단계별 교육, 실습 중심, 지속적 지원
- **위험 관리**: 저항 관리, 실패 대응, 조정 능력
- **장기적 관점**: 문화 정착, 지속가능성, 확장성

---

# 12_Working_with_legacy_code

## 핵심 내용
레거시 코드에 테스트를 추가하는 방법을 다루며, 테스트 도입 우선순위 결정, 안전한 리팩토링 전략, 레거시 시스템의 일반적인 문제점과 해결 방안을 제시합니다.

## 상세 핵심 내용
- **레거시 코드의 일반적 문제**: 기존 코드에 대한 테스트 작성의 어려움과 장애 요인
- **테스트 시작점 결정**: 논리적 복잡성, 의존성 수준, 우선순위를 고려한 체계적 접근
- **테스트 가능성 표**: 컴포넌트별 테스트 도입 우선순위를 정량적으로 평가하는 방법
- **안전한 리팩토링**: 테스트가 없는 코드를 안전하게 리팩토링하는 전략
- **점진적 개선**: 전체 시스템을 한 번에 바꾸는 것이 아닌 점진적 개선 접근법

## 상세 내용
- **TDD 도입 실패 원인**: 심(seam) 부족, 강한 결합, 시간 부족, 조직적 저항, 도구 한계
- **평가 요소**: 논리적 복잡성(순환 복잡도), 의존성 수준(외부 서비스 호출), 우선순위(비즈니스 중요도)
- **안전한 리팩토링 전략**: 캐릭터라이제이션 테스트, 스프라우트 메서드, 스프라우트 클래스
- **점진적 개선 전략**: 스트랭글러 피그 패턴, 브랜치 바이 추상화
- **테스트 가능성 표**: 컴포넌트별 점수화를 통한 우선순위 결정

## 주요 화제
- **레거시 코드 특성**: 테스트 부족, 강한 결합, 복잡한 로직, 문서 부족
- **위험 관리**: 안전한 변경, 점진적 접근, 롤백 계획
- **도구와 기법**: 코드 분석 도구, 리팩토링 도구, 테스트 생성 도구

## 부차 화제
- **조직적 고려사항**: 시간 투자, 리스크 관리, 팀 교육
- **기술적 전략**: 마이크로서비스, API 게이트웨이, 데이터 마이그레이션
- **성공 요인**: 명확한 목표, 단계적 계획, 지속적 평가
- **일반적인 함정**: 빅뱅 접근, 과도한 완벽주의, 도구 의존

---