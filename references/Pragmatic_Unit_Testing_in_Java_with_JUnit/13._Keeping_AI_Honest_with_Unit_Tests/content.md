Line 1: 
Line 2: --- 페이지 257 ---
Line 3: CHAPTER 13
Line 4: Keeping AI Honest with Unit Tests
Line 5: You’ve learned a number of benefits you can gain from writing unit tests:
Line 6: fewer defects, of course, but also trustworthy documentation, the ability to
Line 7: keep your code clean through refactoring, and a dramatic increase in confi-
Line 8: dence for shipping the system.
Line 9: AI can generate code, creating increasingly dramatic implications for the
Line 10: software development industry and you. Yet, unit testing can and will provide
Line 11: tremendous value in your software development efforts. In this chapter, you’ll
Line 12: take an approach involving AI generation of both production code and unit
Line 13: tests. You’ll discover why unit tests remain essential, and you’ll learn how to
Line 14: incorporate them into a workflow that will give you the confidence to ship.
Line 15: AI Isn’t Going Away
Line 16: By the time you read this chapter, the capabilities of artificial intelligence (AI)
Line 17: will have advanced, perhaps significantly, from when I wrote it (January
Line 18: 2024). At some future point, very possibly within the span of your career,
Line 19: most (not all) software will be generated by AI.
Line 20: You will still need to tell your AI assistant what to do.
Line 21: Today, AI-generated code has limitations. It’s of dubious quality, for one—very
Line 22: stepwise and highly concrete. Maybe when AI evolves to a point where the
Line 23: code always works as expected, its quality won’t matter because, at that point,
Line 24: you might never have to read or write another word of code again. But today,
Line 25: AI-generated code may contain defects. ChatGPT, for example, perpetually
Line 26: admits that fact:
Line 27: ChatGPT can make mistakes. Consider checking important information.
Line 28: I’ve seen failures often occur when an LLM (Large Language Model) adds a
Line 29: new feature to an existing body of code, for example. You’ll explore how to
Line 30: report erratum  •  discuss
Line 31: 
Line 32: --- 페이지 258 ---
Line 33: help your LLM do a better job with that challenge in this chapter. But left to
Line 34: its own devices, an LLM is increasingly likely to break existing functionality
Line 35: as it adds new increments.
Line 36: Do not trust any AI-generated code to be correct.
Line 37: I’ve been pleasantly surprised, though: more often than not, the code LLMs
Line 38: (including ChatGPT, Meta.ai, and Claude) have produced for me has been
Line 39: correct. But I’ve also seen them generate enough wrong code to know that I
Line 40: could never fully depend on it.
Line 41: From these limitations arises a critical need: if you’re going to use AI tools to
Line 42: generate code, you’ll need to create and run tests.
Line 43: Fortunately, you’ve read the rest of this book (right?) and know how to do
Line 44: just that. Even better, AI will speed you up by coding the tests.
Line 45: Give the benefit of the doubt to your pair programmer—whether artificial or
Line 46: human—but assume that you can both make mistakes. доверяй, но проверяй.
Line 47: (“Trust, but verify.”)
Line 48: Note: as I write this, you can also use tools like GitHub Copilot, JetBrains AI
Line 49: Assistant, and Duet to help you develop. These tools sit atop one or more
Line 50: LLMs and provide what can best be described as AI-assisted code completion.
Line 51: I highly recommend incorporating them into your regular code development
Line 52: process. In this chapter, however, you’ll focus on using a test-driven process
Line 53: for generating code at the class level—with the intent of maximizing the
Line 54: amount of (verified) code that AI can generate for you.
Line 55: Exploring a Simple Example with ChatGPT
Line 56: Interaction with an LLM via prompting is a conversation. That conversation
Line 57: may play out very differently the next time I have it. As a result, it’s probably
Line 58: best if this chapter reads as a story about my personal interaction with
Line 59: ChatGPT on a small example. Accordingly, unlike the rest of the book, this
Line 60: chapter is written in first-person past tense.
Line 61: I held my conversation with OpenAI’s chatbot, ChatGPT, which at the time
Line 62: was based on the GPT-4 LLM. My subsequent mentions of ChatGPT refer to
Line 63: this configuration. While other models may exist that have been trained to be
Line 64: optimized for programming tasks (Code Llama for example), the experience I
Line 65: Chapter 13. Keeping AI Honest with Unit Tests • 246
Line 66: report erratum  •  discuss
Line 67: 
Line 68: --- 페이지 259 ---
Line 69: relay in this chapter demonstrates an approach that will work—and will only
Line 70: get better with time—with virtually any current LLM.
Line 71: I was responsible for producing an event check-in list. Given a list of attendees, I
Line 72: needed to write code that sorted them. Attendee names started with a first
Line 73: name, followed by zero or more “middle” names, followed by the surname or
Line 74: last name. Some examples:
Line 75: Jeffrey John Langr
Line 76: John Jacob Jingleheimer-Schmidt
Line 77: John Yossarian
Line 78: Arthur Ignatius Conan Doyle
Line 79: The check-in list needed to show names in alphabetical order based on the last
Line 80: name, not the first name. I had to “normalize” each name, then, into the form
Line 81: “Last, First M. I.”:
Line 82: Langr, Jeffrey J.
Line 83: Jingleheimer-Schmidt, John J.
Line 84: Yossarian, John
Line 85: Doyle, Arthur I. C.
Line 86: Oh I. C. indeed: the middle names are transformed into initials. Other rules
Line 87: implicit in these examples include the obvious fact that names are separated
Line 88: by spaces and that a comma should appear after each last name.
Line 89: I focused on the task of normalizing a single name, deferring the trivial task
Line 90: of sorting a list of names. First, however, I wanted to teach my LLM how to
Line 91: write code to help me and ChatGPT work better together.
Line 92: Establishing a Java Standard
Line 93: By default, ChatGPT generates stepwise code that requires too much time to
Line 94: fully comprehend. I wanted it to do better, so I supplied a prompt describing
Line 95: the kind of code I wanted:
Line 96: YOU:
Line 97: I will be asking you to write Java code. Write all code as Jeff Langr. Jeff
Line 98: Langr (Jeff) has a specific coding standard. Here are the rules for your standard
Line 99: for Java language programming, which I will refer to as Jeff-Java when appropriate.
Line 100: 1. Use ‘var‘ when declaring local variables and the compiler allows it.
Line 101: 2. Where possible, prefer use of the streams functionality and implement iterative
Line 102: operations using stream functions, such as ‘map‘ and ‘filter‘.
Line 103: 3. For any and all complex expressions—mathematics, complex conditionals, pred-
Line 104: icates, and so on—extract the code to a separate function. This should also hold
Line 105: true for lambdas within a chained stream expression.
Line 106: report erratum  •  discuss
Line 107: Establishing a Java Standard • 247
Line 108: 
Line 109: --- 페이지 260 ---
Line 110: 4. In general, create very short, intention-revealing functions for any complexity.
Line 111: 5. Avoid the use of temporaries in most cases unless there is a strong reason to use
Line 112: them (for example, to use them more than once within a single expression). Instead,
Line 113: extract the temporary’s initialization to a separate function with the same name as
Line 114: the temporary, then inline the temporary to remove it.
Line 115: ChatGPT affirmed my request:
Line 116: CHAT-GPT:
Line 117: Understood! Blah blah blah...
Line 118: You might wonder why I even bothered telling my LLM to improve the code.
Line 119: If an LLM can generate the code I need, I shouldn’t have to read it.
Line 120: However, hearken back to the earlier mentioned limitations of LLMs like
Line 121: ChatGPT. They’re gonna be wrong at times…just like you and me. You’ll have
Line 122: to read and manually update some amount of code. Even as that need likely
Line 123: diminishes over time, keeping your code organized (by predominantly creating
Line 124: small classes and methods) appears to increase the odds that the LLM-
Line 125: generated code is correct.
Line 126: Providing Examples to ChatGPT
Line 127: Incrementally test driving small, unit behaviors into a system remains the
Line 128: best choice for humans. For an LLM, maybe not.
Line 129: I first tried getting ChatGPT to consume all my requirements for the name
Line 130: normalizer at once. The code was a mess, and it didn’t work. I took the next-
Line 131: smaller step, which was to first give it a subset containing the four core cases
Line 132: it needed to cover. I helped ChatGPT focus on what I believe to be a proper
Line 133: design—one that, in general, is based on small classes and small methods.
Line 134: With such an improved design, I believe ChatGPT had a much better chance
Line 135: to correctly generate new increments.
Line 136: One of the best ways to get good results from an LLM is to provide examples
Line 137: in your prompts. I followed that advice for the name normalizer after first
Line 138: describing in English what I wanted. My prompt provided five examples for
Line 139: four core cases:
Line 140: YOU:
Line 141: Write Java code for a feature known as the name normalizer. Given a per-
Line 142: son’s name, the name normalizer should return the last name first, followed by a
Line 143: comma, then the first name.
Line 144: If there is one or more middle names, return the initial of each. The initial is the first
Line 145: letter followed by a period.
Line 146: Assume that the name provided to the method is never empty or null.
Line 147: Chapter 13. Keeping AI Honest with Unit Tests • 248
Line 148: report erratum  •  discuss
Line 149: 
Line 150: --- 페이지 261 ---
Line 151: Examples:
Line 152: input: Plato
Line 153: output: Plato
Line 154: input: Leonard Cohen
Line 155: output: Cohen, Leonard
Line 156: input: Samuel Leroy Jackson
Line 157: output: Jackson, Samuel L.
Line 158: input: George Raymond Richard Martin
Line 159: output: Martin, George R. R.
Line 160: input: Emma Azalia Smith Hackley
Line 161: output: Hackley, Emma A. S.
Line 162: Unit tests and examples are birds of a feather—remember this tip from
Line 163: Chapter 10, Streamlining Your Tests, on page 189:
Line 164: Good tests provide examples of how clients interact with the
Line 165: system.
Line 166: Accordingly, I told my LLM to translate the examples into tests:
Line 167: YOU:
Line 168: Also, provide JUnit tests for the core cases.
Line 169: I took a few seconds to vet the tests that ChatGPT generated to ensure that
Line 170: they correctly aligned with my examples. ChatGPT did a decent job, generating
Line 171: tests that used the same data as the examples I provided:
Line 172: utj3-ai/01/src/test/java/util/NameNormalizerTest.java
Line 173: import org.junit.jupiter.api.Test;
Line 174: import static org.junit.jupiter.api.Assertions.assertEquals;
Line 175: public class NameNormalizerTest {
Line 176: @Test
Line 177: public void testSingleName() {
Line 178: assertEquals("Plato",
Line 179: NameNormalizer.normalizeName("Plato"));
Line 180: }
Line 181: @Test
Line 182: public void testFirstNameLastName() {
Line 183: assertEquals("Cohen, Leonard",
Line 184: NameNormalizer.normalizeName("Leonard Cohen"));
Line 185: }
Line 186: report erratum  •  discuss
Line 187: Providing Examples to ChatGPT • 249
Line 188: 
Line 189: --- 페이지 262 ---
Line 190: @Test
Line 191: public void testMultipleMiddleNames() {
Line 192: assertEquals("Jackson, Samuel L.",
Line 193: NameNormalizer.normalizeName("Samuel Leroy Jackson"));
Line 194: assertEquals("Martin, George R. R.",
Line 195: NameNormalizer.normalizeName("George Raymond Richard Martin"));
Line 196: }
Line 197: @Test
Line 198: public void testLongName() {
Line 199: assertEquals("Hackley, Emma A. S.",
Line 200: NameNormalizer.normalizeName("Emma Azalia Smith Hackley"));
Line 201: }
Line 202: }
Line 203: ChatGPT got a little confused regarding the tests testMultipleMiddleNames and
Line 204: testLongName. I had ChatGPT fix this later (as I also did with the unnecessary test
Line 205: prefix for each test).
Line 206: ChatGPT did a job (in other words, not a fine one) generating the corresponding
Line 207: normalizer implementation:
Line 208: utj3-ai/01/src/main/java/util/NameNormalizer.java
Line 209: import java.util.Arrays;
Line 210: import java.util.stream.Collectors;
Line 211: public class NameNormalizer {
Line 212: public static String normalizeName(String name) {
Line 213: var nameParts = name.split(" ");
Line 214: if (nameParts.length == 1) {
Line 215: return name;
Line 216: }
Line 217: var lastName = nameParts[nameParts.length - 1];
Line 218: var firstName = nameParts[0];
Line 219: var middleNames =
Line 220: Arrays.copyOfRange(nameParts, 1, nameParts.length - 1);
Line 221: return formatLastNameFirst(lastName, firstName, middleNames);
Line 222: }
Line 223: private static String formatLastNameFirst(
Line 224: String lastName, String firstName, String[] middleNames) {
Line 225: var middleInitials = Arrays.stream(middleNames)
Line 226: .map(NameNormalizer::extractInitial)
Line 227: .collect(Collectors.joining(" "));
Line 228: return middleInitials.isEmpty() ?
Line 229: String.format("%s, %s", lastName, firstName) :
Line 230: String.format("%s, %s %s", lastName, firstName, middleInitials);
Line 231: }
Line 232: Chapter 13. Keeping AI Honest with Unit Tests • 250
Line 233: report erratum  •  discuss
Line 234: 
Line 235: --- 페이지 263 ---
Line 236: private static String extractInitial(String name) {
Line 237: return name.charAt(0) + ".";
Line 238: }
Line 239: }
Line 240: Telling Your LLM to Clean Up Its Act
Line 241: The LLM’s solution passed the tests, and it wasn’t bad, actually, but there
Line 242: were a few wrinkles to iron out. First, it didn’t include a package name, which
Line 243: forced me to copy only part of its solution rather than wholesale copy-and-
Line 244: replace the generated code, which is a lot faster. (I’m imagining a near future
Line 245: where integration with IDEs is a lot better, and, in fact, I’ve begun building
Line 246: such a plugin myself.)
Line 247: Here’s my prompt to tell the LLM to add the package name, as well as smooth
Line 248: out the aforementioned wrinkles:
Line 249: YOU:
Line 250: The code should live in a Java package named util.
Line 251: The Jeff-Java standard indicates that you should avoid the use of temporaries in
Line 252: methods, but normalizeName has three temps that should be eliminated.
Line 253: Do not include the word test in the test name; it is redundant.
Line 254: Do not use static methods for the implementation. Prefer using instance methods
Line 255: for generated code.
Line 256: Update the Jeff-Java standard where appropriate to fix these problems for any code
Line 257: generated going forward.
Line 258: ChatGPT did a good job of delivering:
Line 259: utj3-ai/02/src/test/java/util/NameNormalizerTest.java
Line 260: import org.junit.jupiter.api.Test;
Line 261: import static org.junit.jupiter.api.Assertions.assertEquals;
Line 262: public class NameNormalizerTest {
Line 263: private final NameNormalizer normalizer = new NameNormalizer();
Line 264: @Test
Line 265: public void singleName() {
Line 266: assertEquals("Plato", normalizer.normalizeName("Plato"));
Line 267: }
Line 268: @Test
Line 269: public void firstNameLastName() {
Line 270: assertEquals("Cohen, Leonard",
Line 271: normalizer.normalizeName("Leonard Cohen"));
Line 272: }
Line 273: report erratum  •  discuss
Line 274: Telling Your LLM to Clean Up Its Act • 251
Line 275: 
Line 276: --- 페이지 264 ---
Line 277: @Test
Line 278: public void multipleMiddleNames() {
Line 279: assertEquals("Jackson, Samuel L.",
Line 280: normalizer.normalizeName("Samuel Leroy Jackson"));
Line 281: assertEquals("Martin, George R. R.",
Line 282: normalizer.normalizeName("George Raymond Richard Martin"));
Line 283: }
Line 284: @Test
Line 285: public void longName() {
Line 286: assertEquals("Hackley, Emma A. S.",
Line 287: normalizer.normalizeName("Emma Azalia Smith Hackley"));
Line 288: }
Line 289: }
Line 290: utj3-ai/02/src/main/java/util/NameNormalizer.java
Line 291: import java.util.Arrays;
Line 292: import java.util.stream.Collectors;
Line 293: public class NameNormalizer {
Line 294: public String normalizeName(String name) {
Line 295: var nameParts = name.split(" ");
Line 296: if (nameParts.length == 1) {
Line 297: return name;
Line 298: }
Line 299: return formatLastNameFirst(nameParts[0],
Line 300: nameParts[nameParts.length - 1],
Line 301: Arrays.copyOfRange(
Line 302: nameParts, 1, nameParts.length - 1));
Line 303: }
Line 304: private String formatLastNameFirst(
Line 305: String firstName, String lastName, String[] middleNames) {
Line 306: var middleInitials = Arrays.stream(middleNames)
Line 307: .map(this::extractInitial)
Line 308: .collect(Collectors.joining(" "));
Line 309: return middleInitials.isEmpty() ?
Line 310: String.format("%s, %s", lastName, firstName) :
Line 311: String.format("%s, %s %s", lastName, firstName, middleInitials);
Line 312: }
Line 313: private String extractInitial(String name) {
Line 314: return name.charAt(0) + ".";
Line 315: }
Line 316: }
Line 317: And once again, all tests passed.
Line 318: I disliked a few of its choices, but found the code fairly easy to follow and…
Line 319: almost good enough. I complained immediately:
Line 320: Chapter 13. Keeping AI Honest with Unit Tests • 252
Line 321: report erratum  •  discuss
Line 322: 
Line 323: --- 페이지 265 ---
Line 324: YOU:
Line 325: The arguments to formatLastNameFirst should have first been extracted to new
Line 326: functions, perhaps named firstName, middleNames, and lastName respectively.
Line 327: Update the Jeff-Java standard to indicate that the right-hand side of an assignment
Line 328: should first be extracted to a new function before inlining, if it is anything that
Line 329: involves "implementation-specific details," i.e., anything that might need to be
Line 330: explained.
Line 331: Now we were talking! ChatGPT was doing a pretty good job of listening.
Line 332: utj3-ai/03/src/main/java/util/NameNormalizer.java
Line 333: import java.util.Arrays;
Line 334: import java.util.stream.Collectors;
Line 335: public class NameNormalizer {
Line 336: public String normalizeName(String name) {
Line 337: var nameParts = name.split(" ");
Line 338: if (nameParts.length == 1) {
Line 339: return name;
Line 340: }
Line 341: return formatLastNameFirst(
Line 342: ➤
Line 343: firstName(nameParts),
Line 344: ➤
Line 345: lastName(nameParts),
Line 346: ➤
Line 347: middleNames(nameParts));
Line 348: ➤
Line 349: }
Line 350: private String firstName(String[] nameParts) {
Line 351: ➤
Line 352: return nameParts[0];
Line 353: ➤
Line 354: }
Line 355: ➤
Line 356: private String lastName(String[] nameParts) {
Line 357: ➤
Line 358: return nameParts[nameParts.length - 1];
Line 359: ➤
Line 360: }
Line 361: ➤
Line 362: private String[] middleNames(String[] nameParts) {
Line 363: ➤
Line 364: return Arrays.copyOfRange(
Line 365: ➤
Line 366: nameParts, 1, nameParts.length - 1);
Line 367: ➤
Line 368: }
Line 369: ➤
Line 370: private String formatLastNameFirst(
Line 371: String firstName, String lastName, String[] middleNames) {
Line 372: var middleInitials = Arrays.stream(middleNames)
Line 373: .map(this::extractInitial)
Line 374: .collect(Collectors.joining(" "));
Line 375: return middleInitials.isEmpty() ?
Line 376: String.format("%s, %s", lastName, firstName) :
Line 377: String.format("%s, %s %s", lastName, firstName, middleInitials);
Line 378: }
Line 379: private String extractInitial(String name) {
Line 380: return name.charAt(0) + ".";
Line 381: }
Line 382: }
Line 383: report erratum  •  discuss
Line 384: Telling Your LLM to Clean Up Its Act • 253
Line 385: 
Line 386: --- 페이지 266 ---
Line 387: The code was at the point where I could easily reason about exactly what was
Line 388: going on. It took only a moment to understand any one method and trust
Line 389: that it did what it said.
Line 390: I prompted ChatGPT to fix a few more things:
Line 391: YOU:
Line 392: Simplify the method named extractInitial to initial.
Line 393: Move the assertion for "Samuel Leroy Jackson" to a new test initializesMiddleName.
Line 394: Move the assertion for "Emma Azalia Smith Hackley" to the test multipleMiddleNames.
Line 395: Eliminate the arguments to formatLastNameFirst. Instead, have its code directly access
Line 396: the functions firstName, lastName, and middleNames.
Line 397: ChatGPT complied:
Line 398: utj3-ai/04/src/test/java/util/NameNormalizerTest.java
Line 399: @Test
Line 400: public void initializesMiddleName() {
Line 401: assertEquals("Jackson, Samuel L.",
Line 402: normalizer.normalizeName("Samuel Leroy Jackson"));
Line 403: }
Line 404: @Test
Line 405: public void multipleMiddleNames() {
Line 406: assertEquals("Martin, George R. R.",
Line 407: normalizer.normalizeName("George Raymond Richard Martin"));
Line 408: assertEquals("Hackley, Emma A. S.",
Line 409: normalizer.normalizeName("Emma Azalia Smith Hackley"));
Line 410: }
Line 411: utj3-ai/04/src/main/java/util/NameNormalizer.java
Line 412: public String normalizeName(String name) {
Line 413: this.nameParts = name.split(" ");
Line 414: if (nameParts.length == 1) {
Line 415: return name;
Line 416: }
Line 417: return formatLastNameFirst();
Line 418: }
Line 419: // ...
Line 420: private String formatLastNameFirst() {
Line 421: ➤
Line 422: var middleInitials = Arrays.stream(middleNames())
Line 423: .map(this::initial)
Line 424: .collect(Collectors.joining(" "));
Line 425: return middleInitials.isEmpty() ?
Line 426: String.format("%s, %s", lastName(), firstName()) :
Line 427: ➤
Line 428: String.format("%s, %s %s", lastName(), firstName(), middleInitials);
Line 429: ➤
Line 430: }
Line 431: private String initial(String name) {
Line 432: ➤
Line 433: return name.charAt(0) + ".";
Line 434: }
Line 435: Chapter 13. Keeping AI Honest with Unit Tests • 254
Line 436: report erratum  •  discuss
Line 437: 
Line 438: --- 페이지 267 ---
Line 439: Adding a New Feature: Suffixes
Line 440: I moved on to the next code increment, again providing an example for the
Line 441: LLM to translate into a test.
Line 442: YOU:
Line 443: Alter both the code and the tests to support suffixes. A suffix appears after
Line 444: a comma at the end of a name.
Line 445: Examples
Line 446: input: Martin Luther King, Jr.
Line 447: output: King, Martin L., Jr.
Line 448: Here’s what ChatGPT spewed out:
Line 449: utj3-ai/05/src/test/java/util/NameNormalizerTest.java
Line 450: @Test
Line 451: public void nameWithSuffix() {
Line 452: assertEquals("King, Martin L., Jr.",
Line 453: normalizer.normalizeName("Martin Luther King, Jr."));
Line 454: }
Line 455: utj3-ai/05/src/main/java/util/NameNormalizer.java
Line 456: public class NameNormalizer {
Line 457: private String[] nameParts;
Line 458: private String suffix = "";
Line 459: ➤
Line 460: public String normalizeName(String name) {
Line 461: if (name.contains(",")) {
Line 462: ➤
Line 463: var parts = name.split(", ");
Line 464: ➤
Line 465: this.nameParts = parts[0].split(" ");
Line 466: ➤
Line 467: this.suffix = ", " + parts[1];
Line 468: ➤
Line 469: } else {
Line 470: ➤
Line 471: this.nameParts = name.split(" ");
Line 472: ➤
Line 473: }
Line 474: ➤
Line 475: ➤
Line 476: if (nameParts.length == 1) {
Line 477: ➤
Line 478: return name;
Line 479: ➤
Line 480: }
Line 481: ➤
Line 482: ➤
Line 483: return formatLastNameFirst() + suffix;
Line 484: ➤
Line 485: }
Line 486: // ...
Line 487: }
Line 488: That went to pot pretty quickly. It did work, at least for the test case I gave
Line 489: it, but the code was back to stepwise, intertwined logic that was hard to follow.
Line 490: Also, ChatGPT seemed to have forgotten my Jeff-Java style rules.
Line 491: report erratum  •  discuss
Line 492: Adding a New Feature: Suffixes • 255
Line 493: 
Line 494: --- 페이지 268 ---
Line 495: Letting Your LLM Discover Missing Tests
Line 496: Before I asked ChatGPT to fix the code, I took a little detour. I thought it might
Line 497: be useful to ask ChatGPT to generate test cases for its own code but in a new
Line 498: conversation. It produced this:
Line 499: utj3-ai/05/src/test/java/util/NameNormalizerAITest.java
Line 500: public class NameNormalizerAITest {
Line 501: private NameNormalizer normalizer = new NameNormalizer();
Line 502: @Test
Line 503: public void testSimpleTwoPartName() {
Line 504: assertEquals("Doe, John", normalizer.normalizeName("John Doe"));
Line 505: }
Line 506: @Test
Line 507: public void testNameWithMiddleInitial() {
Line 508: assertEquals("Doe, John A.",
Line 509: normalizer.normalizeName("John A. Doe"));
Line 510: }
Line 511: @Test
Line 512: public void testNameWithSuffix() {
Line 513: assertEquals("Doe, John Jr.",
Line 514: normalizer.normalizeName("John Doe, Jr."));
Line 515: }
Line 516: @Test
Line 517: public void testSingleName() {
Line 518: assertEquals("John", normalizer.normalizeName("John"));
Line 519: }
Line 520: @Test
Line 521: public void testNameWithMiddleNames() {
Line 522: assertEquals("Doe, John A. B.",
Line 523: normalizer.normalizeName("John Adam Bernard Doe"));
Line 524: }
Line 525: @Test
Line 526: public void testEmptyString() {
Line 527: assertEquals("", normalizer.normalizeName(""));
Line 528: }
Line 529: // Optional: If handling null is expected
Line 530: @Test
Line 531: public void testNullInput() {
Line 532: assertEquals(null, normalizer.normalizeName(null));
Line 533: }
Line 534: }
Line 535: The generated test cases were decent, though again, they ignored the Jeff-
Line 536: Java rule around test names. When I ran them, I discovered two test failures:
Line 537: Chapter 13. Keeping AI Honest with Unit Tests • 256
Line 538: report erratum  •  discuss
Line 539: 
Line 540: --- 페이지 269 ---
Line 541: testNameWithSuffix and testNullInput. I ignored testNullInput since I’d decided the input
Line 542: to normalizeName couldn’t ever be null.
Line 543: The other failing test, testNameWithSuffix, involved a two-part name, whereas I’d
Line 544: only provided a three-part name to ChatGPT as an example. When I copied
Line 545: the test code for testNameWithSuffix into NameNormalizerTest, it still failed.
Line 546: ChatGPT indeed had discerned the need for a test case that I’d missed! The
Line 547: failing test didn’t point out a problem with the code, though—its expected
Line 548: output for “John Doe, Jr.” was incorrect (it should have been “Doe, John,
Line 549: Jr.”, with a comma after the first name).
Line 550: I considered what I knew about iterating via ZOM (see ZOM: Zero and One
Line 551: Done, Now Testing Many, on page 22) and gave ChatGPT a one-two-three set
Line 552: of examples.
Line 553: YOU:
Line 554: Try again with the following changes.
Line 555: Alter both the code and the tests to support suffixes. A suffix appears after a comma
Line 556: at the end of a name.
Line 557: Examples
Line 558: input: Madonna, Esq.
Line 559: output: Madonna, Esq.
Line 560: input: John Doe, Sr.
Line 561: output: Doe, John, Sr.
Line 562: input: Martin Luther King, Jr.
Line 563: output: King, Martin L., Jr.
Line 564: Ensure you use the Jeff-Java standard. Most importantly, find a way to keep the
Line 565: suffix code isolated from as much of the existing code within NameNormalizer as
Line 566: possible.
Line 567: Do not include any tests around a null name.
Line 568: At first glance, the result looked promising:
Line 569: utj3-ai/06/src/test/java/util/NameNormalizerTest.java
Line 570: @Test
Line 571: public void nameWithSuffix() {
Line 572: assertEquals("King, Martin L., Jr.",
Line 573: normalizer.normalizeName("Martin Luther King, Jr."));
Line 574: assertEquals("Doe, John, Sr.",
Line 575: normalizer.normalizeName("John Doe, Sr."));
Line 576: }
Line 577: report erratum  •  discuss
Line 578: Adding a New Feature: Suffixes • 257
Line 579: 
Line 580: --- 페이지 270 ---
Line 581: @Test
Line 582: public void singleNameWithSuffix() {
Line 583: assertEquals("Madonna, Esq.",
Line 584: normalizer.normalizeName("Madonna, Esq."));
Line 585: }
Line 586: utj3-ai/06/src/main/java/util/NameNormalizer.java
Line 587: public class NameNormalizer {
Line 588: private String[] nameParts;
Line 589: private String suffix = "";
Line 590: public String normalizeName(String name) {
Line 591: extractSuffix(name);
Line 592: if (nameParts.length == 1 && suffix.isEmpty()) {
Line 593: return name;
Line 594: }
Line 595: return formatLastNameFirst() + suffix;
Line 596: }
Line 597: private void extractSuffix(String name) {
Line 598: if (name.contains(",")) {
Line 599: var parts = name.split(", ", 2);
Line 600: this.nameParts = parts[0].split(" ");
Line 601: this.suffix = ", " + parts[1];
Line 602: } else {
Line 603: this.nameParts = name.split(" ");
Line 604: }
Line 605: }
Line 606: // ...
Line 607: }
Line 608: The AI solution was awkward. The method extractSuffix did extract the suffix,
Line 609: but it also set a value into nameParts, making the logic much harder to follow.
Line 610: A better solution would involve a pure function named extractSuffix that does
Line 611: only that—given a name, return the suffix or empty string.
Line 612: I ignored the deficiency. ChatGPT was teaching me not to sweat the small
Line 613: stuff as much—unlike building my own code, where tending to all the
Line 614: small things speeds me up over time.
Line 615: It had also become apparent that nitpicking every nuance of what the LLM
Line 616: produced seemed like it would take hours. I decided I’d prompt ChatGPT to
Line 617: fix the problem if I needed to revisit the extractSuffix method.
Line 618: From AI, “good enough to have an easy conversation about” is
Line 619: good enough.
Line 620: Chapter 13. Keeping AI Honest with Unit Tests • 258
Line 621: report erratum  •  discuss
Line 622: 
Line 623: --- 페이지 271 ---
Line 624: ChatGPT Breaks the Code
Line 625: On the surface, the code ChatGPT produced was reasonable, except for the way
Line 626: it had designed extractSuffix. Alas, I now had a test failure involving poor Madonna.
Line 627: Expected :Madonna, Esq.
Line 628: Actual
Line 629: :Madonna, Madonna, Esq.
Line 630: “Madonna, Madonna, Esquire?” Sounds like a potential song, maybe a blatant
Line 631: ripoff of “Vogue.” Maybe I should get ChatGPT to write some lyrics. (I did.)
Line 632: 1
Line 633: I went with the lazy flow—I asked ChatGPT to fix its mistake. (It broke stuff,
Line 634: so why should I fix it?) ChatGPT has had the effect of making me lazy, but
Line 635: maybe that’s the good kind of lazy.
Line 636: YOU:
Line 637: Expected :Madonna, Esq.
Line 638: Actual :Madonna, Madonna, Esq.
Line 639: See if you can fix the problem.
Line 640: The LLM had a sense of what was going on and how to fix it:
Line 641: CHAT-GPT:
Line 642: The issue with the Madonna-based test case failing is due to how the
Line 643: normalization logic is applied even when there’s only a single name part before
Line 644: the suffix, leading to the repetition of the name. To fix this, we need to adjust the
Line 645: logic to correctly handle cases where there’s only a single name part (i.e., no first
Line 646: and last name separation, but potentially a suffix).
Line 647: The fix offered did pass the tests:
Line 648: utj3-ai/07/src/main/java/util/NameNormalizer.java
Line 649: public String normalizeName(String name) {
Line 650: extractSuffix(name);
Line 651: // Handle case for 1 name w/ no middle names but possible a suffix
Line 652: if (nameParts.length == 1) {
Line 653: ➤
Line 654: return nameParts[0] + suffix;
Line 655: ➤
Line 656: }
Line 657: ➤
Line 658: return formatLastNameFirst() + suffix;
Line 659: }
Line 660: Defects in code are often good at hiding themselves—broken things may look
Line 661: reasonable. But reasonable isn’t correct.
Line 662: Don’t ship code just because it looks good.
Line 663: 1.
Line 664: https://langrsoft.com/2024/01/23/madonna/
Line 665: report erratum  •  discuss
Line 666: Adding a New Feature: Suffixes • 259
Line 667: 
Line 668: --- 페이지 272 ---
Line 669: Getting the LLM to Do Final Design Cleanup
Line 670: The last thing to tackle was some final code cleanup.
Line 671: YOU:
Line 672: The solution works. The method extractSuffix should be reworked, however,
Line 673: into a pure function (i.e., with no side effects). The side effects, if needed, should
Line 674: occur in normalizeName.
Line 675: Also, I just noticed the silliness in formatLastNameFirst. Inline the temporaries, please.
Line 676: Oh my. I don’t want to show you the abomination it produced, but I suppose
Line 677: I must. Here’s a small piece of it:
Line 678: utj3-ai/08/src/main/java/util/NameNormalizer.java
Line 679: public String normalizeName(String name) {
Line 680: var extractedResult = extractSuffix(name);
Line 681: var nameParts = extractedResult[0].split(" ");
Line 682: var suffix = extractedResult[1];
Line 683: if (nameParts.length == 1) {
Line 684: return nameParts[0] + suffix;
Line 685: }
Line 686: var middleInitials = Arrays.stream(middleNames(nameParts))
Line 687: .map(this::initial)
Line 688: .collect(Collectors.joining(" "));
Line 689: return (nameParts[nameParts.length - 1] + ", " + nameParts[0] +
Line 690: (middleInitials.isEmpty() ? "" : " " + middleInitials)) + suffix;
Line 691: }
Line 692: I was a little upset at this point. My message to ChatGPT wasn’t very pleasant.
Line 693: YOU:
Line 694: Undo that last change. It’s horrible. You inlined the helper functions like
Line 695: last(). Show me the prior version.
Line 696: Thankfully, ChatGPT only undid the inlining mess. It retained the conversion
Line 697: of extractSuffix to a functional method:
Line 698: utj3-ai/09/src/main/java/util/NameNormalizer.java
Line 699: public String normalizeName(String name) {
Line 700: var result = extractSuffix(name);
Line 701: this.nameParts = result[0].split(" ");
Line 702: this.suffix = result[1];
Line 703: if (nameParts.length == 1) {
Line 704: return nameParts[0] + suffix;
Line 705: }
Line 706: return formatLastNameFirst() + suffix;
Line 707: }
Line 708: Chapter 13. Keeping AI Honest with Unit Tests • 260
Line 709: report erratum  •  discuss
Line 710: 
Line 711: --- 페이지 273 ---
Line 712: private String[] extractSuffix(String name) {
Line 713: if (name.contains(",")) {
Line 714: var parts = name.split(", ", 2);
Line 715: return new String[] {parts[0], ", " + parts[1]};
Line 716: } else {
Line 717: return new String[] {name, ""};
Line 718: }
Line 719: }
Line 720: private String formatLastNameFirst() {
Line 721: return lastName() + ", " + firstName() + middleInitialsString();
Line 722: }
Line 723: private String firstName() {
Line 724: return nameParts[0];
Line 725: }
Line 726: private String lastName() {
Line 727: return nameParts[nameParts.length - 1];
Line 728: }
Line 729: private String middleInitialsString() {
Line 730: if (nameParts.length > 2) {
Line 731: return " " + Arrays.stream(middleNames())
Line 732: .map(this::initial)
Line 733: .collect(Collectors.joining(" "));
Line 734: }
Line 735: return "";
Line 736: }
Line 737: private String[] middleNames() {
Line 738: if (nameParts.length > 2) {
Line 739: return Arrays.copyOfRange(nameParts, 1, nameParts.length - 1);
Line 740: }
Line 741: return new String[]{};
Line 742: }
Line 743: private String initial(String name) {
Line 744: return name.charAt(0) + ".";
Line 745: }
Line 746: }
Line 747: Its new solution clarified to me what ChatGPT was trying to do all along, but
Line 748: I hadn’t noticed. The extractSuffix method was now returning a tuple—or Java’s
Line 749: code-heavy version of one—a two-dimensional array containing the base name
Line 750: and suffix. With modern Java, using a record seemed a better choice.
Line 751: YOU:
Line 752: Replace the tuple returned by extractSuffix with a version that uses a Java
Line 753: record, defined as a nested class within NameNormalizer.
Line 754: report erratum  •  discuss
Line 755: Getting the LLM to Do Final Design Cleanup • 261
Line 756: 
Line 757: --- 페이지 274 ---
Line 758: ChatGPT did the job:
Line 759: utj3-ai/10/src/main/java/util/NameNormalizer.java
Line 760: private record ExtractedNameParts(String[] nameParts, String suffix) {}
Line 761: public String normalizeName(String name) {
Line 762: var extractedNameParts = extractSuffix(name);
Line 763: this.nameParts = extractedNameParts.nameParts();
Line 764: this.suffix = extractedNameParts.suffix();
Line 765: if (nameParts.length == 1) {
Line 766: return nameParts[0] + suffix;
Line 767: }
Line 768: return formatLastNameFirst() + suffix;
Line 769: }
Line 770: private ExtractedNameParts extractSuffix(String name) {
Line 771: if (name.contains(",")) {
Line 772: var parts = name.split(", ", 2);
Line 773: return new ExtractedNameParts(parts[0].split(" "), ", " + parts[1]);
Line 774: } else {
Line 775: return new ExtractedNameParts(name.split(" "), "");
Line 776: }
Line 777: }
Line 778: I’ll take it. I felt that the code still had numerous little problems, particularly
Line 779: some bits where the code didn’t declare well what was going on. For example,
Line 780: what’s nameParts[0]? What’s parts[0]?
Line 781: But maybe that’s okay. I reminded myself that I wasn’t trying to create “perfect”
Line 782: code. (As if there was such a thing.)
Line 783: It is important that an AI solution is composed of focused units. (Huh!) Small,
Line 784: single-purpose methods allow ChatGPT to employ intention-revealing, accurate
Line 785: method and variable names. In turn, those small, accurately named concepts
Line 786: allow both the LLM and you (or me) to continue with a sensible conversation
Line 787: as you add more increments and fix problems.
Line 788: For Extra Credit
Line 789: Start a similar conversation with your LLM of choice to build the name nor-
Line 790: malizer. Then, see how effective a solution it can produce by prompting a
Line 791: couple more features.
Line 792: 1.
Line 793: Harry Truman had a single-letter middle name, sort of, implying that it
Line 794: should not be abbreviated with a period.
Line 795: input: Harry S Truman
Line 796: output: Truman, Harry S
Line 797: Chapter 13. Keeping AI Honest with Unit Tests • 262
Line 798: report erratum  •  discuss
Line 799: 
Line 800: --- 페이지 275 ---
Line 801: 2.
Line 802: If a person has a salutation, it should precede the first name in the result.
Line 803: Known salutations include Dr, Mr, Mrs, Ms, Sir, Miss, Lord, and Esq.
Line 804: Each salutation may optionally be terminated by a period. Retain the
Line 805: period if it exists.
Line 806: input: Dr. Martin Luther King, Jr.
Line 807: output: King, Jr., Dr. Martin L.
Line 808: input: Sir Patrick Stewart
Line 809: output: Stewart, Sir Patrick
Line 810: If you really want to get wild, a version supporting non-Western names would
Line 811: no doubt involve numerous additional rules.
Line 812: Increasing Odds of Success with AI-Generated Code
Line 813: The most important thing to remember when developing software with an LLM
Line 814: is you can’t trust the code it generates. The skills you obtained in Pragmatic
Line 815: Unit Testing in Java with JUnit, however, provide you with a basis for verifying
Line 816: the code. Consider always following the CAX cycle, as demonstrated in this
Line 817: chapter, for generating code:
Line 818: • Create both production code and tests when prompting the LLM, using
Line 819: (ZOM-inclusive) examples as the basis for the tests.
Line 820: • Assess the fidelity of the generated tests with the examples you provided.
Line 821: • e*Xecute the tests. Repeat the cycle (with alterations) if they don’t all pass.
Line 822: Also, provide a small set of programming style guidelines to your LLM to
Line 823: improve the solution’s design and potentially increase the likelihood of a
Line 824: correct solution. Jeff-Java style represents a good starting point.
Line 825: Will I Go Faster?
Line 826: AI tools are only now emerging from their infancy, but they show a lot of
Line 827: promise. As with human toddlers, they thrive when you provide them with
Line 828: some direction and safeguards, but they can also surprise you with their
Line 829: cleverness, particularly when you let them explore.
Line 830: Good design makes so many things easier: writing tests around code, under-
Line 831: standing code, extending code, and so on. Generating code via an LLM is also
Line 832: easier when you direct it to follow a small set of guidelines for design that
Line 833: promote small, focused methods and intention-revealing names.
Line 834: report erratum  •  discuss
Line 835: Increasing Odds of Success with AI-Generated Code • 263
Line 836: 
Line 837: --- 페이지 276 ---
Line 838: Will using an LLM speed you up? I believe the answer will be increasingly
Line 839: yes. For now, it will speed you up at least as much as any auto-code-complete
Line 840: mechanisms speed you up. You’re typing far less, for one.
Line 841: Personally, I can go considerably faster than an LLM for some pieces of pro-
Line 842: ducing a solution, particularly around small adjustments to the way I want
Line 843: the code expressed. But there are many operations that LLMs can do faster
Line 844: than me. For example, it was quicker to change the array-based tuple to a
Line 845: record than it would have been by hand. It’s also a lot faster to have the LLM
Line 846: generate tests from examples.
Line 847: Maybe my biggest speed-up is that I can take larger steps with an LLM than
Line 848: with TDD, where I do one small thing at a time. Sure, AI will get some things
Line 849: wrong as a result of the larger steps, but it’s a lot quicker to revert and try
Line 850: something different when it does.
Line 851: Summary
Line 852: In Pragmatic Unit Testing in Java with JUnit, you’ve learned a wealth of
Line 853: approaches, skills, practices, and design tips. You can apply these skills
Line 854: immediately to your work and start to reap the multiple benefits of unit testing.
Line 855: Whether or not you use AI to generate code, unit testing will remain an
Line 856: important tool in your development toolbox. Without good unit tests, you will
Line 857: always proceed with considerable risk. Done properly, unit tests will allow
Line 858: you to go faster and ship with high confidence.
Line 859: Chapter 13. Keeping AI Honest with Unit Tests • 264
Line 860: report erratum  •  discuss